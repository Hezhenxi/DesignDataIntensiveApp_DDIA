# 设计数据密集型应用_DDIA :see_no_evil:
## 目录

<a name="3060-1621846615933"></a>**本书案例方案的感想：利用工程师思维，从问题的正反面入手，科学分析解决的过程。答案不是固定的，只要你能给出符合逻辑事实的解释；**

<a name="vg2e-1740350174259"></a>**解决方案-->方案的长短处-->其它方案**

<a name="ggph-1740363635225"></a>[===数据密集型应用===](#nm5q-1706969255961)

<a name="purv-1740363635227"></a>[序言](#d3cb-1739990087327)

<a name="prqu-1740363635229"></a>[NOSQL!大数据!Web-Scale!分片!最终一致性!ACID! CAP定理!云服务!MapReduce!实时!](#j9wq-1739990271690)

<a name="83qx-1740363635231"></a>[第一部分 数据系统的基石](#unbe-1677787447006)

<a name="xud7-1740363635233"></a>[1.可靠性、可拓展性、可维护性能](#kwfx-1677787447007)

<a name="1vrt-1740363635235"></a>[小结：一个应用必须满足各种需求才称得上有用](#zrzj-1642646974315)

<a name="dkqh-1740363635237"></a>[-功能性需求：CRUD](#lykw-1644227240038)

<a name="apcl-1740363635239"></a>[-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性](#b2tu-1644227249556)

<a name="zkjd-1740363635241"></a>[.可靠性(即使发生故障，系统也能正常工作)](#qqm5-1644227303238)

<a name="bvgp-1740363635243"></a>[故障可能发生在硬件（通常是随机和不相关的）](#mk9e-1644227360160)

<a name="ltzq-1740363635245"></a>[软件（通常是系统性的bug,很难处理）](#w7by-1644227387308)

<a name="xpfx-1740363635247"></a>[人类（不可避免的时不时出错）](#dozl-1644227415061)

<a name="tq62-1740363635249"></a>[容错技术可以对终端用户隐藏某些类型的故障。](#fvz4-1644227444254)

<a name="hbu6-1740363635251"></a>[硬件故障](#7xms-1644228225080)

<a name="rcht-1740363635253"></a>[硬盘的平均无故障时间mean time to failure 约为10~50年](#3gfd-1708357730326)

<a name="fgkl-1740363635255"></a>[aws设计优先考虑灵活性flexibility 和 弹性 elasticity,而非单机可靠性，所以虚拟机实例不可用却无任何告警](#yusj-1708357802977)

<a name="kqfd-1740363635257"></a>[软件错误](#dfpv-1708357497902)

<a name="opak-1740363635259"></a>[系统性错误 ](#ptxr-1708357908223)

<a name="vcph-1740363635261"></a>[测量监控系统行为，运行时不断自检，出现差异desrepancy时报警](#ybic-1708358007856)

<a name="ss7h-1740363635263"></a>[人为错误(如何让系统变得可靠)](#drpl-1708357507365)

<a name="lnwg-1740363635265"></a>[既然人类不可靠，如何让系统变得可靠：](#eb1v-1708358093033)

<a name="3fzj-1740363635267"></a>[。最小化犯错机会的方式设计系统,  但如果限制太多，人们可能会忽略它们的好处而绕开，很难把握其中微妙的平衡](#i4we-1708358144376)

<a name="sqxi-1740363635269"></a>[。在易错地方和可能导致失效的地方解耦decouple,提供非生产环境沙箱sandbox-虚拟化环境，隔离真实系统进行安全测试](#xzfa-1708358243121)

<a name="dzle-1740363635271"></a>[。彻底的测试，单元测试，集成测试，手动测试，自动化测试覆盖边缘场景corner case.](#9jaa-1708358634289)

<a name="77k7-1740363635273"></a>[。滚动发布，快速回滚](#zlp4-1708358698137)

<a name="yizm-1740363635275"></a>[。配置详细和明确的监控](#40us-1708358954660)

<a name="j4s2-1740363635277"></a>[。良好的管理和充分的培训。一个复杂而重要的方面，但超出本书的范围](#o66x-1708358967000)

<a name="ydl2-1740363635279"></a>[可靠性有多重要](#x7co-1708357515795)

<a name="c0z7-1740363635281"></a>[造成客户巨大损失-阿里云宕机造成的用户损失](#nc0w-1708358745350)

<a name="uogm-1740363635283"></a>[家长将孩子照片存储在你的应用里，数据库损坏，客户有何体验，他们可能会知道如何从备份恢复吗？](#qopp-1708358856827)

<a name="isaq-1740363635285"></a>[.可扩展性(即使在增加负载的情况下也能保持性能的策略)](#dsae-1708357483848)

<a name="yurw-1740363635287"></a>[定量描述负载和性能的方法。](#gqfn-1644228379215)

<a name="wjom-1740363635289"></a>[推特主页时间线，介绍描述负载参数，并将响应时间百分点作为衡量性能的一种方式。头部阻塞、尾部延迟。](#krij-1644228405843)

<a name="xoqn-1740363635291"></a>[(有很多人通过将工作负载迁移到低延迟、自适应的GC来控制尾部延迟-infoQ java趋势)](#unxv-1739960162350)

<a name="wjps-1740363635293"></a>[在可扩展的系统中可以添加处理容量 以在高负载下保持可靠。](#bynr-1644228470161)

<a name="munh-1740363635295"></a>[服务降级degradation的一个常见原因是负载的增加。](#eg4z-1708359118801)

<a name="hul7-1740363635297"></a>[可拓展性Scalability是用来描述系统应对负载增长能力的术语。scalability: 可扩展性；可伸缩性；可量测性](#qd5r-1739959711621)

<a name="lr2e-1740363635299"></a>[PS:scale  n.规模,刻度，大小     健合架构师说开关增减功能是可扩展性LOL](#dgno-1739959800409)

<a name="idtw-1740363635301"></a>[描述负载(tps-推特主页时间线扇出-查询性能优化)](#vja4-1708356470840)

<a name="h5pu-1740363635303"></a>[描述性能](#s6un-1708356581594)

<a name="fmrf-1740363635305"></a>[吞吐量throughput](#fcez-1708523606684)

<a name="sfrk-1740363635307"></a>[响应时间 response time.](#k30f-1708523620292)

<a name="eyzs-1740363635309"></a>[响应时间的高位百分点（也称为尾部延迟tail latencies](#bogk-1708523658968)

<a name="d3ax-1740363635311"></a>[优化99.99百分位点（一万个请求中最慢的一个-尾部延迟）则认为太昂贵了](#uijc-1740357866390)

<a name="gdsa-1740363635314"></a>[.可维护性：（代码:设计模式  系统：检测健康性）](#k1dg-1708355783343)

<a name="wthx-1740363635316"></a>[可操作性：人生苦短，关爱运维。](#mwlq-1739809481662)

<a name="05ux-1740363635318"></a>[简单性：管理复杂度](#zi2h-1739809499485)

<a name="h5ln-1740363635320"></a>[可演化性：拥抱变化  ](#b64f-1739809505843)

<a name="6iam-1740363635322"></a>[可维护性关于工程师和运维团队生活质量的。](#vg1v-1699843968229)

<a name="opam-1740363635324"></a>[良好的抽象降低复杂度，系统易于修改和适应新的应用场景。](#mq1x-1644231096441)

<a name="ecft-1740363635326"></a>[良好的可操作性对系统的健康状态具有良好的可见性，并拥有有效的管理手段。](#qj5f-1644228656997)

<a name="ktlj-1740363635328"></a>[2.数据模型与查询语言](#jufm-1677787447008)

<a name="0c2b-1740363635330"></a>[数据模型是软件开发中最重要的部分，选择一个合适的模型非常重要。](#moyn-1739958400668)

<a name="1h8n-1740363635332"></a>[多数应用是层次结构，如何使用低一层的数据模型表示:](#glyn-1739958437519)

<a name="wikw-1740363635334"></a>[1.开发人员用对象或数据结构API对现实世界对象进行建模](#itiw-1739958558955)

<a name="fxfa-1740363635336"></a>[2.存储选择：JSON，XML,关系型数据库中表、或图模型](#zst8-1739958597323)

<a name="cckm-1740363635338"></a>[3.数据库工程师选定内存、磁盘或网络字节来表示存储便于crud处理](#ndln-1739958769398)

<a name="zyke-1740363635340"></a>[4.硬件工程使用电流，脉冲，磁场等表示字节](#87e2-1739958841062)

<a name="sue7-1740363635342"></a>[关系模型与文档模型](#lynl-1739957541870)

<a name="hyem-1740363635344"></a>[70年代提出sql模型，80年代成为首选](#jomv-1739958926076)

<a name="dall-1740363635346"></a>[典型事务处理：销售，银行交易，航司预定，库存管理](#rcx8-1739958971699)

<a name="bhbd-1740363635348"></a>[批处理（客户发票，工资单，报告）](#jsln-1739959008693)

<a name="ujno-1740363635350"></a>[NoSQL的诞生](#8vxs-1739957588389)

<a name="scja-1740363635352"></a>[09年分布式，非关系数据库上的聚会传播NoSQL:](#h5mi-1739989893599)

<a name="iglf-1740363635354"></a>[比关系数据库更好的可扩展性，大数据集高写入吞吐](#i5dd-1739989949590)

<a name="49z7-1740363635356"></a>[一些特殊的查询操作](#b0qv-1739989985562)

<a name="mric-1740363635358"></a>[渴望多动态多表现力的数据模型](#cliq-1739989941345)

<a name="nxdp-1740363635360"></a>[对象关系不匹配（关系型需要ORM对数据进行转换映射-阻抗不匹配）](#ciyc-1739957588391)

<a name="3zjr-1740363635362"></a>[Linkin简历则直接用Json更合适，使树状结构明确，减少阻抗不匹配](#idg9-1739990650566)

<a name="5vwc-1740363635364"></a>[多对一和多对多的关系](#rdhn-1739957588393)

<a name="eome-1740363635366"></a>[特殊名词用ID限定：](#l9tl-1739990839589)

<a name="qqi3-1740363635368"></a>[避免歧义](#pr4x-1739990961816)

<a name="to9v-1740363635370"></a>[易于更新](#snq7-1739990965115)

<a name="yq9k-1740363635372"></a>[标准化支持](#tbxm-1739990983886)

<a name="5qad-1740363635374"></a>[linkin多对多关系关联指向](#7rsr-1739991178955)

<a name="mbnf-1740363635376"></a>[文档数据库是否在重蹈覆辙?](#ejgi-1739957588395)

<a name="qumv-1740363635378"></a>[网络模型](#ftqi-1739957588397)

<a name="y6nr-1740363635380"></a>[遍历记录列和访问路径表](#l5i7-1739991286971)

<a name="v93s-1740363635382"></a>[关系模型](#jxjx-1739957588399)

<a name="racs-1740363635384"></a>[没有复杂路径](#bwbl-1739991317494)

<a name="md2h-1740363635386"></a>[查询优化器耗费多年研究和开发精力](#vlwx-1739991363241)

<a name="j3hy-1740363635388"></a>[只需构建一次查询优化器，所有应有程序都可以从中受益](#gkyb-1739991402751)

<a name="tj1r-1740363635390"></a>[与文档数据库相比](#dgpl-1739957588401)

<a name="1bss-1740363635392"></a>[外键-文档引用](#2s88-1739991241151)

<a name="qqkh-1740363635394"></a>[关系型数据库与文档数据库在今日的对比](#yecy-1739957588403)

<a name="fgl2-1740363635396"></a>[哪个数据模型更方便写代码?](#3kqq-1739957588405)

<a name="rbso-1740363635398"></a>[文档数据库：类似文档结构（一对多关系树，一次加载整个树）](#glnq-1739991500088)

<a name="dz0d-1740363635400"></a>[关系型：高度相联数据](#r37b-1739991571636)

<a name="l8ql-1740363635402"></a>[图数据库：图型模型](#wjtn-1739991541917)

<a name="n5fp-1740363635404"></a>[文档模型中的架构灵活性](#ablj-1739957588407)

<a name="ilfi-1740363635406"></a>[无模式schemaless/读时模式schema-on-read](#aynf-1739991684573)

<a name="xjvk-1740363635408"></a>[不同类型对象放在表中不现实](#dxob-1739991755087)

<a name="mzp2-1740363635410"></a>[数据结构由外部决定，无法控制外部系统且随时变化](#tfyl-1739991795457)

<a name="iewq-1740363635412"></a>[查询的数据局部性](#gre0-1739957588409)

<a name="4uxm-1740363635414"></a>[局部性原理：无需查询多次，所需数据在局部边缘](#fr73-1739991930943)

<a name="pzwr-1740363635416"></a>[适用于需要文档绝大部分内容的情况](#jtgm-1739991998839)

<a name="umnq-1740363635418"></a>[文档和关系数据库的融合](#oswg-1739957588411)

<a name="h7r6-1740363635420"></a>[除mysql外都已支持xml格式](#md2f-1739992070998)

<a name="4kdy-1740363635422"></a>[高版本开始支持Json格式](#qv8p-1739992118385)

<a name="kim9-1740363635424"></a>[数据查询语言](#hicx-1739957588413)

<a name="rojk-1740363635426"></a>[Web上的声明式查询](#3nio-1739957588415)

<a name="revu-1740363635428"></a>[简洁容易，隐藏实现细节](#ltru-1739992165789)

<a name="1zyb-1740363635430"></a>[声明式CSS比JS实现好得多](#6fnh-1739992292353)

<a name="woxx-1740363635432"></a>[声明式SQL比命令式查询API好得多](#9py6-1739992446867)

<a name="r818-1740363635434"></a>[MapReduce查询](#19wu-1739957588417)

<a name="xnrw-1740363635436"></a>[比SQL底层，可用于实现SQL查询功能](#erlv-1739992560815)

<a name="lhuv-1740363635438"></a>[图数据模型](#ow5x-1739957588419)

<a name="xdwn-1740363635440"></a>[属性图](#p6tp-1739957588421)

<a name="vpuk-1740363635442"></a>[Cypher查询语言](#xrco-1739957588423)

<a name="xhti-1740363635444"></a>[SQL中的图查询](#wlr2-1739957588425)

<a name="znce-1740363635446"></a>[三元组存储和SPARQL](#cqog-1739957588427)

<a name="zk7l-1740363635448"></a>[语义网络](#z8sp-1739957588429)

<a name="vz6r-1740363635450"></a>[RDF数据模型](#bqfx-1739957588431)

<a name="rvff-1740363635452"></a>[SPARQL查询语言](#rbsb-1739957588433)

<a name="tm8c-1740363635454"></a>[基础:Datalog](#u7qx-1739957588435)

<a name="aszx-1740363635456"></a>[本章小结：](#auej-1739957588437)

<a name="ziqa-1740363635458"></a>[-关系模型](#pgu6-1699844351041)

<a name="jesv-1740363635460"></a>[-NoSql (es,redis)](#kfpd-1644410618294)

<a name="cwym-1740363635462"></a>[1.文档数据库:MongoDB](#0p23-1644410807294)

<a name="kg0m-1740363635464"></a>[  2.图形数据库 ：](#09bl-1644410666587)

<a name="ezvo-1740363635466"></a>[-其它模型(基因序列)](#6fxw-1644410924417)

<a name="ovu5-1740363635468"></a>[3.存储与检索](#sm0u-1677787447009)

<a name="gtrz-1740363635470"></a>[两大类存储引擎：](#eecw-1740153790262)

<a name="rrx8-1740363635472"></a>[日志结构：LSM树 - 段  追加](#q4ii-1740155028973)

<a name="1fmd-1740363635474"></a>[面相页面：B树   -  页面  就地更新覆盖](#0hl1-1740155034913)

<a name="qjl1-1740363635476"></a>[驱动数据库的数据结构](#wfwi-1740153581649)

<a name="ortm-1740363635478"></a>[日志文件：db_get查找最新值使用 tail -n 1 原因：日志文件末尾追加记录](#tv8n-1740155156001)

<a name="m39t-1740363635480"></a>[高效查找数据：索引](#tug5-1740155286426)

<a name="tokv-1740363635482"></a>[权衡索引带来开销的利弊](#p3si-1740155327190)

<a name="b1h1-1740363635484"></a>[哈希索引](#rlyu-1740153582091)

<a name="rvz8-1740363635486"></a>[key  ：byte offset    -key的字节偏移量（检索到对应的key位置）memtable内存表](#wwhy-1740155355395)

<a name="yrrt-1740363635488"></a>[Riak默认存储引擎Bitcask适合每个键经常更新](#jmo1-1740156066924)

<a name="hvru-1740363635490"></a>[Bitcask压缩键值更新日志，只保留每个键最近值，为什么不用新值覆盖，只能追加设计的原因：](#lqhv-1740157192025)

<a name="mn54-1740363635492"></a>[顺序写入：追加和分段合并时，比随机写入快，基于闪存SSD优选](#fddz-1740156309455)

<a name="11bh-1740363635494"></a>[并发和崩溃恢复简单：段文件是附加或不可变的，不必担心值覆盖时崩溃回滚丢失旧数据](#3nar-1740156360507)

<a name="uioq-1740363635496"></a>[避免数据文件分散：合并旧段避免其随时间分散问题](#hx0m-1740156507858)

<a name="wz72-1740363635498"></a>[哈希局限性：](#fzjg-1740156686379)

<a name="dq9j-1740363635500"></a>[散列表必须放进内存： 变满增长时昂贵，磁盘哈希映射表现差，大量随机I/O, 且散列冲突需要很多逻辑。](#ir0f-1740156695161)

<a name="nn24-1740363635502"></a>[范围查询效率不高：如查0~99999，需要单独查每个键](#4hz0-1740157036066)

<a name="5m6p-1740363635504"></a>[SSTables和LSM树](#fzxl-1740153582093)

<a name="3uf9-1740363635506"></a>[SSTable-排序字符串表：键值对序列按键排序，优势](#rezu-1740157411774)

<a name="ox5f-1740363635508"></a>[合并段简单高效，即使文件大于内存。类似归并排序算法](#ufmh-1740157485412)

<a name="qqnk-1740363635510"></a>[不再需要保存内存中所有键的索引，因为有序，可知目标键前后位置](#bvrd-1740157454667)

<a name="ihtb-1740363635512"></a>[节省磁盘空间，减少IO带宽： 写入磁盘前进行压缩，每个条目都指向压缩块开始处](#0yy6-1740157757279)

<a name="gdjy-1740363635514"></a>[内存中为有序key : byte offset(MemTable内存表),   每个key是disk每段(SSTable)的头节点。](#cecn-1740225640452)

<a name="rkwd-1740363635516"></a>[PS: Log-Structured Merge Tree 专为写入密集设计：](#z3in-1740250091207)

<a name="eqlx-1740363635518"></a>[旨在通过将数据分散存储在多个结构中优化写操作性能](#ezl0-1740250352949)

<a name="n6cg-1740363635520"></a>[同时批量处理减少磁盘操作成本](#clsq-1740250357670)

<a name="ge4t-1740363635525"></a>[构建和维护SSTables](#i5pu-1740153582095)

<a name="pkpu-1740363635527"></a>[1.平衡树：写入时，添加到内存中平衡树结构（例如红黑树），也称内存表](#ygxv-1740164523160)

<a name="hque-1740363635529"></a>[2.入盘：当内存表大于某个阈值（通常几兆), 作为SSTable文件写入磁盘](#yry5-1740164572357)

<a name="8pxp-1740363635531"></a>[3.读取：先在内存表中找关键字，然后在最近的磁盘段中](#acht-1740164814071)

<a name="ljzx-1740363635533"></a>[4.压缩：后台运行合并压缩过程组合段文件覆盖删除旧值](#jpws-1740164861028)

<a name="bcy4-1740363635535"></a>[解决崩溃时内存数据丢失：保存一个单独日志，每个写入立即落盘，用于恢复。](#9uey-1740164946782)

<a name="pun2-1740363635537"></a>[用SSTables制作LSM树](#atfb-1740153582097)

<a name="si7v-1740363635539"></a>[Cassandra, Hbase 受Bigtable影响，引入SSTable 和 memtable内存表](#r0ik-1740165041645)

<a name="1qte-1740363635541"></a>[LSM存储引擎：基于合并和压缩排序文件原理的存储引擎](#j8ta-1740165140730)

<a name="qrzb-1740363635543"></a>[Lucene和ES、Solr全文搜索使用类似的方法来存储字典：](#ms2r-1740165303784)

<a name="rwpw-1740363635545"></a>[全文索引比键值复杂得多](#x7ec-1740165389878)

<a name="v82l-1740363635547"></a>[分词索引、二级索引](#52hb-1740165392571)

<a name="pnym-1740363635549"></a>[性能优化](#gtdu-1740153582099)

<a name="717b-1740363635551"></a>[查找不存在的键时：LSM树算法很慢；检查内存表，一直回到最老的，才能确定键不存在](#dvbd-1740165554199)

<a name="6udp-1740363635553"></a>[解决：Bloom过滤器-近似集合内容的高效数据结构，告诉您数据库中是否出现键，从而节省磁盘读取](#i4ew-1740166032050)

<a name="3reg-1740363635555"></a>[压缩合并策略：规模级别调整-更新和更小的合并到大老的SSTable中，水平则拆分成更小。](#uku4-1740166095455)

<a name="hux9-1740363635557"></a>[平坦压缩：LevelDB因此得名，RocksDB](#nogm-1740166206243)

<a name="junx-1740363635559"></a>[大小分层：Hbase](#yrcs-1740166183634)

<a name="arpl-1740363635561"></a>[both: Cassandra](#xbph-1740166243292)

<a name="lesb-1740363635563"></a>[LSM树基本思想： 保存一系列在后台合并的SSTables，简单有效](#obce-1740166273567)

<a name="sp31-1740363635565"></a>[ 即使数据集比内存大得多，仍能正常工作](#dmmn-1740166423949)

<a name="pp1p-1740363635567"></a>[按序存储可高效执行范围查询](#uc4r-1740166514362)

<a name="ojqq-1740363635569"></a>[磁盘写入是连续的，高写入吞吐量](#fc6o-1740166561440)

<a name="kfob-1740363635571"></a>[B树](#jidy-1740153582101)

<a name="gj6u-1740363635573"></a>[1970年提出](#5mho-1740225282678)

<a name="sa2s-1740363635575"></a>[SSTable   有序  可变大小段（通常为几兆）](#1wbz-1740225295395)

<a name="yce4-1740363635577"></a>[B树      有序页（通常为4k,innodb 64k/页） 页面树](#eoxw-1740225354418)

<a name="hv4t-1740363635579"></a>[算法分隔页面生长B树，四级树多达256TB](#ilpu-1740227362881)

<a name="m7z5-1740363635581"></a>[让B树更可靠](#tuyj-1740153582103)

<a name="ppfk-1740363635583"></a>[崩溃B树产生孤儿页面风险](#5uig-1740227401618)

<a name="r7qf-1740363635585"></a>[解决：预写式日志WAL ,也称为重做日志redolog，仅追加的文件](#hcsm-1740229623873)

<a name="cab0-1740363635587"></a>[并发安全，避免多线程访问树数据不一致](#tbc5-1740229671142)

<a name="tjm5-1740363635589"></a>[解决：并发控制，轻量级锁，锁存器latches](#azii-1740229723964)

<a name="nplc-1740363635591"></a>[B树优化](#wout-1740153582105)

<a name="kwtz-1740363635593"></a>[.写时复制 代替 WAL ,对并发控制也很有用](#odav-1740247750938)

<a name="9rwh-1740363635595"></a>[.节省页面空间，使具有更多键，使得层次/IO更少 ps:B+树](#yhsp-1740247793034)

<a name="nips-1740363635597"></a>[.使得叶子页面顺序出现在磁盘，树增长后维持困难。LSM合并重写存储更易使顺序键在磁盘上彼此靠近](#itqr-1740247965059)

<a name="n77a-1740363635599"></a>[.额外指针指向左右兄弟节点，利于顺序扫描，无需返回父节点](#ldlt-1740248368480)

<a name="ryb4-1740363635601"></a>[.借用日志结构思想减少磁盘寻道。如分形树（与分形无关）](#i95u-1740248417650)

<a name="xck5-1740363635603"></a>[比较B树和LSM树](#lerd-1740153582107)

<a name="zjjb-1740363635605"></a>[B树：实现更成熟  读取快写入慢](#cfuu-1740249099701)

<a name="pnxq-1740363635607"></a>[LSM树： 写入快读取慢  因为需在压缩阶段检查不同的数据结构和SSTable。](#ivvw-1740249108704)

<a name="uvos-1740363635609"></a>[ps:但哈希索引O(1)特性一般用作读多写少的缓存LOL，LSM是指检索key，非O(1)通过key获取值](#q7gb-1740249591162)

<a name="xzww-1740363635611"></a>[LSM树的优点](#7w72-1740153582109)

<a name="fhgt-1740363635613"></a>[写放大现象：写入数据库导致对磁盘多次写入 ](#c6ai-1740249240366)

<a name="lhxw-1740363635615"></a>[B树一次写WAL, 一次写树页面本身](#dv6j-1740249742983)

<a name="cwro-1740363635617"></a>[LSM树反复压缩合并SSTable-较低的写放大](#anhw-1740249964228)

<a name="klk1-1740363635619"></a>[写频繁应用性能瓶颈：写入速度，写放大导致性能代价-写入磁盘次数越多，可用磁盘带宽内每秒写入次数越少](#xsly-1740250788941)

<a name="lr2x-1740363635621"></a>[LSM优点：](#i5jw-1740250937048)

<a name="phdo-1740363635623"></a>[比B树支持更高写入吞吐量：较低的写放大-顺序写入紧凑的SSTable, 非必须覆盖树中几个页面。](#ujpd-1740250987705)

<a name="edao-1740363635625"></a>[压缩更好：比B树在磁盘产生更小文件，B树面相页，拆分时产生未使用空间；LSM树不是面相页，定期重写SSTable去除碎片，较低存储开销，特别是平坦压缩](#v8ct-1740251133848)

<a name="c0zu-1740363635627"></a>[存储引擎写入模式影响不太明显：](#smi5-1740251352836)

<a name="ify8-1740363635629"></a>[固态硬盘内部会使用日志结构化算法，将随机写入转变为顺序写入底层存储芯片](#alfh-1740251452288)

<a name="wki7-1740363635631"></a>[但是，较低的吸入放大率和减少的碎片对SSD仍有利：更紧凑地表示数据可在可用的I/O带宽内提供更多读取和写入](#l62m-1740251469313)

<a name="3zyj-1740363635633"></a>[LSM树的缺点](#jks7-1740153582111)

<a name="8zln-1740363635635"></a>[.压缩过程干扰正在进行的读写操作：对吞吐和平均响应时间通常影响很小，但在更高百分比下，日志结构化存储引擎查询响应时间有时相当长，B树行为更具预测性。](#fsqo-1740251639777)

<a name="p8za-1740363635637"></a>[.压缩跟不上写入速率：高写入吞吐量与压缩配置不匹配，需明确的监控来检测](#cp9q-1740251838486)

<a name="pnq3-1740363635639"></a>[B树优点](#98ps-1740251976429)

<a name="bejc-1740363635641"></a>[强大的事务语义：](#rhwe-1740252063459)

<a name="7kwa-1740363635643"></a>[每个键只存在于索引中的一个位置，而日志化LSM树不同段中有相同键多个副本](#ntqr-1740252170914)

<a name="jx76-1740363635645"></a>[事务隔离通过键范围使用锁实现，B树索引锁可以之间连接到树](#dakj-1740252235763)

<a name="gyje-1740363635647"></a>[其他索引结构](#xhzo-1740153582113)

<a name="hxxm-1740363635649"></a>[主键索引](#5rgs-1740252404764)

<a name="l2li-1740363635651"></a>[二级索引](#knmi-1740252409865)

<a name="rehf-1740363635653"></a>[将值存储在索引中](#pses-1740153582115)

<a name="sact-1740363635655"></a>[堆文件：行被存储的地方](#qv6w-1740252438746)

<a name="m9yw-1740363635657"></a>[某些情况下索引到对文件而外跳跃堆读取性能损失太大](#pymp-1740252694481)

<a name="pv8g-1740363635659"></a>[聚集索引：索引中存储所有行数据](#kmgw-1740252732413)

<a name="ujbw-1740363635661"></a>[非聚集索引/二级索引：用于回表查询](#kd3e-1740252804070)

<a name="ifo6-1740363635663"></a>[多列索引](#ptaw-1740153582117)

<a name="ht0y-1740363635665"></a>[一个索引key对应多个列/多个字段](#zyq4-1740252955275)

<a name="nu9d-1740363635667"></a>[连接索引/复合索引：过个字段组成一个键](#bias-1740252877232)

<a name="0ni9-1740363635669"></a>[多维索引：地理空间经纬度](#qaxm-1740253057597)

<a name="mohl-1740363635671"></a>[标准B树或者LSM树索引不够高效支持，经纬度可能是任意值](#ktpo-1740253096893)

<a name="cfza-1740363635673"></a>[解决：空间填充曲线将二维位置转换成单个数字，使用常规B树索引；](#rb86-1740253150498)

<a name="ch9i-1740363635675"></a>[空间索引R树](#60tv-1740253222093)

<a name="ue93-1740363635677"></a>[全文搜索和模糊索引](#vfjq-1740153582119)

<a name="ojjz-1740363635679"></a>[没有确切值或排序的键场景：错写的单词，模糊查询](#pbup-1740253315216)

<a name="pkjv-1740363635681"></a>[全文搜索引擎：单词扩展同义词，朝文档分类和机器学习方向发展](#bfha-1740253391849)

<a name="wc6u-1740363635683"></a>[在内存中存储一切](#kczd-1740153582121)

<a name="vxmd-1740363635685"></a>[随着RAM变得越来越便宜，磁盘GB价格优势被侵蚀数据集不大全部保存在内存是可行的](#cxhv-1740253476516)

<a name="aqcp-1740363635687"></a>[内存数据库的发展:Memcached VoltDB,MemSQL](#ttcb-1740254156445)

<a name="bawq-1740363635689"></a>[支持持久化](#v0vo-1740254085247)

<a name="keyn-1740363635691"></a>[反缓存anti-caching: 缓存内存中少使用的数据转移到磁盘](#0h8m-1740254207754)

<a name="kyyq-1740363635693"></a>[新领域：非易失性存储器NVM,进一步改变存储引擎设计](#gigc-1740254291162)

<a name="n6zz-1740363635695"></a>[事务处理还是分析?](#opxp-1740153582123)

<a name="9d6o-1740363635697"></a>[起初相同数据库用于OLTP和OLAP, 查询效果很好](#l4km-1740344822931)

<a name="zdjz-1740363635699"></a>[80年代末和90年代初，开始在单独数据库上运行分析-数据仓库](#gunc-1740345202551)

<a name="lsuw-1740363635701"></a>[数据仓库](#a3ws-1740153582125)

<a name="2nhh-1740363635703"></a>[大公司多个OLTP系统： 线下实体店，仓库库存，车辆路线，供应商，员工等](#f8mt-1740345620249)

<a name="hfqh-1740363635705"></a>[小公司少量数据，可在传统SQL数据库中查询，甚至电子表格](#tkhz-1740345673586)

<a name="ledl-1740363635707"></a>[OLTP下运行OLAP损耗事务性能](#5lmq-1740345338991)

<a name="xdko-1740363635709"></a>[ETL: 从OLTP数据库提取数据-转换合适的分析模式-清理并加载到数仓](#qhmy-1740345391081)

<a name="z5y7-1740363635711"></a>[索引算法对OLTP有效，对于回答分析查询并不是很好](#omhz-1740345601517)

<a name="lk0t-1740363635713"></a>[OLTP数据库和数据仓库之间的分歧](#s1an-1740153582127)

<a name="tmwq-1740363635715"></a>[数仓对分析性查询进行了优化](#vzyr-1740345853192)

<a name="sfmi-1740363635717"></a>[现在数据库供应商重点支持事务处理或分析工作负载其一](#sx44-1740345915239)

<a name="9vvj-1740363635719"></a>[星型和雪花型:分析的模式](#ybnk-1740153582129)

<a name="mtue-1740363635721"></a>[星型模型/维度建模](#jheq-1740348889870)

<a name="gcfv-1740363635723"></a>[非零售量而是分析流量- 每行是用户页面浏览量或点击量，](#lwmn-1740348945086)

<a name="uruc-1740363635725"></a>[事实被视为单独事件，列为属性，其他是维表的外键引用(事件发生地点，时间，方式，原因)](#mjj1-1740349156137)

<a name="u0r3-1740363635727"></a>[雪花型，品牌和产品类别有单独表格，而非字符串。](#3nxf-1740349244410)

<a name="ktvn-1740363635729"></a>[比星型更规范化，但星型通常为首选，使用简单](#gy72-1740349701771)

<a name="0rln-1740363635731"></a>[事实表格宽泛，通常有100列以上](#u1pg-1740349755363)

<a name="hi0k-1740363635733"></a>[列存储](#cvpc-1740153582131)

<a name="y25u-1740363635735"></a>[ 100列宽度，按行从磁盘加载到内存，解析过滤，耗时长](#lknp-1740352332002)

<a name="q4wn-1740363635737"></a>[      解决：按列存储](#hlpv-1740352397203)

<a name="41kf-1740363635739"></a>[列压缩](#gsyu-1740153582133)

<a name="0t2p-1740363635741"></a>[压缩进一步降低吞吐量需求，且列存储适合压缩，重复数值多](#ezrn-1740352503854)

<a name="grbz-1740363635743"></a>[位图编码压缩](#l5z0-1740352533108)

<a name="jlki-1740363635745"></a>[内存带宽和向量处理](#mtsf-1740153582135)

<a name="6ls6-1740363635747"></a>[矢量化处理： 按位"与"和“或”直接在这样的压缩列数据块上操作](#ksbk-1740352860514)

<a name="prl7-1740363635749"></a>[列存储中的排序顺序](#axhk-1740153582137)

<a name="yehf-1740363635751"></a>[几个不同的排序顺序](#utbx-1740153582139)

<a name="lwoa-1740363635753"></a>[写入列存储](#hw2b-1740153582141)

<a name="7mg9-1740363635755"></a>[聚合:数据立方体和物化视图](#lmc7-1740153582143)

<a name="aweg-1740363635757"></a>[本章小结](#hypc-1740153582145)

<a name="wd3p-1740363635759"></a>[-优化事务处理（OLTP）transaction ](#bhcv-1644935436804)

<a name="8q1p-1740363635761"></a>[1.OLTP系统通常面向用户，大量的请求。](#tbhw-1699844517372)

<a name="2jup-1740363635763"></a>[2.磁盘寻道时间往往是这里的瓶颈。](#fnev-1644935714127)

<a name="9wln-1740363635765"></a>[3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。](#cjwp-1644935609899)

<a name="xfya-1740363635767"></a>[-优化分析（OLAP）analys](#jg7s-1699844443567)

<a name="puhs-1740363635769"></a>[1.列式储存(投影操作，压缩技术，聚合过滤)](#pjd1-1703887811615)

<a name="j8e8-1740363635771"></a>[-OLTP两大主流学派的存储引擎：](#8sgm-1644935924013)

<a name="kytt-1740363635773"></a>[1.日志结构学派](#i55y-1644935943748)

<a name="nsf3-1740363635775"></a>[2.就地更新学派](#h3il-1644935977285)

<a name="bghi-1740363635777"></a>[4.编码（序列化）与演化(XML,JSON,CSV)](#lbs1-1677787447010)

<a name="lm4y-1740363635779"></a>[编码数据的格式](#hnz2-1740362369788)

<a name="tege-1740363635781"></a>[语言特定的格式](#loua-1740362391326)

<a name="zgrl-1740363635783"></a>[JSON，XML和二进制变体](#bvx6-1740362391328)

<a name="6yia-1740363635785"></a>[二进制编码](#vxuu-1740362391330)

<a name="bavn-1740363635787"></a>[Thrift与Protocol Buffers](#mzz8-1740362391332)

<a name="jqxg-1740363635789"></a>[字段标签和模式演变](#bivf-1740362391334)

<a name="dc37-1740363635792"></a>[数据类型和模式演变](#mshf-1740362391336)

<a name="vmlf-1740363635794"></a>[Avro](#defc-1740362391338)

<a name="8u6d-1740363635796"></a>[作者模式与读者模式](#rsr4-1740362391340)

<a name="qf9j-1740363635798"></a>[模式演变规则](#dkzq-1740362391342)

<a name="cjsw-1740363635800"></a>[但作者模式到底是什么?](#ndh2-1740362391344)

<a name="my07-1740363635802"></a>[动态生成的模式](#hxlw-1740362391346)

<a name="mjau-1740363635804"></a>[代码生成和动态类型的语言](#lq8a-1740362391348)

<a name="pe5v-1740363635806"></a>[模式的优点](#dd97-1740362391350)

<a name="2uvf-1740363635808"></a>[数据流的类型](#vcma-1740362391352)

<a name="thl6-1740363635810"></a>[数据库中的数据流](#mmkb-1740362391354)

<a name="naya-1740363635812"></a>[在不同的时间写入不同的值](#dedw-1740362391356)

<a name="unsb-1740363635814"></a>[归档存储](#gax1-1740362391358)

<a name="gnd4-1740363635816"></a>[服务中的数据流:REST与RPC](#0l6j-1740362391360)

<a name="xgbk-1740363635818"></a>[Web服务](#qik0-1740362391362)

<a name="dq6y-1740363635820"></a>[远程过程调用(RPC)的问题](#2jfn-1740362391364)

<a name="ul8l-1740363635822"></a>[RPC的当前方向](#olix-1740362391366)

<a name="ioex-1740363635824"></a>[数据编码与RPC的演化](#k8b3-1740362391368)

<a name="diay-1740363635826"></a>[消息传递中的数据流](#er0d-1740362391370)

<a name="pfb7-1740363635828"></a>[消息掮客](#0qtl-1740362391372)

<a name="mrso-1740363635830"></a>[分布式的Actor框架](#a9jv-1740362391374)

<a name="6j9a-1740363635832"></a>[本章小结](#hc4u-1740362391376)

<a name="xez7-1740363635834"></a>[第二部分 分布式数据](#4p9n-1677787447012)

<a name="izl5-1740363635836"></a>[1.高可用性/容错](#o4ag-1646310813851)

<a name="pv58-1740363635838"></a>[2.断开连接的操作](#snwm-1646310894841)

<a name="eic1-1740363635840"></a>[3.减少延迟(节点近)](#evly-1646310918322)

<a name="mfrr-1740363635842"></a>[4.可拓展性](#itsh-1646310968967)

<a name="3juj-1740363635844"></a>[.拓展至更高的载荷](#gjis-1708362947856)

<a name="q9rd-1740363635846"></a>[垂直扩展scale up ：购买更强大的机器 cpu](#mgia-1708362999715)

<a name="0zu9-1740363635848"></a>[共享内存架构shared-memory architecture：许多处理器、内存和磁盘再同一操作系统下相互连接，共享内存和磁盘](#pdo8-1708363038596)

<a name="sgaz-1740363635850"></a>[共享磁盘share-disk architecture：独立处理器和内存，数据存储在机器之间共享的磁盘阵列上，磁盘通过快速网络连接。数仓](#wgwl-1708363065800)

<a name="9dmd-1740363635852"></a>[无共享架构](#klw2-1708363340866)

<a name="tpqa-1740363635854"></a>[.复制VS分区](#gbgq-1646311175182)

<a name="bzf7-1740363635856"></a>[5.复制](#gd4q-1708363438406)

<a name="g2aa-1740363635858"></a>[.领导者与追随者-单主复制](#9hbs-1708441077626)

<a name="izan-1740363635860"></a>[客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。](#aucb-1708528116000)

<a name="ohqu-1740363635862"></a>[读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）](#wgge-1646311567456)

<a name="7ct3-1740363635864"></a>[.同步复制与异步复制](#cbey-1646310922523)

<a name="rjgy-1740363635866"></a>[.设置新从库(快照复制+caught up binlog)](#j5o0-1704983008475)

<a name="kccc-1740363635868"></a>[.处理宕机节点](#bcod-1708442233018)

<a name="geb7-1740363635870"></a>[从库失效：追赶恢复](#5ufz-1708443850274)

<a name="kser-1740363635872"></a>[主库失效：故障切换failover](#udix-1708443860752)

<a name="udkn-1740363635874"></a>[自动切换步骤：1.确认主库失效](#w3sj-1708523445192)

<a name="ywna-1740363635876"></a>[2.选举新主库：共识](#y3qn-1708523480847)

<a name="qsuh-1740363635878"></a>[3.配置系统启用新主库](#wua6-1708523497956)

<a name="ajo0-1740363635880"></a>[failover的麻烦：1.异步复制数据丢失](#z7mn-1708523814309)

<a name="zo8h-1740363635882"></a>[2.自增主键冲突](#mnjx-1708523836932)

<a name="rfyt-1740363635884"></a>[3.脑裂split brain](#dbhg-1708523873194)

<a name="jfzy-1740363635886"></a>[4.如何设置超时](#561v-1708523878338)

<a name="mnua-1740363635888"></a>[.复制日志的实现](#8mem-1708442228760)

<a name="sokd-1740363635890"></a>[基于语句的复制(每个写入请求语句statment)](#k8yo-1708524004340)

<a name="uomm-1740363635892"></a>[记录每个写入请求语句statment，语句日志传输给从库](#hcqe-1708524155632)

<a name="9nst-1740363635894"></a>[问题：非确定函数nondeterministic, NOW()  RAND()](#9xml-1708524182083)

<a name="fh33-1740363635896"></a>[    自增列- 造成差异](#il4a-1708524271564)

<a name="l4n6-1740363635898"></a>[副作用的语句：用户自定义函数，触发器，存储过程](#azmh-1708524331636)

<a name="yz6g-1740363635900"></a>[解决: 用固定值替换](#rcfb-1708524371120)

<a name="hqqz-1740363635902"></a>[  如语句存在任何不确定性，切换到基于行的数据](#6uy2-1708524426849)

<a name="fwiz-1740363635904"></a>[传输预写式日志(WAL)](#rnmz-1708524013585)

<a name="vd0h-1740363635906"></a>[日志存储引擎SSTables LSM树](#hze4-1708524498278)

<a name="bco3-1740363635908"></a>[磁盘块的B树  WAL, 崩溃恢复](#qzop-1708524541132)

<a name="uvq5-1740363635910"></a>[逻辑日志复制(基于行)](#a3ng-1708524040960)

<a name="ezlo-1740363635912"></a>[binlog](#jiiu-1708524648209)

<a name="4xpd-1740363635914"></a>[基于触发器的复制](#ezoi-1708524083973)

<a name="rxwv-1740363635919"></a>[.复制延迟问题(解决方法都是反分布式，或者趋于单机一致性。数据一致性模型：https://jepsen.io/consistency)](#https://jepsen.io/consistency)

<a name="jqn3-1740363635921"></a>[读己之写(读主库或带写时间戳查询)](#w5nz-1708525244967)

<a name="mu0m-1740363635923"></a>[写后从旧副本读取数据-未同步  ](#25nj-1708526407050)

<a name="kzh1-1740363635925"></a>[解决：写后读read after write 一致性 或叫做 read your write consistency 防止这种异常](#4st1-1708525569674)

<a name="qrhl-1740363635927"></a>[1.都从主库读。适用仅由用户本人编辑的数据，如个人信息。大部分内容从主库读不适用，扩容读无效果](#v4r0-1708525736897)

<a name="dkd1-1740363635929"></a>[2. 扩容读需要保证更新时间，监控复制延迟，防止滞后超过一分钟从从库发出查询](#vqjs-1708525818133)

<a name="dpuv-1740363635931"></a>[3. 客户端记录写入时间戳，系统确保从库提供查询时，版本时间已覆盖，否则从另一个从库读，或者等待caught up-  等待不就相当弱可用状态，且时钟不可靠](#nmrh-1708525971734)

<a name="rdf7-1740363635933"></a>[4. 副本在多个数据中心，复杂度高，都需经过主库IDC](#wmu9-1708526095856)

<a name="g3lc-1740363635935"></a>[单调读(基于id散列路由同一副本)](#kwrd-1708525264596)

<a name="3vgu-1740363635937"></a>[先读到最新副本，后读到旧副本感觉数据消失](#npwe-1708527802311)

<a name="ucyz-1740363635939"></a>[A看到B评论后消失，时光倒流moving backward in time ](#4cn0-1708526272081)

<a name="4rfk-1740363635941"></a>[解决：单调读monotonic reads总是从同一个副本进行读取(基于用户散列id，如果副本失效则重新路由)](#drqk-1708526396300)

<a name="4jva-1740363635943"></a>[  比强一致性(同步复制/类比单机)弱，比最终一致性更强](#s6u3-1708526566643)

<a name="gfcx-1740363635945"></a>[一致前缀读(因果关系写到相同分区)](#bfps-1708525268614)

<a name="rhl4-1740363635947"></a>[consistent prefix reads](#q7p0-1711363121071)

<a name="tkln-1740363635949"></a>[不同分片副本同步先后问题导致读顺序错误](#rqcm-1708527879976)

<a name="jj2q-1740363635951"></a>[分区partition/分片sharded数据库中的一个特殊问题，全局写入顺序](#bwov-1708526677620)

<a name="m9kh-1740363635953"></a>[分区主库1写入 A:你吃饭了吗？ 分区主库2写入B:没有。 分区1副本同步主库1落后分区2副本同步主库2    C读取1副本: 没有，后读取2副本。你吃饭了吗？](#7e9o-1708526727984)

<a name="sdwy-1740363635955"></a>[解决：确保因果关系都写入到相同分区](#turn-1708527108521)

<a name="lodr-1740363635957"></a>[复制延迟解决方案](#a2la-1708525420248)

<a name="vaar-1740363635959"></a>[趋于反分布式，局部或者部分看做一个单机，做到强一致性](#x8ng-1708527233293)

<a name="elmf-1740363635961"></a>[写后读。](#gecf-1708527304184)

<a name="dmra-1740363635963"></a>[数据库通过事务提供强大保证。](#zsq6-1708527307246)

<a name="v0w6-1740363635965"></a>[.多主复制(主主复制，互为副本-写冲突。多主复制被认为是危险的领域)](#pbfd-1708528009698)

<a name="4ywr-1740363635967"></a>[多主复制的应用场景](#kxkx-1708441627686)

<a name="5l59-1740363635969"></a>[运维多个数据中心(IDC-主主间复制需要处理写冲突）](#xrso-1708700002291)

<a name="sed1-1740363635971"></a>[性能(多活配置，写操作在本地IDC处理，其他IDC异步复制，性能更好)](#06t6-1708700132681)

<a name="glpc-1740363635973"></a>[容忍IDC停机](#9sww-1708700267631)

<a name="spwa-1740363635975"></a>[容忍网络问题(临时的网络中断不会妨碍正在写入的处理)](#dtkl-1708700295371)

<a name="3a2e-1740363635977"></a>[需要离线操作的客户端(支持多个终端离线操作couchDB)](#knxa-1708700020273)

<a name="takk-1740363635979"></a>[协同编辑](#hvwb-1708700115895)

<a name="14iv-1740363635981"></a>[处理写冲突(A将标题从1改2,B将1改3)](#fdot-1708700612321)

<a name="azz3-1740363635983"></a>[同步于异步冲突检测](#u8bc-1708700824251)

<a name="owvv-1740363635985"></a>[同步：单主程序复制 - 不允许每个副本独立接受写入](#wfgd-1708700957597)

<a name="fi8b-1740363635987"></a>[异步：独立接受写入- 异步检测，但为时已晚](#x6is-1708701017804)

<a name="nnhq-1740363635989"></a>[避免冲突(特定记录写入都通过同一个领导者，主库切换或者用户迁移至更近的主库时会有同时写入的可能性)](#xg2a-1708700840681)

<a name="xerd-1740363635991"></a>[收敛convergent至一致的状态(副本主库和其副本在复制完成时收敛至一个相同的最终值)](#ucfn-1708700844474)

<a name="ijdt-1740363635993"></a>[最后写入胜利LWW,last write wins- 给每个写入一个唯一id, 挑选最高ID的写入作为胜利者，并丢弃其他写入-数据丢失](#cbla-1708701376316)

<a name="i4sy-1740363635995"></a>[为每个副本分配一个唯一ID,ID编号更高的具有高优先级。数据丢失](#40po-1708701481447)

<a name="e4tw-1740363635997"></a>[将值合并在一起](#p4m4-1708701593939)

<a name="gx1z-1740363635999"></a>[记录冲突，并编写解决逻辑代码。如通过提醒用户方式](#8fcs-1708701611999)

<a name="uhkz-1740363636001"></a>[自定义冲突解决逻辑](#yrdi-1708700860148)

<a name="e4vj-1740363636003"></a>[自定义冲突解决逻辑(complex)](#t4i7-1708702160004)

<a name="gdo7-1740363636005"></a>[写时执行-后台处理](#pdql-1708702370625)

<a name="4twt-1740363636007"></a>[读时执行-提供多版本用户选择，回写数据库](#sksk-1708702376293)

<a name="uxfw-1740363636009"></a>[亚马逊购物车移除的商品重新出现](#4bqp-1708702425059)

<a name="ouvb-1740363636011"></a>[什么是冲突(两个领导者预订同一个会议室，7章看冲突实例12章看检测解决)](#6x4i-1708700867996)

<a name="4e40-1740363636013"></a>[多主复制拓扑](#o41a-1708702111509)

<a name="tqfm-1740363636015"></a>[环形，星型，all to all -mysql仅支持环形](#5feh-1708702903239)

<a name="9w50-1740363636017"></a>[问题：多主复制时，可能在某些副本中写入错误的顺序。like A写主库1，B写主库2，主库3先同步2，再同步1。类似一致前缀读。](#ddyu-1708702949257)

<a name="mypc-1740363636019"></a>[解决：时间戳是不够的-不可靠时钟，使用一种称为版本向量(version vectors)的技术-检测并发写入](#ghp3-1708703247102)

<a name="vgfz-1740363636021"></a>[无主复制leaderless](#bfz8-1708759285067)

<a name="tody-1740363636023"></a>[Amazon的Dynomo系统。](#cvru-1708759359537)

<a name="hoob-1740363636025"></a>[Riak, Cassandra，Voldmort 也称为Dynamo风格。](#wf6o-1708759707666)

<a name="dchb-1740363636027"></a>[类型1：客户端直接将写入发送到几个副本中](#xpqf-1708760120711)

<a name="0grf-1740363636029"></a>[类型2：coordinator协调者节点代表客户端写入。](#pl2z-1708760121090)

<a name="tmqc-1740363636031"></a>[当节点故障时写入数据库(仲裁写⼊，法定读取，并在节点中断后读修复。)](#qgpe-1708760989905)

<a name="e1im-1740363636033"></a>[如果主从复制，主故障/重启系统更新 则需进行故障切换](#zfuz-1708760396929)

<a name="bhwm-1740363636035"></a>[无主复制： userA set piture_url   -> replica1 ok    Then version=7](#3soj-1708760452090)

<a name="dybe-1740363636037"></a>[           user set piture_url   -> replica2 ok  Then version=7](#4f05-1708760543198)

<a name="1rgi-1740363636039"></a>[user set piture_url   -> replica3 offline  fail   version= 6](#ynls-1708759898772)

<a name="y5pm-1740363636041"></a>[    userB get piture  :  rp3(version6) rp1(version7)  rp2(version7)  Than fix rp3 value to version7](#e1ur-1708760618873)

<a name="e69h-1740363636043"></a>[ 读修复和反熵(失效节点重新连机后如何caught up)](#tyv3-1708760780373)

<a name="vseq-1740363636045"></a>[读修复like userB get piture fixed rp3](#wjho-1708761214792)

<a name="io2c-1740363636047"></a>[反熵 后台进程不断查找副本之间的数据差异。Voldmort无反熵过程，副本可能丢失数据](#xblj-1708761286988)

<a name="upce-1740363636049"></a>[ 读写的法定人数（仲裁）](#w3ia-1708761120623)

<a name="t99r-1740363636051"></a>[仲裁一致性的局限性-最终一致，更强的保证需要事务或共识](#oj1i-1708759830121)

<a name="kmj9-1740363636053"></a>[松散法定人数与带提示的接力](#cu5q-1708759841416)

<a name="19fx-1740363636055"></a>[运维多个数据中心-将写入发送到所有副本，仅需本地IDC内法定节点确认](#kzki-1708761744887)

<a name="g8f7-1740363636057"></a>[检测并发写入](#pt1k-1708759856530)

<a name="eb68-1740363636059"></a>[Dynamo风格的数据存储，没有明确定义的顺序。](#mu89-1708761978075)

<a name="v68f-1740363636061"></a>[userA set x=A   get x](#dbni-1708763823783)

<a name="ikrj-1740363636063"></a>[rp 1 A ok    B unresponsive   A](#auce-1708763993783)

<a name="jsma-1740363636065"></a>[rp2 A ok   B OK  B](#kteo-1708764011894)

<a name="ue1f-1740363636067"></a>[rp3 B ok A ok A](#9xyy-1708764019308)

<a name="3zon-1740363636069"></a>[userB set x=B ](#esiv-1708702764305)

<a name="wihc-1740363636071"></a>[最后写入胜利(丢弃并发写入)](#wd1i-1708764197180)

<a name="kgpb-1740363636073"></a>[LLW 无法确定真实排序，强制排序，选择最新的最大时间戳，并丢弃较早的任何写入.Cassandra唯一支持的方式，Riak可选](#uzhw-1708874432788)

<a name="x5jf-1740363636075"></a>[缺点：数据丢失 ](#henp-1708874594301)

<a name="5vpp-1740363636077"></a>[此前发生的关系和并发](#hzwp-1708764215825)

<a name="5ckk-1740363636079"></a>[因果依赖(causally dependent)  如果B后发与A, 则B因果依赖A, ](#3wp0-1708874672763)

<a name="vhha-1740363636081"></a>[如果是并发，则存在需要解决的冲突](#1wzv-1708875051673)

<a name="mqm9-1740363636083"></a>[捕获此前发生的关系](#j2r6-1708764228505)

<a name="m6ws-1740363636085"></a>[捕获两个客户端间的因果关系，同时编辑购物车(示例为单副本)](#vv7q-1708875756229)

<a name="swwj-1740363636087"></a>[合并同时写入的值](#zp0i-1708874374616)

<a name="r35w-1740363636089"></a>[客户端需额外工作，合并并发写入的值来擦屁股。Riak称这些并发值兄弟(sibings)](#wawo-1708876272614)

<a name="nbjg-1740363636091"></a>[版本向量](#arlv-1708874381589)

<a name="9rlm-1740363636093"></a>[所有副本的版本号集合称为版本向量(version vector)](#b1ov-1708700703636)

<a name="u1nj-1740363636095"></a>[6.分区](#dyz5-1709800112532)

<a name="ti8s-1740363636097"></a>[.分区与复制(分区与复制方案是独立的)](#twd1-1709800204792)

<a name="u9zc-1740363636099"></a>[.键值数据的分区](#fbqg-1709800263679)

<a name="ipuj-1740363636101"></a>[偏斜skew：分区过多数据或过多查询](#s7ju-1709801062977)

<a name="xcq4-1740363636103"></a>[热点hot spot:高负载的分区](#u0d3-1709801107270)

<a name="enzj-1740363636105"></a>[根据键的范围分区](#lqbu-1709800332210)

<a name="zlc4-1740363636107"></a>[Bigtable, HBase, RethinkDB 和 MongoDB2.4](#i2ju-1709801151406)

<a name="bcc6-1740363636109"></a>[按照一定的顺序保存键（SSTbale和LSM-树）](#np00-1709801582805)

<a name="mxw8-1740363636111"></a>[按时间分区当日写过载（需加传感器保证日期+传感主键均匀分布）](#evhb-1709801683166)

<a name="qu2c-1740363636113"></a>[根据键的散列分区(可将偏斜数据均匀分布)](#a1yy-1709800347130)

<a name="empz-1740363636115"></a>[不适合分区的简单哈希函数：java .hashCode-同键不同进程不同哈希值](#mdg4-1709801628016)

<a name="vj4f-1740363636117"></a>[一致性哈希consistent hashing:哈希键分区边界均匀间隔，也可伪随机选择（CDN均匀分配负载）。](#7rkg-1709802019859)

<a name="yd1m-1740363636119"></a>[缺点：无序，低效范围查询(需发送到所有分区)](#iktb-1709802309508)

<a name="quvn-1740363636121"></a>[折中方案：复合主键/组合索引。(uid,time).不同用户在不同分区，每个用户按时间搓顺序存储在单个分区上。](#zznq-1709802490074)

<a name="8gyq-1740363636123"></a>[负载倾斜与消除热点](#ed70-1709800357523)

<a name="kxpe-1740363636125"></a>[数百万追随者做某事-大量写入同一个键](#403a-1709802593546)

<a name="ss1e-1740363636127"></a>[解决：火爆主键+随机数即可将主键分散为100个分区](#wx5s-1709802730512)

<a name="ahdf-1740363636129"></a>[缺点：数据合并，跟踪火爆主键。需权衡利弊。](#h0b7-1709802773377)

<a name="4vfz-1740363636131"></a>[.分片与次级索引](#ekdv-1709800287975)

<a name="1baa-1740363636133"></a>[次级索引通常并不能唯一标识记录。](#n3vk-1709803239471)

<a name="drmp-1740363636135"></a>[HBase Volde-mort为了减少实现复杂度放弃了次级索引。](#q1u5-1709803293988)

<a name="7gvd-1740363636137"></a>[Riak开始添加， 次索是Solr Elasticesearch 搜索的基石](#fhpr-1709803333585)

<a name="jrn0-1740363636139"></a>[按文档的二级索引](#mwm0-1709800370635)

<a name="2w6g-1740363636141"></a>[文档分区索引/本地索引](#ud7o-1709803718409)

<a name="xo6b-1740363636143"></a>[每个分区独立维护自己的二级索引。](#zlhf-1709803740582)

<a name="dkvi-1740363636145"></a>[查询发送所有分区，并合并所有返回结果，分散/聚集scatter/gather-容易导致尾部延迟放大。](#bkj3-1709803789802)

<a name="0pse-1740363636147"></a>[缺点：可能使二级索引读取查询相当昂贵。](#ghpm-1709803878421)

<a name="ojvy-1740363636149"></a>[根据关键词(Term)的二级索引](#itl0-1709800380617)

<a name="l3k1-1740363636151"></a>[全局索引：覆盖所有分区数据的索引，也须分区。](#8bw4-1709804016790)

<a name="vkrr-1740363636153"></a>[关键词分区：关键词本身或它的散列进行分区。](#qc2d-1709913637902)

<a name="qgs8-1740363636155"></a>[优点：只需请求包含关键词的分区，读取更有效率](#jmj8-1709913775261)

<a name="oiga-1740363636157"></a>[缺点：写入慢且复杂。需支持分布式事务。](#i7kp-1709913825503)

<a name="pg4d-1740363636159"></a>[理想下总是最新，实践中更新通常为异步。Amazon DynamoDB声称全局次级索引不到1s内更新。](#mv7j-1709913923874)

<a name="dfe1-1740363636161"></a>[.分区再平衡(reblancing)](#hpnd-1709800294747)

<a name="r6ct-1740363636163"></a>[吞吐量增加：加cpu](#1f0n-1709914101899)

<a name="o7sa-1740363636165"></a>[数据集大小增加：加磁盘和RAM](#vjb0-1709914129763)

<a name="auvm-1740363636167"></a>[机器故障：其他机器接管](#smcd-1709914153882)

<a name="grvf-1740363636169"></a>[----------再平衡应满足--------------](#2efu-1709916803909)

<a name="mfvr-1740363636171"></a>[发生时：数据库应该继续接受读取和写入](#20wj-1709916807951)

<a name="yths-1740363636173"></a>[节点之间只移动必须数据(分区)，以便快速再平衡，减少网络和磁盘io负载。](#cxoi-1709916893371)

<a name="te6b-1740363636175"></a>[平衡后：存储，读取和写入公平共享](#cj8j-1709916938075)

<a name="kojn-1740363636177"></a>[平衡策略](#cavd-1709800402611)

<a name="yv6r-1740363636179"></a>[反面教材：hash mod N](#6f6z-1709800409866)

<a name="zkeo-1740363636181"></a>[$hash(key)=22  22mod10..2  22mod 11...0  22 mod 9 ...4 ](#anib-1709916997775)

<a name="hwl5-1740363636183"></a>[节点需要转移秘钥及次数过多，过于昂贵。](#anz7-1709917243580)

<a name="obnj-1740363636185"></a>[解决：更换为只移动必须数据的方法。](#7ytl-1709917334275)

<a name="1ot1-1740363636187"></a>[固定数量的分区(加节点时分配分区)](#8l9j-1709800420954)

<a name="85vf-1740363636189"></a>[新增/减少节点时，将现存部分数据转移到节点新增/现存节点(Riak,es,couchbase Voldemort使用这种再平衡）](#vmsm-1709917322722)

<a name="zdkc-1740363636191"></a>[适用：分区数量第一次建立时确定。](#ktrd-1709917648400)

<a name="kpdc-1740363636193"></a>[缺点：数据集总量大小难以预估时；分区大再平衡代价昂贵，分区小产生额外开销。](#vw7j-1709917692466)

<a name="hdlp-1740363636195"></a>[分区大小与集群数据总量成比例增长](#eszc-1709921747523)

<a name="gcpa-1740363636197"></a>[动态分区(适用键范围的分区)](#tkjw-1709800428033)

<a name="chec-1740363636199"></a>[解决：使用键范围分区，固定边界的固定数量的分区不便。出现边界错误，手动重新去配分区边界将非常繁琐。](#itsg-1709917825657)

<a name="s5em-1740363636201"></a>[动态分区：与B树类似，分区数据增长超过配置时将分成两区，大量数据删除分区缩小低于阈值则合并(HBase RethinkDB)](#05rm-1709917996703)

<a name="lenl-1740363636203"></a>[优点：分区数量适应总数据量-动态划分分区数量。](#v8uv-1709918235496)

<a name="zi9w-1740363636205"></a>[注意：空库分区开始，未绘制边界先验信息。所有写操作都必须由单个节点处理。其它节点空闲](#cdjv-1709918375629)

<a name="ituv-1740363636207"></a>[解决：配置一组初始分区-预分割 Hbase MongoDb。配需提前知道键分配方式。](#3uee-1709918458100)

<a name="twm5-1740363636209"></a>[MongoDB同时支持范围和哈希分区且动态分割分区。](#tlmq-1709918504615)

<a name="zhnm-1740363636211"></a>[分区数量与数据集大小成正比](#xqee-1709921516740)

<a name="oswu-1740363636213"></a>[按节点比列分区](#kcsr-1709800432396)

<a name="gusu-1740363636215"></a>[新增节点，分区将变小。随机选择固定数量的现有分区进行拆分,最终获得公平的负载份额。cassandre ketama.](#xscz-1709920011051)

<a name="jtni-1740363636217"></a>[随机选择分区边界要求使用基于散列的分区-一致性哈希。](#pmpc-1709920187661)

<a name="5xld-1740363636219"></a>[分区数量与节点数量无关](#a0l0-1709923420226)

<a name="a29r-1740363636221"></a>[ 运维：手动还是自动平衡](#w6ob-1709800443454)

<a name="dxo5-1740363636223"></a>[自动：与故障检测结合将十分危险，高负载节点响应慢被视为死亡被踢掉，重新平衡集群时其他超负荷节点可能级联失败](#qobk-1709920292898)

<a name="oi0b-1740363636225"></a>[手动人为监控+自动](#a05n-1709920414620)

<a name="wiri-1740363636227"></a>[.请求路由](#qxk3-1709800301840)

<a name="boi4-1740363636229"></a>[分区再平衡后的服务发现(IP 端口)](#sd2e-1709921854453)

<a name="04kc-1740363636231"></a>[-------方案-------](#gliq-1709921964410)

<a name="96pl-1740363636233"></a>[1.循环策略：Round-Robin load balancer，轮询节点看是否有请求的分区。](#ibln-1709921978507)

<a name="019k-1740363636235"></a>[2.路由层：有中间层的路由决定请求的节点，由路由层负载均衡](#gjxa-1709922094115)

<a name="yxhh-1740363636237"></a>[3.要求客户端知道分区和节点的分配。客户端可直连节点。](#ukz9-1709922149547)

<a name="93ua-1740363636239"></a>[具有挑战性的问题。重要的是所有参与者都同意-否则将被发送到错误的节点，而不是正确处理。分布式中的共识协议-但很难正确实现。](#1c54-1709922244119)

<a name="eelk-1740363636241"></a>[Zookeper分区分配改变时通知路由层保持最新信息。](#c7dc-1709922373821)

<a name="wlbd-1740363636243"></a>[LinkedIn的Espressor使用Heix进行集群管理(依靠Zookeeper）](#ne7u-1709922442881)

<a name="tk9r-1740363636245"></a>[Hbase,SolrCloud 和kafka也是用Zookeeper来跟踪分区分配。](#41cr-1709922584212)

<a name="tvwm-1740363636247"></a>[Cassandra  Riaks节点间使用留言协议gossip protocol来传播群集状态变化。请求发送任意节点，该节点转发到含有请求分区的节点。模型增加数据库节点的复杂性。但避免对Zookeeper这类外部协调服务的依赖](#kg5k-1709922347652)

<a name="9vv4-1740363636249"></a>[Couchbash不会自动再平衡，简化了设计。moxi路由层。](#uohs-1709922928889)

<a name="bza4-1740363636251"></a>[执行并行查询](#h26t-1709800460759)

<a name="s5pl-1740363636253"></a>[大规模并行处理(MPP,massively parallel processing)-数仓](#oj8k-1709923010027)

<a name="zrp6-1740363636255"></a>[7.事务](#7qvp-1708523954496)

<a name="z6pt-1740363636258"></a>[简化故障失败的机制-强大的事务！！](#wk3n-1710172857428)

<a name="ek0t-1740363636260"></a>[故障](#pzui-1710172844274)

<a name="xkpm-1740363636262"></a>[崩溃](#znoj-1710172848152)

<a name="kdbw-1740363636264"></a>[网络中断](#vovu-1710172885568)

<a name="i8qx-1740363636266"></a>[多线程/客户端写入覆盖](#sxty-1710172894683)

<a name="5blo-1740363636268"></a>[读取无意义中间态数据](#hbqy-1710172933218)

<a name="txb9-1740363636270"></a>[多线程/客户端竞争](#jlng-1710172974900)

<a name="crxu-1740363636272"></a>[.事务的棘手概念](#58hv-1710167822460)

<a name="bru5-1740363636274"></a>[ACID的含义](#yxrp-1710167867782)

<a name="rloh-1740363636276"></a>[原子性atomicity](#hryj-1710167943276)

<a name="gyk6-1740363636278"></a>[一致性consistency](#9aal-1710167983379)

<a name="sbtf-1740363636280"></a>[—致性这个词重载的很厉害:](#jkse-1710173130714)

<a name="h76u-1740363636282"></a>[隔离性isolation](#gfkv-1710171645686)

<a name="rg7v-1740363636284"></a>[持久性durability](#7kja-1710171663168)

<a name="xgry-1740363636286"></a>[单对象与多对象操作](#pblh-1710167919896)

<a name="a6hs-1740363636288"></a>[违反隔离性：一个事务读取另一个事务未被执行的写入（脏读）](#42qx-1710250188446)

<a name="sqm7-1740363636290"></a>[ 原⼦性确保发⽣错误时，事务先前的任何写⼊都会被撤消，以避免状态不⼀致（all or nothing）](#daxd-1710250201202)

<a name="canh-1740363636292"></a>[单对象写入](#7ymn-1710171710772)

<a name="bdn5-1740363636294"></a>[单对象写入崩溃，原子性通过日志实现恢复](#h5aa-1710250215106)

<a name="bxqg-1740363636296"></a>[原子操作：CAS也是流行的操作](#ihdr-1710250368749)

<a name="lqcv-1740363636298"></a>[事务通常被理解为：将多个对象上的多个操作合并为一个执行单元的机制](#a1qj-1710250481310)

<a name="ooyd-1740363636300"></a>[多对象事务的需求](#afyc-1710171718578)

<a name="ptnr-1740363636302"></a>[是否需要多对象事务？ ](#t9gh-1710251706186)

<a name="bulp-1740363636304"></a>[是否有可能只用键值模型和单对象来实现应用程序？](#9b6e-1710251739137)

<a name="ga79-1740363636306"></a>[ 关系型数据库：多表关联插入操作](#ormg-1710250533532)

<a name="lfa2-1740363636308"></a>[ 文档数据模型：多个字段常在同一个文档(被视为单个对象），缺乏连接功能的文档DB会鼓励非规范化(操作非规范化信息需要更新多个文档)。事务可防止非规范化数据不同步。](#opfe-1710250566216)

<a name="n6kg-1740363636310"></a>[ 二级索引的数据库中：一二级索引的同步更新](#syt6-1710251863622)

<a name="6qms-1740363636312"></a>[无原子性:复杂的错误处理](#ymgi-1710251891615)

<a name="p0pj-1740363636314"></a>[无隔离性：并发问题](#ovhl-1710251918119)

<a name="xwiu-1740363636316"></a>[处理错误和中止](#g5o1-1710171723084)

<a name="fell-1740363636318"></a>[···   ACID哲学：违反规则宁可放弃，不留半成品。](#ygfp-1710251941752)

<a name="g3nl-1740363636320"></a>[无主复制则是尽力而为：数据库将做尽可能多的事。错误时不会撤销已经完成的事。-错误恢复是应用程序的责任。](#0hze-1710252188073)

<a name="t1xq-1740363636322"></a>[Rails的ActiveRecord、Django这样的orm框架不会重试中断的事务。丢弃用户输入。](#7mbo-1710252298563)

<a name="ah5p-1740363636324"></a>[中止的重点应该是允许安全的重试。但它并不完美：](#p2mf-1710253466041)

<a name="hji5-1740363636326"></a>[事务成功，网络故障可能导致执行两次。除非有额外应用级除重机制。](#lmfw-1710253530673)

<a name="thwf-1740363636328"></a>[负载过大，重试将更槽糕。限制重试次数，指数退避算法。并单独处理和过载相关的错误](#nxyx-1710253675080)

<a name="o1ir-1740363636330"></a>[仅在临时性错误才值得重试（死锁，异常，网络中断和切换）。发生永久性错误的重试是无意义的](#njy9-1710253740189)

<a name="efrg-1740363636332"></a>[数据库外的副作用：重试每次重发电子邮件。不同系统事务。两阶段提交2PC.](#auy9-1710253799114)

<a name="ki8l-1740363636334"></a>[ 客户端重试失效则丢失数据。](#mtpo-1710253936214)

<a name="f6zp-1740363636336"></a>[.弱隔离级别](#jngf-1710167840980)

<a name="v4fo-1740363636338"></a>[安全并行parallel：事务不触及相同数据](#wdhp-1710263089880)

<a name="hqfd-1740363636340"></a>[竞争条件：](#ykgs-1710263216103)

<a name="xhdt-1740363636342"></a>[读：事务读取另一个事务同时修改的数据](#er05-1710263177909)

<a name="4qyc-1740363636344"></a>[写：事务同时修改相同的数据](#pypw-1710263203957)

<a name="6wan-1740363636346"></a>[事务隔离：](#xps5-1710263234506)

<a name="emyj-1740363636348"></a>[可序列化(一次一个执行，没有任何并发)](#ghkk-1710263260640)

<a name="pir5-1740363636350"></a>[性能损失](#a876-1710263299289)

<a name="mvjs-1740363636352"></a>[弱隔离级别(非串行化nonserializable)](#nqm3-1710263313752)

<a name="byek-1740363636354"></a>[较弱的隔离级别防止一部分，而非全部的并发问题](#e7nl-1710263334073)

<a name="qkl8-1740363636356"></a>[资金损失，耗费财务调查，财务数据请使用ACID数据库(注意：流行的数据库也使用弱隔离级别，不一定能防止并发错误)](#2xxd-1710331395046)

<a name="rfk7-1740363636358"></a>[读已提交](#pjqb-1710171742279)

<a name="kjaw-1740363636360"></a>[没有脏读](#7h42-1710171796899)

<a name="ykd5-1740363636362"></a>[dirty reads：事务看到另一个事务未提交的值](#lyju-1710332135761)

<a name="fnnc-1740363636364"></a>[为什么要防止dirty reads：](#x8ch-1710333899846)

<a name="dvcj-1740363636366"></a>[更新多对象：脏读以为只看到部分数据](#pwpa-1710333902582)

<a name="frhl-1740363636368"></a>[事务中止：回滚后，看到的是未提交的数据](#jcj0-1710333902583)

<a name="sbl3-1740363636370"></a>[解决：只能读取提交后的数据，且不会阻塞，并行时保存已提交的旧值 -mvcc](#3mi1-1710332238978)

<a name="va4a-1740363636372"></a>[没有脏写](#vmfl-1710171803833)

<a name="fn1i-1740363636374"></a>[dirty write: 事务同时更新相同对象。后面的写入覆盖尚未提交的值。](#hvah-1710332040048)

<a name="oii2-1740363636376"></a>[避免的问题：](#chr0-1710333916523)

<a name="r9vx-1740363636378"></a>[混乱写入，导致bob后买车先更新发票commit而alic先买车后更新发票commit(buyer=bob but recipient=alice)](#14wx-1710333919188)

<a name="emfh-1740363636380"></a>[解决：延迟/阻塞第二次的写入，直到第一次写入事务提交或终止。](#g1sw-1710332222649)

<a name="adci-1740363636382"></a>[但不能防止计数器增量的竞争状态。(读写非原子性，写依赖读的副本)](#ujzx-1710333397576)

<a name="3g6s-1740363636384"></a>[计数器增量安全：防止更新丢失 -版本号](#ugiq-1710333641028)

<a name="ngwv-1740363636386"></a>[实现读已提交](#z96g-1710171821987)

<a name="wzzr-1740363636388"></a>[默认的隔离级别：oracle,postgreSQL,sql server ,memSql](#tays-1710333754461)

<a name="kpqk-1740363636390"></a>[行锁row-level lock](#svaf-1710333809593)

<a name="md3g-1740363636392"></a>[读写锁防止脏读：读写锁互斥，只有读锁拥有者可持有写锁。](#fsbu-1710334081090)

<a name="qqif-1740363636394"></a>[缺点：阻塞，性能损失。](#xj1j-1710334321006)

<a name="h7oo-1740363636396"></a>[优化：所以一般用mvcc的模式。-或者copy on write](#7klj-1710334353854)

<a name="3kjy-1740363636398"></a>[快照隔离和可重复读](#bww4-1710171760070)

<a name="gmvk-1740363636400"></a>[不可重复读nonrepeatable read/读取偏差read skew](#wjut-1710343195467)

<a name="imkn-1740363636402"></a>[skew重载：在热点指的是不平衡，这里指异常时机  alice两个账号各500，alice先读acount1=500,转账员将acount1+100,acount2-100后commit，alice读acount2=400.commit.导致Alice看起来少了100。-暂时不一致。](#jmuu-1710343248537)

<a name="r9bk-1740363636404"></a>[提交后，刷新网页即可。有些情况不能容忍暂时不一致：](#gwgf-1710343469620)

<a name="ulkg-1740363636406"></a>[备份：数据库备份需要几小时，期间接收写入包含新老数据。如果备份用于恢复，不一致就变成永久的了。-解决：全局锁/快照备份](#m0km-1710345572560)

<a name="ysvq-1740363636408"></a>[分析查询和完整性检查：扫描大部分数据库，查询在不同时间点观察数据库产生不同，可能返回无意义的结果。](#i5pt-1710345666724)

<a name="ntwc-1740363636410"></a>[ 快照隔离snapshot isolation 对长时间运行的只读查询非常有用（备份和分析）。](#p7tm-1710345899708)

<a name="iujx-1740363636412"></a>[ 即 一致快照consistent snapshot,即使被另一个事务更改，每个事务只能看到该特定时间的旧数据（特定时间点冻结的一致快照）。](#q8oz-1710345935366)

<a name="cncc-1740363636414"></a>[PostgerSQL, mysql innoDB, Oracle, sqlServer](#mo1i-1710346175801)

<a name="fvje-1740363636416"></a>[实现快照隔离](#2hpt-1710171981487)

<a name="io0e-1740363636418"></a>[关键原则：读不阻塞写，写不阻塞读。两者没有任何锁定争用。](#49s0-1710346236063)

<a name="u7jm-1740363636420"></a>[多版本并发控制mvcc,multi-version concurrentcy contorl](#w8v8-1710346319154)

<a name="5d4o-1740363636422"></a>[读已提交不提供快照隔离，保留对象的一两个版本就足够。通常支持快照隔离也是用mvcc来实现读已提交隔离级别：](#fh82-1710346453757)

<a name="6qkg-1740363636424"></a>[读已提交为每个查询使用单独的快照-每个select单独生成。](#3xbw-1710346540026)

<a name="mly7-1740363636426"></a>[快照隔离对整个事务使用相同的快照-复用第一个select生成的快照](#xqhm-1710346554737)

<a name="xahx-1740363636428"></a>[update操作在内部翻译为Delete 和 insert](#pmk8-1710351883488)

<a name="csgz-1740363636430"></a>[-innoDB实际上delete将旧数据版本移到undolog版本链中。垃圾收集会删除任何事务不可见的就对象版本。](#vnfd-1710351911457)

<a name="lgrh-1740363636432"></a>[观察一致性快照的可见性规则](#box0-1710171988275)

<a name="et7h-1740363636434"></a>[从来不更新值，而是每次值改变时创建一个新版本。使得数据库提供一致快照产生的开销很小。](#yapf-1710408915465)

<a name="9mvw-1740363636436"></a>[事务id决定它可以看到哪些对象，规则如下：](#ecrk-1710408160769)

<a name="crqk-1740363636438"></a>[事务开始时列出当时所有事务清单，即使之后提交，这些事务的写入也都会被忽略。](#ogtp-1710408539120)

<a name="rfyl-1740363636440"></a>[忽略被中止事务任何写入](#unjc-1710408595672)

<a name="syy4-1740363636442"></a>[较晚(当前事务之后开始)的写入都被忽略，不管是否提交](#ofbz-1710408626209)

<a name="s9dg-1740363636444"></a>[所有其他写入，对应用都是可见的。](#hgwi-1710408682423)

<a name="0vkn-1740363636446"></a>[对象可见的两条规则](#rg1c-1710408738736)

<a name="bs21-1740363636448"></a>[读事务开始时，创建该对象的事务已提交。](#weyp-1710408754844)

<a name="nbgx-1740363636450"></a>[请求删除的事务在读事务开始时未提交。](#xqky-1710408773006)

<a name="2ghe-1740363636452"></a>[索引和快照隔离(索引如何在多版本数据库中工作)](#ai77-1710171999516)

<a name="2aso-1740363636454"></a>[同一对象不同版本放在同一个页面中，PostgreSQL的优化可以避免更新索引](#kanl-1710410047690)

<a name="40te-1740363636456"></a>[仅追加/写时拷贝apeend-only/copy-on-wirte的变体B树：更新不覆盖树的页面，为每个修改页创建副本。](#yv2q-1710410120895)

<a name="dprc-1740363636458"></a>[每个写入事务/一批事务都会创建一个新的B树，当创建时，从该特定树根生长的树就是数据库的一个一致性快照。](#etza-1710410471666)

<a name="uyj0-1740363636460"></a>[需要负责压缩和垃圾收集的后台进程。](#79xv-1710410561061)

<a name="kjvq-1740363636462"></a>[可重复读与命名混淆](#xr4f-1710172004472)

<a name="rhhx-1740363636464"></a>[原因：System R定义隔离级别时并未有快照隔离](#nohd-1710417835613)

<a name="l9e0-1740363636466"></a>[oracle DB2 称为序列化](#uwdp-1710417928621)

<a name="fi8v-1740363636468"></a>[postgreSql mySql称为可重复读](#f5te-1710417946615)

<a name="6wcm-1740363636470"></a>[防止丢失更新](#e9wg-1710171770800)

<a name="x6k0-1740363636472"></a>[脏写导致丢失更新lost update](#ajmt-1710418075399)

<a name="bfzy-1740363636474"></a>[读取-修改-写入序列的狠揍clobber：第二个事务并没有包括第一个事务的修改: -写依赖读](#c7rv-1710418271703)

<a name="ll69-1740363636476"></a>[增加计数器或更新账户余额(需读取当前值，计算新值并写回更新后的值)](#uvoq-1710418375497)

<a name="s4zf-1740363636478"></a>[进行本地修改： 解析文档，更改后回写修改的文档](#ro12-1710418458493)

<a name="gqbg-1740363636480"></a>[同时编辑wiki页面：整个页面覆盖当前内容。](#9n83-1710418515773)

<a name="inwv-1740363636482"></a>[原子写(x排它锁)](#lftw-1710172034957)

<a name="ozte-1740363636484"></a>[数据库原子更新操作保证并发安全](#6jim-1710418574114)

<a name="nuaz-1740363636486"></a>[mysql: 行级写锁](#dxgy-1710419672127)

<a name="kzfs-1740363636488"></a>[MongoDB：对JSON文档一部分进行本地修改的原子操作](#bqxj-1710419591972)

<a name="vxpt-1740363636490"></a>[redis提供了优先队列等修改数据的原子操作。](#wxju-1710419646040)

<a name="jd3w-1740363636492"></a>[原子操作/游标稳定性cursor stability：通常在读取对象时获取其上的排它锁，以便提交前没有事务可以读取它。另一个选择是将所有原子操作在单一线程上执行。-redis](#h0ip-1710421887552)

<a name="inhz-1740363636494"></a>[unfortunately,ORM框架易执行读取-修改-写入序列，而不是使用数据库提供的原子操作。如果你知道自己在做什么那当然不是问题](#6hwo-1710422121598)

<a name="bwba-1740363636496"></a>[显式锁定(for update：读-改-写序列)](#vysa-1710172041914)

<a name="66wo-1740363636498"></a>[让应用程序显示锁定更新的对象，直到一个读取-修改-写入序列完成](#oknq-1710422501689)

<a name="qxk2-1740363636500"></a>[select ..... for update;](#89ij-1710422624973)

<a name="k4c7-1740363636502"></a>[--更新先前select 返回棋子的位置。](#50q1-1710422845671)

<a name="egiy-1740363636504"></a>[ update](#rmgw-1710422637550)

<a name="vpwg-1740363636506"></a>[for update-对返回的所有行加锁，忘记加锁很容易引入竞争条件(同时修改)](#euv5-1710422671170)

<a name="km8b-1740363636508"></a>[自动检测丢失的更新(管理器检测处理并发问题)](#jpu5-1710172058032)

<a name="iv83-1740363636510"></a>[允许并行执行，事务管理器检测到丢失更新，中止事务并强制重试读-改-写序列。](#8ytj-1710423161566)

<a name="6coi-1740363636512"></a>[Oracle可串行化(快照隔离)和sqlServer的快照隔离级别会自动检测到丢失更新，中止惹麻烦的事务。一些作者认为能防止丢失更新才算提供快照隔离。这个定义下，mysql不算提供快照隔离](#w9el-1710423029153)

<a name="nvjs-1740363636514"></a>[优点：是一个很好的功能，不需要应用代码使用任何特殊数据库功能。允许你忘记加锁或原子操作，由管理器检测丢失更新。](#qg6e-1710423330067)

<a name="ging-1740363636516"></a>[比较并设置(CAS)](#ftwe-1710172063360)

<a name="haba-1740363636518"></a>[不提供事务的数据库中的原子操作：比较并设置（CAS compare and set）](#os3h-1710424617661)

<a name="aosx-1740363636520"></a>[update table set content='new content' where id=123 and content = 'old content'  必要时重试](#hlfh-1710425612756)

<a name="smgc-1740363636522"></a>[问题：数据库允许where子句从旧快照读取，此语句无法防止丢失更新。即另一个并发写入，where条件也为真。-非当前读或非原子写。](#rxcv-1710425806449)

<a name="abew-1740363636524"></a>[解决：检查数据库的CAS是否安全。保证比较交换为当前读且写是否加锁/原子写](#zss4-1710425865867)

<a name="umol-1740363636526"></a>[冲突解决与复制(多个数据库副本的并发)](#bvrp-1710172079412)

<a name="ba8g-1740363636528"></a>[基于锁和cas操作不适用于多个数据库副本](#ewf7-1710434904534)

<a name="mgyg-1740363636530"></a>[如检测并发写入：允许并发吸入创建多个冲突版本(也称兄弟），应用代码或特殊数据结构在发生之后解决合并这些版本。](#8dx4-1710434970886)

<a name="ougx-1740363636532"></a>[原子操作可在复制的上下文中很好工作，尤其具有可交换性时。Riak2.0不同客户端同时更新一个值是，Riak将自动更新合并在一起，以免丢失更新。防止复制副本丢失更新。](#gl8j-1710435048968)

<a name="aqej-1740363636534"></a>[最后写入LWW解决冲突很容易丢失更新。unfortunately,许多复制数据库默认LWW。](#gdtn-1710435259414)

<a name="1jve-1740363636536"></a>[写入偏差与幻读（两个事务更新两个不同的对象）](#rkev-1710172453385)

<a name="qo3d-1740363636538"></a>[select count(*) where oncall=true....alice 和 bob分别查在职医生人数](#itfd-1710436127298)

<a name="huhk-1740363636540"></a>[update...set oncall=false 然后将自己的记录更新为请假，违反至少一医生在职。](#leam-1710436160580)

<a name="uyyz-1740363636542"></a>[写偏差的特征](#ovid-1710172462835)

<a name="eqhk-1740363636544"></a>[特征：涉及多个对象，单对象的原子操作不起作用](#iedp-1710437034438)

<a name="fmr9-1740363636546"></a>[快照隔离实现中，自动检测丢失更新对此无帮助。postgred,innodb的可重复读，oracle序列化或sql server的快照隔离级别中，都不会自动检测写入偏差。写入偏差需要真正的可序列隔离-业务上的问题。](#wszw-1710437034814)

<a name="hk1c-1740363636548"></a>[数据库配置约束，指定至少一个值为true.大多数不支持这种配置，可以使用触发器或者物化视图实现。](#hn04-1710437034815)

<a name="gu8g-1740363636550"></a>[显示锁定。 select ...fro update -锁定返回的所有行，锁定两个医生（行锁+间隙锁）](#crrt-1710437034816)

<a name="cgox-1740363636552"></a>[写偏差的更多例子](#4jr1-1710172470885)

<a name="qzj4-1740363636554"></a>[读数据为空，分别插入一条数据的会议室预定系统：select count(*) from bookings where roomid=123 and time...，insert into bookings....不能防止另一个用户插入冲突会议。解决：又需要串行化执行。](#0hyt-1710437389755)

<a name="5bvv-1740363636556"></a>[多人游戏：棋盘用锁防止丢失更新，但锁定不能妨碍将不同的棋子放在相同位置。产生写入偏差 。解决：使用唯一约束。](#pgcb-1710437636980)

<a name="ar0y-1740363636558"></a>[抢注用户名：和会议系统一样。不过唯一性约束可以解决该问题。](#bwel-1710437042998)

<a name="9swu-1740363636560"></a>[防止双重开支；用户花钱和积分服务，检查支付数不超过余额，有了写入偏差，可能会发生两个支出项目同时插入，导致余额变为负值，两个事务都不会注意到另一个。](#ogt8-1710438166946)

<a name="toz5-1740363636562"></a>[导致写入偏差的幻读](#8gty-1710172478550)

<a name="wiho-1740363636564"></a>[所有以上例子都遵循类似的模式](#tw0y-1710438423955)

<a name="pyap-1740363636566"></a>[Select查询符合条件的行，至少两名医生值班；不存在该会议室同一时段的预定；棋盘位置未被占据；用户未被抢注；账户还有足够余额](#bngi-1710438445792)

<a name="chub-1740363636568"></a>[按照第一个查询的结果，应用代码决定是否继续](#l6p0-1710438590471)

<a name="toga-1740363636570"></a>[应用决定继续操作，执行写入(插入更新删除），并提交事务](#qt10-1710438739456)

<a name="wtdd-1740363636572"></a>[步骤3修改的行，是步骤1中返回的行之一，可以使用select for update来使事务安全避免写入偏差.](#cdmo-1710438899441)

<a name="xnnt-1740363636574"></a>[但检查是否不存在满足条件行，写入添加一个匹配相同条件的行。如果步骤1中的查询没有返回任何](#caet-1710439501945)

<a name="9aop-1740363636576"></a>[⾏，则 SELECT FOR UPDATE 锁不了任何东⻄（读已提交） 。PS:innodb可重复读读null数据会加间隙锁，不走索引则锁表。](#bsm5-1739288894816)

<a name="hgtj-1740363636578"></a>[       这种效应：一个事务中的写入改变另一个事务的搜索查询结果，被称为幻读。快照隔离避免了只读查询中的幻读。以上的读写事务中，幻影会导致特别棘手的写歪斜情况。](#cwgh-1710440241091)

<a name="gnun-1740363636580"></a>[物化冲突](#1cjy-1710172485201)

<a name="gsr6-1740363636582"></a>[物化冲突：将幻读变为数据库中一组具体行上的锁冲突。](#fv3x-1710440426895)

<a name="3jde-1740363636584"></a>[通过创建时间槽和房间的表，提前出入房间和时间的所有可能组合。创建预定的事务可以select for update锁定房间和时间段对应的行，在获得锁定后，可以检查重叠的预定并插入新的预定。该表不是存储预定相关的信息，它完全就是一组锁，用于防止同时修改同一房间和时间范围内的预定。](#laff-1710440634993)

<a name="bbln-1740363636586"></a>[缺点：弄清除如何物化冲突可能很难，也很容易出错，而让并发控制机制泄露到应用数据模型是很丑陋的做法。](#dngy-1710441936216)

<a name="nejc-1740363636588"></a>[物化冲突应为最后的手段。可序列化Serializeble级别是更可取的。](#i0he-1710441997817)

<a name="8isj-1740363636590"></a>[.可序列化](#di29-1710167844061)

<a name="zdim-1740363636592"></a>[弱隔离级别读已提交和快照隔离不能解决写入偏差幻读：](#ztac-1710587737356)

<a name="8tb5-1740363636594"></a>[隔离级别难以理解，且不同数据库中实现不一致，可重复读概念不一样](#ky3h-1710588699885)

<a name="r7xk-1740363636596"></a>[光检查应用代码很难判定在特定隔离界别是否安全](#tpbs-1710588738858)

<a name="wnb6-1740363636598"></a>[无检测竞争条件的好工具，往往倒霉时才会出现问题。](#jp98-1710588779920)

<a name="mofg-1740363636600"></a>[20世纪70年代system R就已经是这样，研究人员的答案都很简单：可序列化（serializeble）级别（但非人见人爱），都使用三种技术之一。](#sqvc-1710588820273)

<a name="rzxq-1740363636602"></a>[字面意义上的串行顺序执行事务](#mqa4-1710589545518)

<a name="bkbb-1740363636604"></a>[两相锁定2PL two-phase locking,几十年来唯一的可行选择](#neot-1710589568078)

<a name="zcyq-1740363636606"></a>[乐观并发控制，可序列话的快照隔离serializable snapshot isolation](#pizj-1710589721553)

<a name="u9mz-1740363636608"></a>[真的串行执行(单线程执行事务)](#2oi3-1710172506817)

<a name="72wu-1740363636610"></a>[数据库设计人员07年才确定，单线程循环执行事务时可行的。（多线程过去30年中被认为是获得良好性能的关键所在）](#o5af-1710589822067)

<a name="ziac-1740363636612"></a>[两个进展引发了这个反思：](#phuh-1710609564138)

<a name="u6wv-1740363636614"></a>[RAM足够便宜，许多场景可以将完整的活跃数据保存在内存中。-redis](#owi7-1710609747624)

<a name="a0ij-1740363636616"></a>[数据库设计人员意识到OLTP事务很短，只进行少量的读写操作。长时间的分析查询通常是只读的，可以用一致快照（快照隔离）上运行。](#vhy4-1710609817752)

<a name="6udg-1740363636618"></a>[VoltDB/H-Store, Redis 和 Datomic中实现。避免锁的协调开销。吞吐量仅限单个cpu](#xcax-1710609934885)

<a name="y8tf-1740363636620"></a>[在存储过程中封装事务(优化交互式单线程事务)](#xh4n-1710172519134)

<a name="uei3-1740363636622"></a>[数据库设计者认为，机票全流程是一个事务，可以被原子化执行。缺点：交互式会使流程性能直接下降。](#xthc-1710757083497)

<a name="rf4r-1740363636624"></a>[解决：单线程串行执行事务的系统不允许交互式的多语句事务。提前将整个事务作为存储过程提交数据库：](#oo8b-1710757291600)

<a name="ywri-1740363636626"></a>[Interactive transaction :bob医生请假 1.select count  2.if count>=2 3.update false](#9fzd-1710757436562)

<a name="q7vd-1740363636628"></a>[stored procedure: execute stored take doctor of call](#gegl-1710763202697)

<a name="z28a-1740363636630"></a>[事务所需的数据都在内存中，快速执行，无需等待网络和磁盘IO](#t47s-1710763179337)

<a name="fn2s-1740363636632"></a>[存储过程的优点和缺点](#7ksv-1710172529258)

<a name="3be3-1740363636634"></a>[名声不好：](#jfoa-1710763413471)

<a name="0lxy-1740363636636"></a>[陈旧丑陋无库生态，数据库存储过程各自的语言没跟上通用编程语言的发展](#4qhf-1710763421594)

<a name="zhux-1740363636638"></a>[管理困难，调试困难，版本控制测试部署困难，和监控指标的系统集成困难](#96la-1710763483936)

<a name="ynk9-1740363636640"></a>[单个数据库通常由多个应用共享，写得不好的存储过程（占用大量内存和cpu）会比代码造成更大麻烦](#idii-1710763602399)

<a name="0oxn-1740363636642"></a>[ 这些问题都可以克服。现代存储过程放弃了PL/SQL,使用现有通用编程语言：VoltDB使用java或Groovy, Datomic使用Java或Clojure, Redis使用Lua.](#1w0a-1710763899035)

<a name="zsg3-1740363636644"></a>[存储过程与内存存储，使得单线程执行事务可行，](#bp68-1710767504595)

<a name="zz8v-1740363636646"></a>[无需等待I/O,](#ahfz-1710767568244)

<a name="tkrr-1740363636648"></a>[避免并发控制机制的开销，可以在单线程实现相当好吞吐量](#mfvt-1710767570930)

<a name="jrx9-1740363636650"></a>[VoltDB还用存储过程进行复制，在每个节点上执行相同的存储过程，所以要求存储过程是确定性的。比如使用当前日期，需要通过特殊的确定性API实现。](#7m1p-1710767621202)

<a name="shaj-1740363636652"></a>[分区](#xxtp-1710172539181)

<a name="n3rv-1740363636654"></a>[顺序执行事务使并发控制简单多，但吞吐限制为单机单核。吞吐量高的应用，单线程将可能成为严重瓶颈。](#rqu5-1710767939361)

<a name="mrfx-1740363636656"></a>[扩展多核多节点，可以对数据进行分区，每个事务只需在单个分区中读写数据，事务吞度量就可以与cpu保持现行扩展。](#puih-1710768082742)

<a name="kprt-1740363636658"></a>[对于需要访问多个分区的任务事务，需要进行协调，存储过程跨所有分区锁定执行，保证串行。](#jpiw-1710768164695)

<a name="edei-1740363636660"></a>[缺点：协调开销性能比单区事务慢得多。VoltDB吞吐量每秒1000个跨分区写入，比单分区低几个数量级，且通过增加机器来提高](#fgu3-1710768218238)

<a name="wfne-1740363636662"></a>[事务是否可划分-应用的数据结构，键值数据，多个二级索的数据引需要大量跨分区协调。](#8lf4-1710768407791)

<a name="atqw-1740363636664"></a>[串行执行小结](#zyih-1710172540516)

<a name="2ru5-1740363636666"></a>[需每个事务小而快，一个缓慢的事务拖慢所有事务。](#dibg-1710768638498)

<a name="tuxz-1740363636668"></a>[可放入内存仅限活跃数据集，少量数据会移动到磁盘。但需要访问执行中的事务，系统会变慢。](#22nq-1710768681244)

<a name="dovn-1740363636670"></a>[写入吞吐量必须低到能在单个cpu运行，否则事务能划分至但分区，且无需分区协调](#jmsk-1710768781527)

<a name="tlnv-1740363636672"></a>[跨分区事务使用程度受限。](#wlnd-1710769060180)

<a name="olj2-1740363636674"></a>[两阶段锁定（2PL）](#uhxa-1710172558745)

<a name="adfy-1740363636676"></a>[30年高使用的序列化算法：两阶段锁定2PL two phase locking ,独占访问exclusive access:](#nhdj-1710769248115)

<a name="aoeo-1740363636678"></a>[事务A读取对象，阻塞B写入，直至A提交；](#khdp-1710769659952)

<a name="vnj8-1740363636680"></a>[事务A写入对象，阻塞B读取,直至A提交；](#elpw-1710769685611)

<a name="qduq-1740363636682"></a>[快照隔离使得不会阻塞读，2PL提高序列化性质，解决丢失更新和写入偏差。](#6ja2-1710769959539)

<a name="dakd-1740363636684"></a>[实现两阶段锁](#lfuv-1710172605096)

<a name="jkji-1740363636686"></a>[2PL即innoDB可序列化级别及DB2可重复读隔离级别。](#8oif-1710770052594)

<a name="pchb-1740363636688"></a>[读写阻塞为每个对象添加锁。共享模式shared mode 与独占模式exclusive mode:](#6wad-1710770158675)

<a name="mnd8-1740363636690"></a>[读取对象需以共享模式获取锁。读共享](#1dyc-1710770195788)

<a name="h3pa-1740363636692"></a>[写入需独占模式取锁。写互斥。](#bshw-1710770251530)

<a name="op0m-1740363636694"></a>[事务获得锁必须持有锁知道事务结束(提交或中止)。即一阶段获取锁，二阶段释放所有锁。](#r0b0-1711207524774)

<a name="fotc-1740363636696"></a>[死锁deadlock, 数据库会自动检测死锁，并中止其中一个。被中止的事务充实需应用程序实现。](#iuyh-1710770211133)

<a name="drk7-1740363636698"></a>[两阶段锁定的性能](#qi7j-1710172616303)

<a name="u1zb-1740363636700"></a>[比弱隔离差得多](#vz0p-1711207837446)

<a name="g6fu-1740363636702"></a>[锁开销、串行并发性降低](#ienx-1711207878742)

<a name="jope-1740363636704"></a>[交互式事务形成等待队列、高百分位响应慢](#z85f-1711207913718)

<a name="imo4-1740363636706"></a>[死锁频繁时重试造成浪费](#kmkr-1711207799940)

<a name="z9k2-1740363636708"></a>[谓词锁predicate lock](#ccq8-1710172621528)

<a name="sydy-1740363636710"></a>[谓词锁：属于符合搜索条件的对象，解决幻读phantoms](#kfpi-1711208306292)

<a name="njzv-1740363636712"></a>[事务A获取共享谓词锁shared-mode predicate lock读取匹配对象，与排它互斥](#6dqd-1711208459688)

<a name="ykzs-1740363636714"></a>[事务A写入需等待其他事务谓词锁释放。](#p3er-1711208588906)

<a name="vvwm-1740363636716"></a>[适用于尚不存在，将可能添加的对象（幻象），如果两阶段包含谓词锁，可实现串行化。](#bdwj-1711208433268)

<a name="yn7p-1740363636718"></a>[索引范围锁next-key lock](#zv5c-1710172626404)

<a name="rm4k-1740363636720"></a>[谓词锁性能不佳：活跃事务持锁多，检查匹配非常耗时](#a3ce-1711208973949)

<a name="l9kq-1740363636722"></a>[2PL采用索引范围锁-简化版谓词锁：](#ayfb-1711209059199)

<a name="ks3o-1740363636724"></a>[索引位于roomid, 指示room123用于预定](#qmbu-1711212311152)

<a name="bjxc-1740363636727"></a>[或者索引位于时间上，指示12:00~13:00用于预定。](#ajbo-1711212362665)

<a name="pba4-1740363636729"></a>[以上任何一条件，当另一个事务想写入时，需要更新索引-叶子节点，会收到共享锁。解决幻读和写入偏差](#k1ie-1711212755816)

<a name="mawi-1740363636731"></a>[索引范围锁不如谓词锁精确，但开销低](#6lzs-1711212829915)

<a name="pm78-1740363636733"></a>[无可挂载索引，将退化为表锁，性能不利，但这是回退到一个安全位置。](#bofb-1711212877091)

<a name="hslb-1740363636735"></a>[序列化快照隔离SSI（高性能序列化算法）](#slwa-1710172573367)

<a name="rpf4-1740363636737"></a>[新算法：可序列化快照隔离SSI serializeble snapshot isolation 仅与快照隔离有很小性能损失. 08年 micheal cahill博士论文。](#lnci-1711213123166)

<a name="ju6s-1740363636739"></a>[用于单节点PostgreSQL9.1后序列化和分布式数据库](#weo0-1711213307841)

<a name="tl5s-1740363636741"></a>[处于实践证明阶段](#ue1s-1711213377985)

<a name="0wka-1740363636743"></a>[悲观pessimistic与乐观optimistic的并发控制](#yq9i-1710172639651)

<a name="chsq-1740363636745"></a>[极致悲观：串行排它锁](#54jr-1711213690005)

<a name="oawr-1740363636747"></a>[序列化快照隔离SSI是乐观技术： ](#bjxf-1711213769533)

<a name="u0xd-1740363636749"></a>[缺点：多事务争用contention时性能不佳，大部分事务中止，吞吐量极限下有重试机制将使性能变差。](#mefw-1711213819265)

<a name="9npi-1740363636751"></a>[优点：有备用容量，竞争不高场景比悲观好，可交换的原子操作可减少争用。](#nk1s-1711213915330)

<a name="dxqj-1740363636753"></a>[SSI在快照隔离基础上添加算法检测写入的序列化冲突，并决定中止哪些事务。](#snvf-1711214019984)

<a name="qda7-1740363636755"></a>[基于过时前提的决策](#9lgw-1710172651041)

<a name="f6fm-1740363636757"></a>[医生值班读取-修改-写入。数据库检测过时并终止：](#td4m-1711214184809)

<a name="ctqz-1740363636759"></a>[检测对旧MVCC对象版本的读取(读之前存在未提交的写入)](#t08a-1711215992016)

<a name="fokz-1740363636761"></a>[检测影响先前读取的写入（读之后发生写入）](#aego-1711216030637)

<a name="jdhm-1740363636763"></a>[检测旧MVCC读取](#5smj-1710172660675)

<a name="ogd5-1740363636765"></a>[事务提交时，检测是否有被忽略的写入已被提交。](#z7u2-1711216050316)

<a name="omgk-1740363636767"></a>[SSI支持一致快照中长时间运行的读取-仅在提交时中止检测的陈旧读取。因为只读不产生幻读和写入偏差风险](#afqq-1711216243096)

<a name="2pyt-1740363636769"></a>[检测影响之前读取的写入](#mvok-1710172671381)

<a name="cvmc-1740363636771"></a>[事务写入提交时，在索引中查找最近读取受影响的其他事务，通知读取的事务非最新。并中止未提交写入的其他事务。](#mo5j-1711216452745)

<a name="bz1r-1740363636773"></a>[可序列化的快照隔离的性能](#0sq6-1710172685702)

<a name="tgyv-1740363636775"></a>[粒度granularity，精准哪些事务需要中止，但簿记开销显著。](#g2eg-1711216636788)

<a name="hjnx-1740363636777"></a>[简略的跟踪速度快（粗粒度），但导致不必要的事务中止。](#ux2m-1711216812849)

<a name="f4th-1740363636779"></a>[相比2PL, 不需要锁定阻塞，读性能高](#jzqb-1711216700614)

<a name="hkcn-1740363636781"></a>[相比串行化，可扩展多台机器提高吞吐量，可跨分区读。](#qm51-1710756953994)

<a name="topg-1740363636783"></a>[SSI要求事务尽量短，避免长事务发生冲突中止。慢事务SSI比2PL或串行执行更不敏感](#wvsk-1711216911828)

<a name="n0yf-1740363636785"></a>[8.分布式系统的麻烦](#enui-1704985776096)

<a name="gu3e-1740363636787"></a>[前几章failover故障切换, 复制延迟 与事务控制 处理各种可能发生的边缘情况，本章则是彻底的悲观总结。](#e2bp-1711387736669)

<a name="hlsv-1740363636789"></a>[故障与部分失效](#4yaw-1711386647072)

<a name="ihwm-1740363636791"></a>[部分失效partial failure  不确定性的nondeterministic: IDC配电单元故障](#9d0g-1711387883443)

<a name="1g71-1740363636793"></a>[云计算与超级计算机](#w7ln-1711386736921)

<a name="2geh-1740363636795"></a>[不可靠的网络(Timeout)](#ynhs-1711386665148)

<a name="vmxw-1740363636797"></a>[请求丢失： 拔网线](#fav6-1711388032544)

<a name="snuj-1740363636799"></a>[请求排队：](#znsf-1711388048086)

<a name="qgyd-1740363636801"></a>[请求失效：](#gmdu-1711388084834)

<a name="eyhp-1740363636803"></a>[.....](#dssu-1711388054944)

<a name="rlya-1740363636805"></a>[真实世界的网络故障](#y933-1711387087536)

<a name="kqf2-1740363636807"></a>[检测故障](#aywv-1711387099045)

<a name="awi1-1740363636809"></a>[超时与无穷的延迟](#z4hi-1711387103669)

<a name="vocj-1740363636811"></a>[级联失效cascading failure](#qs2e-1711388153448)

<a name="3mzi-1740363636813"></a>[网络拥塞和排队](#gttn-1711387323883)

<a name="mkdu-1740363636815"></a>[TCP执行流量控制flow control](#v9f2-1711388199023)

<a name="gqfm-1740363636817"></a>[视频、语音会议使用UDP，折中丢包与流畅](#up7k-1711389082773)

<a name="cp7l-1740363636819"></a>[同步网络vs异步网络](#t56p-1711387113980)

<a name="sbjp-1740363636821"></a>[有限延迟bounded delay：同步网络，不收排队影响](#fmrl-1711389283437)

<a name="9qhk-1740363636823"></a>[我们不能简单地使用网络延迟可预测吗](#bwvp-1711387335617)

<a name="ob3a-1740363636825"></a>[不可靠的时钟](#l3p1-1711386676597)

<a name="lttj-1740363636827"></a>[机器的时钟：硬件设备，石英振荡器，](#faqp-1711469591901)

<a name="1xk0-1740363636829"></a>[不是完全准确的。](#xtjc-1711469629964)

<a name="nas1-1740363636831"></a>[同步时钟：网络时间协议NTP](#knwp-1711469656643)

<a name="36su-1740363636833"></a>[服务器从精确时间源获取时间-GPS接收器](#pfpq-1711469689783)

<a name="tsey-1740363636835"></a>[单调钟与时钟](#qoxv-1711387218692)

<a name="7v1k-1740363636837"></a>[时钟](#wu2k-1711387376627)

<a name="vat1-1740363636839"></a>[Linux: clock_gettime(CLOCK_REALTIME)](#obwb-1711469781129)

<a name="mkwa-1740363636841"></a>[java:system.currentTimeMilis](#uxdp-1711469821742)

<a name="o8le-1740363636843"></a>[通常与NTP同步，但举例NTP服务器太远，则可能被强制重置(及时跳回）](#gwyx-1711469840905)

<a name="fnqe-1740363636845"></a>[单调钟](#hl1a-1711387385739)

<a name="egy6-1740363636847"></a>[保证总是前进](#uzaz-1711470052827)

<a name="mwru-1740363636849"></a>[Linux:CLOCK_MONOTONIC](#tbmn-1711469988760)

<a name="copg-1740363636851"></a>[java:System.nanoTime](#fb70-1711470014393)

<a name="bwko-1740363636853"></a>[调整频率：NTP检测到计算机石英钟更快或更慢，则调整单调钟频率（偏移skewing时钟）.](#sn42-1711470028035)

<a name="klmn-1740363636855"></a>[不假定不同节点时钟存在同步：分布式系统用单调钟效果好，对测量的不准确不敏感](#ct3v-1711470667953)

<a name="mx2z-1740363636857"></a>[时钟同步与准确性](#a7gy-1711387238026)

<a name="ol1s-1740363636859"></a>[漂移drifts: 计算机石英钟不准确原因,取决机器温度。](#pbyu-1711470750697)

<a name="bbch-1740363636861"></a>[实现精确度：GPS接收机，精确时间协议PTP](#kgdy-1711470917769)

<a name="qrud-1740363636863"></a>[同步错误的原因：NTP守护进程配置错误，防火墙阻止NTP通信。](#kgez-1711470944635)

<a name="gc7e-1740363636865"></a>[依赖同步时钟](#vo0i-1711387245745)

<a name="n07o-1740363636867"></a>[使用需要同步时钟的软件需监测所有机器间的时钟偏移](#zm2f-1711471000801)

<a name="nsyq-1740363636869"></a>[有序事件的时间戳](#fnxq-1711387475761)

<a name="jwdl-1740363636871"></a>[写入排序问题：B客户端写入比A晚但具有更早的时间戳。 ](#n1pp-1711471283186)

<a name="3xpf-1740363636873"></a>[ 最后写入为准LWW](#50kp-1711471399605)

<a name="rv7s-1740363636875"></a>[ 版本向量](#axgx-1711471482711)

<a name="wg9y-1740363636877"></a>[时钟读数存在置信区间](#ofpq-1711387431462)

<a name="pqpd-1740363636879"></a>[ 置信区间的不确定性：NTP服务器的不去定性，加上服务器网络往返时间](#aihs-1711471513794)

<a name="l2zm-1740363636881"></a>[当clock_gettime()返回值不会告诉你预期错误，不知道置信区间是5毫秒还是5年](#aave-1711471693187)

<a name="mgjm-1740363636883"></a>[例外：Spanner Google TureTime API明确报告本地时钟置信区间（最早，最晚）。](#znqm-1711471741654)

<a name="9znp-1740363636885"></a>[全局快照的同步时钟](#bfz6-1711387449885)

<a name="eddh-1740363636887"></a>[分布式的事务快照隔离，分布式事务ID时序成为站不住脚瓶颈](#dpco-1711471815493)

<a name="hlyj-1740363636889"></a>[Spanner通过置信区间来比较A,B发生的时序。](#2ihe-1711471939317)

<a name="spqb-1740363636891"></a>[分布式事务语义使用时钟同步是一个活跃的研究领域，没有在谷歌之外的主流数据库中实现。](#9qfk-1711471991096)

<a name="kerv-1740363636893"></a>[暂停进程](#3mnj-1711387250438)

<a name="ioyh-1740363636895"></a>[如何确保分布式主节点仍未领导者](#ui0e-1711472636558)

<a name="3tau-1740363636897"></a>[方式一：从其他节点获得租约lease, 类似一个带超时的锁，周期性过期前续约。-和redison续约类似](#yh9a-1711472775035)

<a name="kf5t-1740363636899"></a>[过期时，由另一个节点接管。](#kqwv-1711472837428)

<a name="swfs-1740363636901"></a>[缺点：依赖同步时钟](#gi5a-1711473874947)

<a name="tr97-1740363636903"></a>[意外的时间停顿：](#93uw-1711473992955)

<a name="pqvp-1740363636905"></a>[stop-the-world  HotSpot GC](#7kp7-1711474017909)

<a name="iexs-1740363636907"></a>[suspend虚拟机](#6ejp-1711474059672)

<a name="lwgo-1740363636909"></a>[随意暂停恢复：关闭笔记本盖子](#92se-1711474080346)

<a name="j7p2-1740363636911"></a>[窃取时间steal time:虚拟机切换或cpu上下文切换，在其他机器中花费的时间.](#tfxw-1711474128862)

<a name="9qre-1740363636913"></a>[同步时的阻塞io：java惰性加载类文件；磁盘为网络文件系统或网络块设备-亚马逊EBS](#7jwg-1711474280466)

<a name="bw1h-1740363636915"></a>[磁盘交换内存抖动thrashing: 允许交换到磁盘（分页），内存访问可能导致页面错误page fault .话费大量时间将页面交换到内存，实际完成的工作很少thrashing。 服务器机器禁用页面调度，干掉进程释放内存。](#kvsa-1711474441136)

<a name="vn8s-1740363636917"></a>[SIGSTOP暂停unix进程:Ctrl-Z立即阻止进程的CPU周期](#ocvk-1711474648160)

<a name="coht-1740363636919"></a>[这些都可以随时抢占preempt正在运行的线程。](#t1w7-1711474768157)

<a name="4fpr-1740363636921"></a>[响应时间保证](#cirf-1711473855327)

<a name="9f46-1740363636923"></a>[硬实时hard real-time系统: 不满足特定截止时间deadline可能会导致整个系统故障。](#r1ji-1711474887529)

<a name="x4ku-1740363636925"></a>[嵌入式系统精心设计和测试：安全气囊不会因系统GC暂停弹出。](#pgjw-1711475001376)

<a name="1qtn-1740363636927"></a>[大量的额外工作，昂贵。](#urp5-1711475089330)

<a name="ca42-1740363636929"></a>[限制垃圾收集的影响](#i1wt-1711387521748)

<a name="wh28-1740363636931"></a>[通知GC暂停，停止接收新请求-对延迟敏感的金融系统](#oxal-1711475134772)

<a name="rn6f-1740363636933"></a>[变种：GC只收集新生代，积累老年代，一次重启一个节点，类似滚动升级。](#ho3v-1711475217820)

<a name="eygh-1740363636935"></a>[知识、真相与谎言](#ujyf-1711386681865)

<a name="8vkn-1740363636937"></a>[真理由多数所定义](#hdwi-1711387268312)

<a name="lgri-1740363636939"></a>[stop the world 一分钟，被其他节点宣告死亡，重新选举。](#rxcy-1711561420884)

<a name="1jvw-1740363636941"></a>[领导者与锁定](#3zea-1711387542106)

<a name="nkbk-1740363636943"></a>[数据库分区领导者只能有一个节点：避免脑裂](#b6am-1711561462773)

<a name="37pe-1740363636945"></a>[特定资源的锁和对象只允许一个事务/客户端持有](#3ynw-1711561525662)

<a name="1uab-1740363636947"></a>[用户唯一标识](#hqa3-1711561556083)

<a name="ik0i-1740363636949"></a>[节点认为它是天选者the choosen one](#rv2w-1711561875596)

<a name="q2we-1740363636951"></a>[HBase例子：分布式锁的实现不正确，客户端1持有锁stop the world导致lease超时,客户端2获得锁进行处理，客户端1仍认为它具有有效的租约，即使它已经过期，从而破坏了存储的文件。](#gu25-1711561617808)

<a name="hgrm-1740363636953"></a>[防护令牌](#mhlf-1711387550649)

<a name="zlsb-1740363636955"></a>[解决天选者问题：防护fencing](#gw5w-1711561950975)

<a name="oljn-1740363636957"></a>[fencing token :只允许增加屏蔽令牌的顺序进行写操作。](#vi5w-1711562021406)

<a name="vbwt-1740363636959"></a>[服务器端检查token,获取锁时token增加33+1，存储服务器记录更高令牌34的写入，拒绝令牌33的请求。-一般是redisson续期，这个更像乐观锁。](#2yxl-1711562140276)

<a name="9b1k-1740363636961"></a>[ZooKeeper将事务标识zxid和节点版本conersion用作屏蔽令牌。保证了单调递增](#e6n2-1711562077138)

<a name="nr2x-1740363636963"></a>[如文件存储服务器可将令牌卸载文件命中](#uujk-1711564755459)

<a name="bdp2-1740363636965"></a>[拜占庭故障](#bsay-1711387279845)

<a name="qsuh-1740363636967"></a>[拜占庭故障Byzantine fault: 在不信任的环境中达成共识的问题称为拜占庭将军问题。](#id0b-1711628556885)

<a name="kx25-1740363636969"></a>[拜占庭将军问题：n位将军需要同意，一些叛徒通过发送虚假或不真实信息来混淆欺骗他人。](#lxw6-1711628612728)

<a name="8h0q-1740363636971"></a>[拜占庭容错：系统在部分节点发生故障、不遵守协议，恶意攻击，扰乱网络时仍能继续正确工作：](#lpn6-1711628716132)

<a name="r913-1740363636973"></a>[航空航天环境计算机被辐射破坏，不可预知方式响应其他节点](#py6z-1711638469892)

<a name="n6nk-1740363636975"></a>[多个参与组织系统中，参与者试图欺骗他人。比特币等区块链对等网络让互不信任的各方同意交易不依赖中央当局。](#csli-1711638605446)

<a name="or2x-1740363636977"></a>[弱谎言形式](#f38o-1711387557457)

<a name="ohwd-1740363636979"></a>[添加防止撒谎弱形式机制；](#eepx-1711638744038)

<a name="put3-1740363636981"></a>[校验和防止数据包被破坏](#yseh-1711638821915)

<a name="7jya-1740363636983"></a>[公开访问的系统需仔细清理来自用户的任何输入](#2a8h-1711638847924)

<a name="c2dn-1740363636985"></a>[NTP多数对时间范围达成一致，配置错误的服务器将被排除](#zcdt-1711638888096)

<a name="393q-1740363636987"></a>[系统模型与实现](#x4lu-1711387293192)

<a name="3d2b-1740363636989"></a>[定时假设三种系统模型：](#iyps-1711639179162)

<a name="vfc3-1740363636991"></a>[同步模型synchronous model: 网络延迟，暂停和时钟漂移不会超过某个固定上限；](#pgo0-1711640511485)

<a name="kd1k-1740363636993"></a>[部分同步模型partial synchronous：大多数情况像一个同步系统一样运行，有时出现超时，进程暂停和时钟漂移界限](#h1x4-1711640383000)

<a name="a8nr-1740363636995"></a>[异步模型：一个算法不允许对实际做任何假设，事实上它甚至没有时钟。](#vkkn-1711640459345)

<a name="m4kx-1740363636997"></a>[节点系统模型：-节点失效问题](#lg5f-1711640536166)

<a name="j0d5-1740363636999"></a>[崩溃停止crash-stop:只能由崩溃失效，且永远不会回来。](#ahco-1711640498506)

<a name="risa-1740363637001"></a>[崩溃恢复crash-recovery: 具有稳定存储（非易失性磁盘），崩溃中保留，内存中状态会丢失-innodb三阶段提交](#35nl-1711640632666)

<a name="ngj4-1740363637003"></a>[拜占庭（任意）故障：节点可以做任何事情，包括戏弄和欺骗其他节点](#rpmc-1711640822813)

<a name="sraf-1740363637005"></a>[具有崩溃恢复的部分同步模型是最有用的模型。分布式算法如何应用这种模型](#6gea-1711640879281)

<a name="ebsn-1740363637007"></a>[算法的正确性](#hwoz-1711387576180)

<a name="fkph-1740363637009"></a>[描述属性：定义算法的正确性](#i9kv-1711640972087)

<a name="zxbs-1740363637011"></a>[锁生成屏蔽令牌，要求具有以下属性：](#qsck-1711641049261)

<a name="dgtv-1740363637013"></a>[唯一性：没有两个屏蔽令牌请求返回相同的值](#tvxj-1711641079676)

<a name="ooac-1740363637015"></a>[单调序列：时序实现单调](#2d0a-1711641105012)

<a name="akbq-1740363637017"></a>[可用性：请求防护令牌且不会崩溃的节点，最终会收到响应](#mlbd-1711641130527)

<a name="yfoz-1740363637019"></a>[安全性和活性](#1lz8-1711387585629)

<a name="fmve-1740363637021"></a>[澄清这种情况，需区分两种不同性质](#hctm-1711641203049)

<a name="tut3-1740363637023"></a>[安全性safety: 唯一性和单调序列](#k48b-1711641295367)

<a name="q0jz-1740363637025"></a>[活性：可用性](#fmy7-1711641313609)

<a name="3zdj-1740363637027"></a>[将系统模型映射到现实世界](#ndiw-1711387592922)

<a name="n9tl-1740363637029"></a>[9.一致性共识](#rp9s-1705080859004)

<a name="qixn-1740363637031"></a>[共识consensus: 让所有节点对某件事达成一致](#vrvh-1712996687843)

<a name="0l6n-1740363637033"></a>[脑裂brain split: 两个节点都认为自己是master, 经常导致数据丢失；](#oqcs-1712996726634)

<a name="k6vz-1740363637035"></a>[一致性保证](#obqn-1711730044966)

<a name="m7n0-1740363637037"></a>[最终一致性：收敛convergence, 最终收敛到相同的值](#ku5g-1712996774138)

<a name="nwlc-1740363637039"></a>[事务一致性：避免同时执行事务导致的竞争状态](#ga60-1712996859001)

<a name="at94-1740363637041"></a>[分布式一致性模型：面对延迟和故障时，如何协调副本间的状态](#eovi-1712996916251)

<a name="zllx-1740363637043"></a>[线性一致性](#thyh-1711730049653)

<a name="ymz2-1740363637045"></a>[背后的想法：原子一致性atomic consistency, 强一致性strong consistency, 立即一致性 immediate consistency ,外部一致性 external consistency](#bvre-1712997165569)

<a name="iymb-1740363637047"></a>[看起来只有一个数据副本，实际有多个副本 - 强一致性就是逆分布式化，看成一个整体。](#qbsw-1712997247742)

<a name="ymnk-1740363637049"></a>[线性一致是一个新鲜度保证 recency gurantee;](#f0su-1712997377059)

<a name="gjy2-1740363637051"></a>[非线性一致的例子： world cup ,  alice refresh - DB1 return germany 1: 0 argentina won ;  bob refresh website - DB2(un asychronize) return still playing;](#mtb7-1712997407717)

<a name="x0sn-1740363637053"></a>[为什么使得系统线性一致？](#qimr-1711730403998)

<a name="5f6x-1740363637055"></a>[例子：CAS使得多个客户端并发按序更新](#ffat-1712998155207)

<a name="taj9-1740363637057"></a>[线性一致性与可序列化是两种完全不同的保证：](#3elk-1712997586736)

<a name="dtsf-1740363637059"></a>[可序列化serializeble: 单对象或者多对象操作，确保按照某种顺序执行](#qpvu-1712998010030)

<a name="is3e-1740363637061"></a>[线性一致性Linearizability:是读取和写入寄存器（单个对象）的新鲜度保证，不会将操作组合为事务，不会阻止写入偏差等问题](#ojsh-1712998125336)

<a name="7zmz-1740363637063"></a>[单副本强可串行性strong-1SR: 一个数据库可提供可串行性和线性一致, 基于两阶段锁2PL和实际串行执行通常是线性一致的](#5hda-1712998332148)

<a name="uad0-1740363637065"></a>[SSI一致性快照不是线性一致的：不会包括比快照更新的写入；-不会阻塞非写的读。](#obfn-1712998432352)

<a name="it54-1740363637067"></a>[依赖线性一致性](#bje8-1711730427157)

<a name="2yvj-1740363637069"></a>[锁定与领导选举](#xyll-1711730652620)

<a name="0vfh-1740363637071"></a>[领导选举的一种方法：每个节点启动时尝试获取锁，成功者称为领导者。](#2fqs-1712998599719)

<a name="kfil-1740363637073"></a>[保证锁时线性一致的： zookeeper 和 etcd 协调服务的一致性算法。curator基于zookeeper上更高级别的配方](#cbzr-1712998723133)

<a name="7kxj-1740363637075"></a>[约束和唯一性保证](#gpva-1711730659968)

<a name="3zi6-1740363637077"></a>[这种情况类似于一个锁，锁定用户名。该操作与原子性的cas类似：](#9jmj-1712998930168)

<a name="w2fu-1740363637079"></a>[用户名和邮箱；](#lhyk-1712999021176)

<a name="ieel-1740363637081"></a>[银行账号不为负数；](#7sgo-1712999031257)

<a name="z11d-1740363637083"></a>[航班剧院预定了同一时间同一位置](#so5k-1712999045093)

<a name="bkmz-1740363637085"></a>[实际应用中，处理这些限制有时可以接受。如调换位置并补偿。](#q05j-1712999070223)

<a name="isa4-1740363637087"></a>[跨信道的时序依赖](#7cbv-1711730671963)

<a name="dkor-1740363637089"></a>[将用户上传的照片降低分辨率以加快下载速度：](#cqkp-1712999245541)

<a name="qbhg-1740363637091"></a>[步骤：消息队列一般针对较短的消息而设计，一张图片可能达到几M.所以步骤为](#3zoo-1712999362806)

<a name="asdu-1740363637093"></a>[1.上传照片-  web server-2.  (store img) 存储文件服务器  ](#umkb-1712999318589)

<a name="cgpq-1740363637095"></a>[  | 3. send message  || 5.fetch full size img  6.store resized img](#er8u-1712999518585)

<a name="1xqs-1740363637097"></a>[消息队列   - 4.deliver message     image resizer](#iiv4-1712999532781)

<a name="8psn-1740363637099"></a>[问题：存储和缩放存在两个不同的信道，没有线性一致的新鲜度保证](#0yys-1712999647965)

<a name="hwir-1740363637101"></a>[3和4可能比存储服务器内部的复制更快，当5时，可能会看到图像旧版本或者什么都没有，如果处理的是旧版本，则产生不一致。](#xtun-1712999768959)

<a name="i4hx-1740363637103"></a>[实现线性一致性的系统](#ytt0-1711730433598)

<a name="olmj-1740363637105"></a>[单主复制（可能线性一致）protential潜在线性一致：](#j997-1712999879559)

<a name="w5kn-1740363637107"></a>[快照隔离并发错误；](#t174-1712999979364)

<a name="rtoc-1740363637109"></a>[脑裂；异步复制延迟，故障切换](#hh6o-1712999996439)

<a name="mlk3-1740363637111"></a>[共识算法（线性一致）：共识算法可以安全实现线性一致性的存储，zookeeper 和 etcd](#z3nq-1713000050923)

<a name="sb3h-1740363637113"></a>[多主复制（非线性一致）：同时多个节点上处理写入，异步复制到其他节点，会产生冲突的写入](#q0kz-1713000066034)

<a name="slf3-1740363637115"></a>[无主复制（也许不是线性一致的）：Dynamo风格，法定人数读写获得强一致性。通常不完全正确](#ca4m-1713030167882)

<a name="jokl-1740363637117"></a>[线性一致性和法定人数](#9gst-1711730681011)

<a name="yyqe-1740363637119"></a>[最安全的做法是：假设采用Dynamo风格的无主复制的系统是不能提供线性一致性。](#sqvx-1713030399799)

<a name="vzvf-1740363637121"></a>[线性一致性的代价](#vpxf-1711730440465)

<a name="eu9b-1740363637123"></a>[CAP定理](#fqqf-1711730717308)

<a name="nozf-1740363637125"></a>[不仅是单主多主复制的后果，任何线性一致性的数据库都有这个问题：](#8hzl-1713030564813)

<a name="htak-1740363637127"></a>[.应用需要线性一致性，副本因为网络问题断开连接，请求必须等到网络问题解决或直接返回错误（不可用unavailable）](#7lux-1713030592466)

<a name="vg1g-1740363637129"></a>[.网络断开也可独立处理请求（如多主复制），可以在网络问题前保持可用，但其行为不是线性一致的。](#48wk-1713031150235)

<a name="tu0c-1740363637131"></a>[CAP定理没有帮助：网络分区是不可避免的，所以只能是AP 或 CP。](#lsdc-1713031249676)

<a name="dfdg-1740363637133"></a>[线性一致性和网络延迟](#kxsm-1711730728177)

<a name="kqxc-1740363637135"></a>[ 线性一致的系统惊人的少。例如多核CPU并没有保证一定能读到第一个线程写入的值（除非使用内存屏障memory barrier或围栏fence）](#lbl2-1713031508671)

<a name="1wxs-1740363637137"></a>[ 牺牲线性一致性的原因是性能performance. 内存访问先走缓存，副本都是异步更新的，所以失去了线性一致性。](#pnsn-1713031585885)

<a name="xefz-1740363637139"></a>[搞笑的线性一致性存储不可实现。](#8y6v-1713031685808)

<a name="yc66-1740363637141"></a>[顺序保证](#on5f-1711730057760)

<a name="dcry-1740363637143"></a>[写入顺序order of write: 单主复制的主要目的就是复制日志中确定写入顺序。](#dhiv-1713031758875)

<a name="nhav-1740363637145"></a>[序列顺序serial order：某种序列顺序some sequential order](#cyfr-1713031815356)

<a name="nlcn-1740363637147"></a>[顺序与因果](#z48k-1711730472679)

<a name="zxas-1740363637149"></a>[顺序有助于保持因果关系causality](#khzl-1713031939113)

<a name="k0v0-1740363637151"></a>[一致前缀读：先看到答案再看到问题。违背因cause果effect. 存在因果依赖causal dependency](#nbes-1713031966982)

<a name="tldu-1740363637153"></a>[更新不存在的记录：3位领导者间的复制，一些写入会压到其他写入。一条记录需被创建才能更新。](#xehj-1713032060272)

<a name="t6xs-1740363637155"></a>[检测并发写入：A和B并发，则不知道顺序，A和B不知道彼此。](#v1kv-1713032135082)

<a name="8pvs-1740363637157"></a>[快照隔离：写偏差read skew，读取的数据违反因果关系（不可重复读）](#ozi8-1713032226341)

<a name="co04-1740363637159"></a>[事务的写偏差write skew：幻读和值班。](#pgzq-1713032264605)

<a name="dxuj-1740363637161"></a>[世界杯球赛结果，跨信道的时序依赖。](#3ang-1713032756197)

<a name="uiri-1740363637163"></a>[因果一致causally：系统服从因果关系锁规定的顺序。](#tryg-1713032788961)

<a name="tjq2-1740363637166"></a>[因果顺序不是全序的](#niwx-1711730751513)

<a name="ctto-1740363637168"></a>[全序total order: 自然数更大或更小，总是有序的](#x8gk-1713086054855)

<a name="to3f-1740363637170"></a>[偏序partially order: 一个集合大于另一个集合，但是其它情况下无法比较](#wvsa-1713086222914)

<a name="dzoq-1740363637172"></a>[线性一致性：操作是全序的，系统表现好像只有一个副本，所有操作都是原子性的。意味对每个操作总能判定发生顺序](#u7jq-1713086312064)

<a name="ecvl-1740363637174"></a>[因果性：两个操作没在彼此之前发生，即并发无法比较顺序，意味着因果关系定义了一个偏序，而不是全序。一些有序一些无序](#xa0w-1713086399916)

<a name="iaam-1740363637176"></a>[线性一致的数据存储中是不存在并发操作的。确保每个请求都是在唯一时间线上自动处理](#uaxz-1713086531138)

<a name="38am-1740363637178"></a>[并发意味着时间线会分叉然后合并。操作的偏序：](#qs64-1713086635361)

<a name="0znf-1740363637180"></a>[类似git系统，一个提交commit发生在另一个提交之后。分支合并merge会在这些并发创建的提交相融合时创建。](#ctkd-1713086670170)

<a name="pba9-1740363637182"></a>[线性一致性强于因果一致性](#qdnf-1711730766239)

<a name="28qp-1740363637184"></a>[线性一致性隐含implies着因果关系;](#dam4-1713086279684)

<a name="d5u6-1740363637186"></a>[捕获因果关系](#uqqx-1711730776113)

<a name="lb28-1740363637188"></a>[为了维持因果性，需确认操作发生在哪个操作之前happened before:](#agrw-1713086796608)

<a name="mhqp-1740363637190"></a>[刑侦决定Y时是否知到X与Y因果关系](#rys3-1713086865582)

<a name="gz8w-1740363637192"></a>[检测并发写入：推广版本向量解决因果依赖](#znup-1713086911030)

<a name="i7rb-1740363637194"></a>[SSI序列化隔离快照：事务提交时，检测读取是否最新，为此跟踪哪些事务被那些事务锁读取。](#1ivk-1713086936754)

<a name="1gg3-1740363637196"></a>[序列号顺序](#jsuf-1711730485869)

<a name="owzp-1740363637198"></a>[序列号sequence number或时间戳timestamp](#y9ti-1713091524670)

<a name="r6x9-1740363637200"></a>[非因果序列号生成器](#qpya-1711730796494)

<a name="klf9-1740363637202"></a>[兰伯特时间戳](#mtzj-1711730811106)

<a name="fag1-1740363637204"></a>[兰伯特时间戳提供了与因果关系一致的总排序：施行一个全序](#f8uv-1713091653199)

<a name="qult-1740363637206"></a>[检测并发写入有着不同目的：区分两个操作是并发的，一个因果依赖另一个。](#2ayx-1713091789731)

<a name="xfvo-1740363637208"></a>[光有时间戳排序还不够](#elc6-1711730816628)

<a name="jstb-1740363637210"></a>[全序广播](#aw2l-1711730490423)

<a name="fwu1-1740363637212"></a>[可靠交付reliable delivery：没有消息丢失，如果消息被传递到一个节点，它将被传递到所有节点](#axul-1713091937508)

<a name="p9zw-1740363637214"></a>[全序交付totally ordered delivery: 消息以相同的顺序传递给每个节点。](#cruc-1713091989510)

<a name="50ho-1740363637216"></a>[使用全序广播](#hp3a-1711730834892)

<a name="eb5i-1740363637218"></a>[zookeeper和etcd共识服务实际上实现了全序广播](#ztws-1713108978601)

<a name="qzpv-1740363637220"></a>[状态机复制state machine repliacation: 每个副本都按相同的顺序处理相同的写入。](#i8bk-1713109007327)

<a name="a5m4-1740363637222"></a>[与之类似，使用全序广播来实现可序列化的事务：真的串行执行，确定的事务以存储过程来执行，每个节点以相同的顺序处理这些消息。](#8jch-1713109071990)

<a name="ckm2-1740363637224"></a>[以及防护令牌的锁服务，全序广播使得所有消息按顺序一次编号，序列号可当做防护令牌(单调递增)，zookeeper中这个序列号称为zxid;](#w19a-1713109204107)

<a name="i8tn-1740363637226"></a>[使用全序广播实现线性一致的存储](#i3vg-1711730844593)

<a name="bmy5-1740363637228"></a>[使用线性一致性存储实现全序广播](#xlae-1711730855140)

<a name="kvdi-1740363637230"></a>[分布式事务与共识](#y1bv-1711730380233)

<a name="hvbd-1740363637232"></a>[让几个节点达成一致get serveral nodes to agree on somthing](#yt5r-1713109388776)

<a name="qnzl-1740363637234"></a>[领导选举：避免脑裂](#d7t7-1713109479427)

<a name="2xpt-1740363637236"></a>[原子提交atomic commit：多节点事务提交/中止/回滚](#frsp-1713109508353)

<a name="jmgy-1740363637238"></a>[原子提交与两阶段提交2PC](#abk6-1711730509647)

<a name="2fro-1740363637240"></a>[原子性可以避免中间态，多对象事务原子性确保二级索引与主数据库保持一致。](#0h2f-1713110484428)

<a name="foip-1740363637242"></a>[从单节点到分布式原子提交](#iqfd-1711730882368)

<a name="mz12-1740363637244"></a>[从数据库的角度看，这是单独的事务，任何跨事务正确性的保证都是应用自己的问题。](#h1ym-1713110537245)

<a name="kbcf-1740363637246"></a>[2PC两阶段提交简介](#roa9-1711730906391)

<a name="tgr6-1740363637248"></a>[coodinator协调子事务，子事务单独执行完，在准备阶段询问是否可提交](#vaax-1705118249954)

<a name="zaop-1740363637250"></a>[.全部为是，则分别提交。](#7zwc-1705118288968)

<a name="n1cu-1740363637252"></a>[.其中有否，则中断回滚。](#3b8s-1705118337513)

<a name="wgfz-1740363637254"></a>[系统承诺](#kpgk-1711730913393)

<a name="ixhu-1740363637256"></a>[一旦协调者做出决定，这一决定是不可撤销的。](#wkui-1713110739239)

<a name="zqtf-1740363637258"></a>[协调者失败](#qhdj-1711730921387)

<a name="4qos-1740363637260"></a>[参与者投赞成票后，参与者协调者崩溃，数据库1不知道是否提交或中止。](#jpd8-1713110804532)

<a name="dqad-1740363637262"></a>[三阶段提交](#ixzv-1711730924556)

<a name="qa1j-1740363637264"></a>[阻塞blocking原子提交协议, 2PC可能卡主等待协调者恢复的情况。](#edp3-1713111179295)

<a name="rjmf-1740363637266"></a>[在提交阶段，如果子事务进程crash,或者协调者崩溃的时的解决方案，弱原子性，最终一致性。](#llyc-1711731148564)

<a name="93de-1740363637268"></a>[许多coodinator不支持高可用或者只支持基本的复制](#nlrk-1705118500709)

<a name="b45u-1740363637270"></a>[实践中的分布式事务](#xexf-1711730524691)

<a name="ystd-1740363637272"></a>[云服务由于其导致的运维问题而选择不实现分布式事务。](#inqh-1713111548114)

<a name="2lbk-1740363637274"></a>[两阶段难以实现安全保证，且导致的运维问题造成性能下降。](#zuho-1713111590325)

<a name="sabw-1740363637276"></a>[数据库内部的分布式事务](#gf92-1711731287296)

<a name="cnqz-1740363637278"></a>[VoltDB 与mysql Cluster 的NDB引擎就有这样的内部事务支持。](#jhqw-1705080950920)

<a name="6evl-1740363637280"></a>[异构分布式事务](#gvng-1713111648038)

<a name="mqz5-1740363637282"></a>[保证异构数据库的事务更有挑战性](#st60-1713111659854)

<a name="vvbw-1740363637284"></a>[恰好一次的消息处理](#btdt-1711730944613)

<a name="b4m1-1740363637286"></a>[XA事务eXtended Architecture](#qvbk-1711730954739)

<a name="ia13-1740363637288"></a>[怀疑时持有锁](#med0-1711730959684)

<a name="odus-1740363637290"></a>[从协调者故障中恢复](#ouyq-1711730969007)

<a name="o6vl-1740363637292"></a>[唯一的出路是让管理员手动决定提交还是回滚事务](#ouur-1713116418144)

<a name="fyah-1740363637294"></a>[分布式事务的限制](#gzya-1711730975747)

<a name="vvqs-1740363637296"></a>[协调者本身就是一种数据库，存储了事务的结果。](#jkt3-1713116480399)

<a name="i7bn-1740363637298"></a>[协调者默认不是高可用的，只有基本的复制](#mcvv-1713116529836)

<a name="ov3l-1740363637300"></a>[应用服务器不再是无状态的了](#h6gt-1713116550997)

<a name="lp6u-1740363637302"></a>[不能检测不同系统间的死锁，且无法与SSI协同工作](#rrrl-1713116568769)

<a name="dbey-1740363637304"></a>[与构建容错系统的目标背道而驰，分布式事务有扩大失效amplifying failures的趋势](#wbzw-1713116600081)

<a name="f1uc-1740363637306"></a>[容错共识](#npne-1713118985168)

<a name="zfv6-1740363637308"></a>[一个或多个节点提议propose某些值，共识算法决定decides采用其中的某个值。](#beiq-1713118985169)

<a name="dall-1740363637310"></a>[一致同意Uniform agreement:  没有两个节点的决定不同-核心 决定了相同的结果，一旦决定不能改变](#pq0x-1713118985170)

<a name="jigt-1740363637312"></a>[完整性Integrity: 没有节点决定两次-核心](#xnwp-1713118985171)

<a name="w0jl-1740363637314"></a>[有效性validity: 如果一个节点决定了值v, 则v由某个节点所提议-排除平凡的解决方案](#2bty-1713118985172)

<a name="pces-1740363637316"></a>[终止Termination由所有为崩溃的几点来最终决定值。-活性属性，必须取得进展，即使部分节点出现故障，其他节点也必须达成一致。不超过一般的节点崩溃或不可达](#9k32-1713118985173)

<a name="jthz-1740363637318"></a>[稳健达成共识：只要少于三分之一的节点存在拜占庭故障](#scne-1713118985174)

<a name="izak-1740363637320"></a>[共识算法和全序广播](#prxr-1713118985175)

<a name="jeb2-1740363637322"></a>[视图戳复制VSR viewstamped repliacation, Paxos，Raft, Zab](#zmcg-1713118985176)

<a name="vixj-1740363637324"></a>[全序广播相当于重复进行多轮共识：](#1u8f-1713118985177)

<a name="uysh-1740363637326"></a>[一致同意属性，所有节点决定以相同的顺序传递相同的消息](#d2l2-1713118985178)

<a name="iqii-1740363637328"></a>[完整性属性，消息不会重复](#z7u4-1713118985179)

<a name="qc3e-1740363637330"></a>[有效性属性，消息不会被破坏，也不能凭空编造](#pphb-1713118985180)

<a name="ekez-1740363637332"></a>[终止属性,消息不会丢失](#gqmq-1713118985181)

<a name="cs2i-1740363637334"></a>[视图戳复制，raft和zab直接实现了全序广播，比重复一次一致one value a time的共识更高效， paxos 下这种优化称为multi-paxos.](#lxll-1713118985182)

<a name="tq3c-1740363637336"></a>[单领导者复制和共识](#krsz-1713118985183)

<a name="4u4n-1740363637338"></a>[时代编号和法定人数](#90tt-1713118985184)

<a name="5td2-1740363637340"></a>[共识的局限性](#qywj-1713118985185)

<a name="2fzw-1740363637342"></a>[成员与协调服务](#8qzt-1713118985186)

<a name="qftx-1740363637344"></a>[将工作分配给节点](#4tlb-1713118985187)

<a name="mmhe-1740363637346"></a>[服务发现](#tbbj-1713118985188)

<a name="9raw-1740363637348"></a>[成员服务](#1lld-1713118985189)

<a name="f850-1740363637350"></a>[第三部分：衍生数据](#46k8-1705118453932)

<a name="omai-1740363637352"></a>[记录和衍生数据系统](#rboc-1716226529015)

<a name="j5oj-1740363637354"></a>[从高层次看，存储和处理数据的系统可以分为两大类](#cmdh-1716226737947)

<a name="wa54-1740363637356"></a>[记录系统System of record](#1dmv-1716226552894)

<a name="yvxm-1740363637358"></a>[真相源source of truth. 记录用户输入新数据，标准化normalized](#dh96-1716226777418)

<a name="oham-1740363637360"></a>[衍生数据系统Derived data system](#qjlf-1716226568395)

<a name="74cu-1740363637362"></a>[缓存cache, 衍生数据是冗余的，重复了已有的信息。](#igtl-1716226871151)

<a name="mvho-1740363637364"></a>[10.批处理](#0bgb-1716226496297)

<a name="4ewc-1740363637366"></a>[服务（在线系统）：高可用性，性能指标-响应时间](#yygb-1720542683707)

<a name="ttw1-1740363637368"></a>[批处理系统（离线系统）：定时任务job，性能指标-吞吐量](#goo7-1720542700859)

<a name="iokw-1740363637370"></a>[流处理系统（准实时系统）：介于在线离线系统之间](#mv2a-1720542952432)

<a name="oqpm-1740363637372"></a>[使用Unix工具的批处理](#6lu4-1716228538928)

<a name="q9yi-1740363637374"></a>[分析简单日志](#hyii-1716228597300)

<a name="prfd-1740363637376"></a>[Unix命令链：网站上找到五个最受欢迎的网页（nginx/access.log）](#smoq-1720543218731)

<a name="a4c6-1740363637378"></a>[命令链与自定义程序Ruby](#ukyi-1716228816049)

<a name="jiwb-1740363637380"></a>[排序 VS 内存中的聚合](#cnuw-1716228829632)

<a name="gpkx-1740363637382"></a>[工作集working set(作业需要随机访问的内存大小)，单个url 重复出现百万次，哈希表性能好](#siiu-1720543940755)

<a name="wnjy-1740363637384"></a>[工作集大于内存，排序优，与SSTables 和 LSM树一样，内存聚合归并排序，GNU 中的sort通过溢出至磁盘自动应该大于内存大额数据集，瓶颈可能是磁盘io。-MQ的死信处理也是溢出到磁盘。](#lms0-1720544023798)

<a name="e5sh-1740363637386"></a>[Unix哲学](#mgei-1716228613042)

<a name="bf1y-1740363637388"></a>[统一的接口](#sk3b-1716228852580)

<a name="n49x-1740363637390"></a>[Unix中统一的接口是一个文件file](#33ju-1720874904091)

<a name="b6gf-1740363637392"></a>[ASCII文本，\n 分隔，](#yogq-1720875513301)

<a name="bvg9-1740363637394"></a>[CSV， ，号分隔](#7fvb-1720875542091)

<a name="lpge-1740363637396"></a>[逻辑与布线相分离](#3oxq-1716228869387)

<a name="b4ev-1740363637398"></a>[松耦合loose coupling](#0zy9-1720876020643)

<a name="opze-1740363637400"></a>[晚期绑定late binding](#226j-1720876035472)

<a name="y1xn-1740363637402"></a>[控制反转inversion of control](#zedb-1720876065554)

<a name="shok-1740363637404"></a>[透明度与实验](#ftj8-1716228879278)

<a name="kl4o-1740363637406"></a>[MapReduce和分布式文件系统](#djdy-1716228554334)

<a name="xpnf-1740363637408"></a>[MapReduce像是分布在数前台机器上的Unix。](#illh-1720876369554)

<a name="yqpq-1740363637410"></a>[Hadoop的Map-Reduce视线中，文件系统成为HDFS,基于google文件系统GFS的开源实现。](#e1cy-1720876447842)

<a name="1l1q-1740363637412"></a>[Amazon S3，  Azure blob ](#mapk-1720876955975)

<a name="etu9-1740363637414"></a>[MapReduce作业执行](#kdge-1716228625984)

<a name="kfgi-1740363637416"></a>[Mapper在每条输入记录上调用一次,从输入记录中提取键值（提取键值）](#vleh-1720877349422)

<a name="vkbn-1740363637418"></a>[Reduce拉取Mapper生成的键值对，收集属于同一个键的所有值。（收集同键的所有值）](#aol7-1720877397533)

<a name="emky-1740363637420"></a>[分布式执行MapReduce](#kv6u-1716231603620)

<a name="619k-1740363637422"></a>[即在不同服务器上执行mapper reduce 的task。](#wy7r-1720877483243)

<a name="xw6k-1740363637424"></a>[MapReduce工作流](#d0qe-1716231619319)

<a name="elyc-1740363637426"></a>[workflow。一系列命令，输出写入临时文件，下一个命令从临时文件中读取-物化中间状态](#rvme-1720877910897)

<a name="rjzq-1740363637428"></a>[Reduce端连接与分组](#pyoc-1716228643855)

<a name="sbpl-1740363637430"></a>[用户活动事件](#1pza-1716231634942)

<a name="mrmj-1740363637432"></a>[左侧是事件日志/活动事件activity events/点击流事件clickstream evnets](#4l72-1720878002631)

<a name="gpqy-1740363637434"></a>[右侧是用户数据库](#hivt-1720878131008)

<a name="n5xk-1740363637436"></a>[用户行为日志与用户档案的连接](#cvii-1720878237531)

<a name="tls5-1740363637438"></a>[原始:逐个遍历活动事件关联查询。缺点：吞吐量受限数据库服务器且容易压垮](#eiqe-1720878248508)

<a name="sloc-1740363637440"></a>[改良：获取用户数据库副本（ETL进程从数据库备份中提取数据，参考数仓），放在同一个分布式文件系统中。将用户数据库存储HDFS中的一组文件中，用户活动记录存储另一组文件中，](#iueg-1720878322010)

<a name="2aok-1740363637442"></a>[并能用MapReduce将左右相关记录集中到同一个地方进行高效处理。](#ruua-1720878498786)

<a name="tzlo-1740363637444"></a>[排序合并连接](#fihy-1716231663765)

<a name="5o6g-1740363637446"></a>[1.map提取键值(userid-url  usrid-do)和reduce(userid all url do)](#q51q-1720947527716)

<a name="wx8b-1740363637448"></a>[2.二次排序secondary sort ：对1的合并按时间戳排序](#4kvv-1720947648039)

<a name="nkua-1740363637450"></a>[排序合并连接sort-merge join: reduce一次处理一个特定用户所有记录，只需将一条用户记录保存在内存中，无需发送网络请求](#j8br-1720947805879)

<a name="u0qa-1740363637452"></a>[把相关数据放在一起](#8vrk-1716231670998)

<a name="fzne-1740363637454"></a>[Mapper和排序过程确保特定用户id连接操作的必须数据都放在同一个地方](#t1tc-1720947947656)

<a name="u4y6-1740363637456"></a>[GROUP BY](#9j4s-1716228658160)

<a name="rood-1740363637458"></a>[除了连接之外，“把相关数据放在一起”的常见模式是记录分组。SQL中的Group By](#a6wg-1720952083180)

<a name="3xj8-1740363637460"></a>[处理倾斜](#qa24-1716231688547)

<a name="ajx6-1740363637462"></a>[名流热点数据hot spot](#f55j-1720952155251)

<a name="9jlw-1740363637464"></a>[参考负载倾斜和消除热点](#julg-1720952222343)

<a name="0mv8-1740363637466"></a>[Mapper将热键的关联记录随机发送到几个Reduce之一](#akfb-1720952286891)

<a name="8oue-1740363637468"></a>[Map端连接](#2tox-1716228671225)

<a name="8wod-1740363637470"></a>[预处理输入数据](#qiil-1720971178915)

<a name="xioj-1740363637472"></a>[广播散列连接](#wjhj-1716231713037)

<a name="oogm-1740363637474"></a>[broadcast hash join](#k3se-1720971260954)

<a name="6l3p-1740363637476"></a>[分区散列连接](#su27-1716231723170)

<a name="afu9-1740363637478"></a>[Map桶端连接bucketd map jons](#5h9a-1720971514797)

<a name="lcui-1740363637480"></a>[Map端合并连接](#ftdq-1716231736611)

<a name="ndcf-1740363637482"></a>[MapReduce工作流与Map端连接](#yrmc-1716231744413)

<a name="rvhc-1740363637484"></a>[批处理工作流的输入](#zzir-1716228678980)

<a name="lkvq-1740363637486"></a>[OLTP ：查找少量记录，使用索引，呈现给用户](#hiqn-1720971586510)

<a name="jwho-1740363637488"></a>[OLAP：扫描大量记录，执行分组与聚合，输出有着报告的形式，商业决策的分析。](#cqba-1720971612883)

<a name="jyoy-1740363637490"></a>[建立搜索索引](#bwjf-1716231761454)

<a name="tpsi-1740363637492"></a>[MapReduce最初作为google搜索引擎的索引](#lypn-1720971694941)

<a name="5l2v-1740363637494"></a>[全文搜索和模糊索引  Lucene](#iijq-1720971776882)

<a name="a157-1740363637496"></a>[分区和二级索引](#vcun-1720971828838)

<a name="dpvq-1740363637498"></a>[键值存储作为批处理输入](#8fix-1716231782091)

<a name="g6hl-1740363637500"></a>[批处理输入的哲学](#audd-1716231802005)

<a name="lyhv-1740363637502"></a>[视为不可变且避免副作用：](#6i34-1720972317458)

<a name="1faf-1740363637504"></a>[人类容错human fault tolerance](#zciu-1720972319614)

<a name="cxbu-1740363637506"></a>[最小化不可逆性mininizing irreversibility](#oolm-1720972319615)

<a name="ncdg-1740363637508"></a>[Hadoop与分布式数据库的对比](#lp33-1716228684462)

<a name="wpq9-1740363637510"></a>[Hadoop 像Unix的分布式版本，HDFS是它的文件系统，而MapReduce是Unix进程的怪异实现](#g0vj-1720972341966)

<a name="q2xt-1740363637512"></a>[MapReduce论文发表前，并行连接算法已在数据库实现-大规模并行处理MPP massively parallel processing ](#gjbt-1720972427948)

<a name="kqxg-1740363637514"></a>[Gamma database machine, Teradata, Tandem NonStop SQL](#go7m-1720972523351)

<a name="hy4j-1740363637516"></a>[区别：MMP专注一组及骑行并行执行分析SQL 查询](#5mnr-1720972551600)

<a name="jasw-1740363637518"></a>[MapReduce和分布式文件系统的组合是一个可以运行任意程序的通用操作系统](#gx7b-1720972580058)

<a name="1pls-1740363637520"></a>[存储多样性](#eebl-1716231817367)

<a name="bcxr-1740363637522"></a>[数据湖data lake / 企业数据中心enterprise data hub](#5lga-1720972673599)

<a name="afg0-1740363637524"></a>[Hadoop 常用于实现数仓ETL Extract, Transform, Load](#jrhw-1720972777529)

<a name="hns8-1740363637526"></a>[处理模型多样](#ysfv-1716231826972)

<a name="k9o4-1740363637528"></a>[针对频繁故障设计](#kwz4-1716231831752)

<a name="02gh-1740363637530"></a>[MapReduce之后](#p0zx-1716228568687)

<a name="8hyl-1740363637532"></a>[建立在MapReduce上的高级编程模型](#wcyn-1721117329960)

<a name="2wm2-1740363637534"></a>[Pig，Hive, Cascading, Crunch](#l9ug-1721117359714)

<a name="tyno-1740363637536"></a>[流处理：加速批处理的另一种方法](#bz2s-1721117576614)

<a name="rysf-1740363637538"></a>[物化中间状态](#fvak-1716228706372)

<a name="hyqg-1740363637540"></a>[中间状态intermediate state](#npb7-1721117756510)

<a name="zxon-1740363637542"></a>[物化materialization:中间态写入文件的过程](#0rlu-1721117876651)

<a name="rtnr-1740363637544"></a>[MapReduce完全物化中间态的方法不足：](#fnqf-1721117967688)

<a name="zyem-1740363637546"></a>[只有在前驱作业生成其输入完成时才能启动](#pood-1721117984973)

<a name="q3xi-1740363637548"></a>[mapper通常是多余的：仅仅读取由Reducer写入的同样文件](#iljf-1721118032959)

<a name="y61t-1740363637550"></a>[临时文件（数据）被复制到多个节点](#tghz-1721118071785)

<a name="bupe-1740363637552"></a>[解决：数据流引擎](#aer2-1721118148615)

<a name="c60f-1740363637554"></a>[数据流引擎](#sdac-1716231877023)

<a name="m7ex-1740363637556"></a>[分布式批处理新引擎：](#4gu5-1721118111495)

<a name="rzny-1740363637558"></a>[spark,  Flink: 独立的网络通信层，调度器，用户向API](#nfnv-1721118162692)

<a name="c6hc-1740363637560"></a>[Tez : 薄库，依赖YARN shuffle服务实现节点间的数据复制](#0kbz-1721123564974)

<a name="kfsh-1740363637562"></a>[dataflow engines模型:](#jojo-1721118227522)

<a name="6tq7-1740363637564"></a>[函数/算子operators: 一个算子的输出连接到另一个算子的输入](#kstp-1721118246090)

<a name="bxbz-1740363637566"></a>[优点：](#zbrh-1721118327524)

<a name="grlf-1740363637568"></a>[排序等昂贵工作只需在实际需要地方执行，不是默认在Map和Reduce阶段间](#8oqo-1721118330975)

<a name="jzce-1740363637570"></a>[没有不必要的Map任务](#amzf-1721118375240)

<a name="irer-1740363637572"></a>[连接和数据依赖都是显示声明的](#bunw-1721118382779)

<a name="iaks-1740363637574"></a>[算子中间态足以保存内存或写入本地磁盘，比HDFS需要更少I/O](#bzui-1721122836028)

<a name="xsdx-1740363637576"></a>[算子可在输入就绪后立即执行，不许等待前驱完成](#ka7f-1721123164712)

<a name="gdnp-1740363637578"></a>[MapReduce为每个任务启动新JVM, 而df enginer可重用现有JVM，减少启动开销](#rmr3-1721123191298)

<a name="mwqm-1740363637580"></a>[执行速度更快](#mp4i-1721123431562)

<a name="5rjs-1740363637582"></a>[使用：](#2cxo-1721123304059)

<a name="zzuv-1740363637584"></a>[算子是Map和Reduce的泛化/抽象，相同处理代码可在任意引擎上运行](#vyfa-1721123442398)

<a name="qe74-1740363637586"></a>[Pig Hive Casacding中实现的工作流无需修改代码，修改配置，从MapReduce切换到Tez 或spark.](#qxck-1721123483308)

<a name="2jcp-1740363637588"></a>[容错](#glfr-1716231882229)

<a name="woeo-1740363637590"></a>[重启，算子重新计算](#neqa-1721499456929)

<a name="nf5q-1740363637592"></a>[关于物化的讨论](#npsg-1716231884238)

<a name="gbjo-1740363637594"></a>[图与迭代处理](#dvkh-1716228727874)

<a name="tci4-1740363637596"></a>[图数据模型常用于机器学习应用](#y476-1721499725472)

<a name="wvmd-1740363637598"></a>[图形算法PageRank:根据连接到某个网页的其他网页来估计该网页的流行度](#ld62-1721499760165)

<a name="pzyi-1740363637600"></a>[闭包传递transitive clousure: 重复跟进标明地点归属关系的边，生成数据库中北美地点列表](#et5r-1721499798288)

<a name="9z2u-1740363637602"></a>[MapReduce低效：没考虑算法迭代性](#x4m1-1721499995671)

<a name="6yzj-1740363637604"></a>[Pregel处理模型](#lf5y-1716231892007)

<a name="dveo-1740363637606"></a>[图批处理的优化：批量同步并行（BSP）计算模型。](#1faf-1721499959178)

<a name="ebwy-1740363637608"></a>[Pregel模型：Google的Pregel论文推广了处理图的方法。Apache Giraph , Spark GraphX API 和 Flink Gelly API](#3mh8-1721500149918)

<a name="n5yx-1740363637610"></a>[容错](#pxnd-1716231909468)

<a name="9b6k-1740363637613"></a>[并行执行](#v8gr-1716231912877)

<a name="oapa-1740363637615"></a>[高级API和语言](#cxqk-1716228736349)

<a name="z3zy-1740363637617"></a>[Hive,pig, Cascading,Crunch等高级语言和API, Tez](#qlnr-1721841646688)

<a name="sqlc-1740363637619"></a>[向声明式查询语言的转变](#dfa6-1716231923208)

<a name="vhby-1740363637621"></a>[声明式declarative](#zman-1721841903902)

<a name="zgzz-1740363637623"></a>[与SQL的完全声明式查询有很大的区别：](#inea-1721841971310)

<a name="47si-1740363637625"></a>[围绕回调函数的概念建立，自由调用任意代码来决定输出什么。](#ahki-1721842021736)

<a name="gjex-1740363637627"></a>[可基于大量已有库的生态系统创作： 解析、自然语言分析，图像分析以及运算数值算法或统计算法等。](#bdyf-1721842047384)

<a name="7c3q-1740363637629"></a>[专业化的不同领域](#m2pu-1716231937991)

<a name="g3of-1740363637631"></a>[空间算法：最近邻搜索K-nearest neghbors](#wpot-1721842227412)

<a name="7doj-1740363637633"></a>[11.流处理](#iwmv-1721931597264)

<a name="oweq-1740363637635"></a>[流处理Stream processing: 当事件发生时就可以立即处理](#yeid-1722103475505)

<a name="pzfz-1740363637637"></a>[传递事件流](#08iq-1721844360659)

<a name="qmre-1740363637639"></a>[事件event：流处理的上下文件记录](#n0th-1722103658739)

<a name="ycop-1740363637641"></a>[生产者producer/发布者publisher/发送者sender](#titb-1722103707652)

<a name="rqiw-1740363637643"></a>[消费者consumer/订阅者subscribers/接收者recipients](#yhbb-1722103745716)

<a name="kord-1740363637645"></a>[主题topic/流stream：相关事件的聚合](#jdqp-1722103794393)

<a name="dnln-1740363637647"></a>[通知机制：数据库触发器trigger(算是弥补机制)、消息传递系统messaging system](#2buw-1722103875913)

<a name="zhkk-1740363637649"></a>[消息系统](#ipga-1721932434160)

<a name="uz67-1740363637651"></a>[两个关键问题：](#qm3o-1722104029796)

<a name="biln-1740363637653"></a>[1.生产者快于消费者：丢掉消息/将消息放入缓冲队列/背压backpressure(流量控制flow control) 阻塞生产者，以免其发送更多消息](#sztq-1722104046748)

<a name="j0tf-1740363637655"></a>[2.节点崩溃或脱机，是否有消息丢失： 持久性，高吞吐和低延迟则接收丢失](#5ycq-1722104289674)

<a name="pjze-1740363637657"></a>[直接从生产者传递给消费者](#cj2t-1721932544748)

<a name="rgog-1740363637659"></a>[直接网络通信，而不通过中间节点：](#hjhp-1722104612024)

<a name="gfmi-1740363637661"></a>[UPD组播，金融行业，低延时，不可靠，应用层协议可恢复丢失的包（生产者必须记住发送的包，按需重新发送）](#0ggy-1722104631748)

<a name="bf2d-1740363637663"></a>[无代理的消息库，ZeroMQ、nanomsg, TCP或IP多播](#hnj8-1722104735615)

<a name="vybu-1740363637665"></a>[StatsD 和 Brubeck 使用UDP](#pcd7-1722104800545)

<a name="hsyu-1740363637667"></a>[消费者在网络上公开了服务，生产者可以直接发送HTTP和RPC请求将消息推送给使用者webhooks.](#3se2-1722104863261)

<a name="aiku-1740363637669"></a>[消息代理](#jwkh-1721932555905)

<a name="2op5-1740363637671"></a>[消息代理message broker(也称为消息队列message queue)](#dtlb-1722106424439)

<a name="jw57-1740363637673"></a>[消息代理与数据库对比](#fyus-1721932559957)

<a name="uydg-1740363637675"></a>[.数据存储：数据库保留数据直至显示删除；大多数消息代理在消息成功传递给消费者时地总删除](#aj3x-1722106519844)

<a name="8xpx-1740363637677"></a>[.删除消息快，所以队列可以很短。如过缓冲很多消息可能会溢出到磁盘，吞吐量会下降](#pkoh-1722106591225)

<a name="yp4n-1740363637679"></a>[.匹配方式：数据库通常支持二级索引和各种搜索数据的方式；消息代理按照模式匹配订阅子集](#lfst-1722106688956)

<a name="w4ce-1740363637681"></a>[.最新数据：数据库通常支持事务，基于某个时间点数据快照；消息代理不支持任意查询，有新消息会通知客户端](#q13l-1722106755764)

<a name="0fdc-1740363637683"></a>[多个消费者](#v0lh-1721932568637)

<a name="woju-1740363637685"></a>[负载均衡load balance: 多个客户端从同一个队列中消费。JMS中称为共享订阅shared subscripiton](#enlv-1722191268259)

<a name="yt3b-1740363637687"></a>[扇出fan-out:将每条消息传递给多个消费者](#bjqd-1722191397355)

<a name="wctb-1740363637689"></a>[确认与重新交付](#aoas-1721932573289)

<a name="5fqb-1740363637691"></a>[消息代理使用确认acknowlegements:客户端需显示告知代理消息处理完毕的时间，代理将消息从队列中移除。](#8lsc-1723155930519)

<a name="2nis-1740363637693"></a>[确认丢失：需一种原子提交协议才能处理，如分布式事务。](#w6ac-1723156157534)

<a name="cjmj-1740363637695"></a>[负载均衡与重传的组合不可避免导致消息顺序(JMS，AMQP标准要求保留消息的顺序。)重新排序](#zlnz-1723156224601)

<a name="zwkn-1740363637697"></a>[解决：每个消费者使用单独的队列-即不适用负载均衡功能](#fovj-1725028626326)

<a name="f73j-1740363637699"></a>[消息完全独立，消息重排序并不是个问题，消息之间存在因果依赖关系则是个重要问题](#3kzh-1725028667923)

<a name="xmj3-1740363637701"></a>[分区日志](#9bmj-1721932438668)

<a name="zn4e-1740363637703"></a>[消息传递/不留痕迹：网络数据包 和 消息代理 (可抓包和日志持久)](#xree-1725028818863)

<a name="edgc-1740363637705"></a>[持久化：数据库和文件系统，显式删除前将永久记录](#sbbo-1725028858585)

<a name="grso-1740363637707"></a>[消息代理log-base message brokers: 既有数据库的持久化，又有消息传递的低延迟通知。](#n6lq-1725028981222)

<a name="4hmd-1740363637709"></a>[使用日志进行消息存储](#keft-1721932590686)

<a name="x67g-1740363637711"></a>[生产者通过将消息追加到日志末尾来发送消息，消费者通过以此读取日志来接收消息。](#tlnm-1725029031868)

<a name="x1ji-1740363637713"></a>[Unix tail -f 监视文件被追加写入的数据就是这样工作的。](#1606-1725029123561)

<a name="jmow-1740363637715"></a>[Apache Kafka, Amazon Kinesis Streams , Twitter DistributedLog都是基于日志的消息代理](#aq8x-1725029525384)

<a name="gs09-1740363637717"></a>[Google Cloud Pub/Sub在架构上类似，单对外暴露的是JMS风格的API，而不是日志抽象](#0wz5-1725029598472)

<a name="xp8c-1740363637719"></a>[尽管写入磁盘，但通过跨多台机器分区，每秒能实现数百万消息的吞吐量，并通过复制来实现容错性。](#zqkl-1725029648581)

<a name="laug-1740363637721"></a>[日志与传统消息相比](#pr6y-1721932607757)

<a name="smjp-1740363637723"></a>[天然支持扇出式消息传递：过个消费者独立读取日志，而不相互影响](#i3q5-1725115574888)

<a name="pefx-1740363637725"></a>[负载平衡：读取消息不会从日志中删除，代理可以将整个分区分配给消费者组中的节点，而不是单挑消息分配给客户端。](#ymqj-1725115609372)

<a name="c9nq-1740363637727"></a>[消费者偏移量](#o0ft-1721932621047)

<a name="8pbw-1740363637729"></a>[和单领导者数据库复制中常见的日志序列号非常相似，代理无需跟踪每条消息，只需定期记录消费者偏移即可。有助于提高基于日志的系统吞吐量](#emow-1725115793168)

<a name="vocf-1740363637731"></a>[问题：消费者节点失效而没有记录偏移量，重启后这些消息将被处理两次。本章后续讨论。](#gmal-1725115911246)

<a name="fi5d-1740363637733"></a>[磁盘空间使用](#ipmx-1721932629330)

<a name="e7bz-1740363637735"></a>[只追加写入日志，回收时将旧段删除或移动到归档存储](#5ep6-1725115987947)

<a name="hvnh-1740363637737"></a>[问题，消费者跟不上生产者，指向删除段，错过一些消息。](#kjgm-1725116313754)

<a name="coaz-1740363637739"></a>[日志实现一个有限大小的缓冲区：循环缓冲区circular buffer/环形缓冲区，填满时将丢弃旧消息](#k3hi-1725116359622)

<a name="pu0k-1740363637741"></a>[设 大型硬盘容量为 6TB, 顺序写入为150MB/s， 最快需要约11小时填满磁盘，之后开始覆盖旧消息。实践中的部署很少能用满磁盘的写入带宽。所以通常可保留一个几天甚至几周的日志缓冲区](#jjma-1725116440115)

<a name="opbg-1740363637743"></a>[以上保留多长时间的消息，日志吞吐量或多或少保持不变，因为每个消息都写入磁盘。](#bdoa-1725116521841)

<a name="ay3n-1740363637745"></a>[   而默认将消息保存在内存中，当队列很短，系统很快；当系统开始写入磁盘，就慢得多，所以吞吐量取决于保留的历史数量。](#rxx7-1725116637183)

<a name="ztqg-1740363637747"></a>[当消费者更不上生产者时](#91b6-1721932634947)

<a name="2qee-1740363637749"></a>[3种选择：丢弃信息、进行缓冲或施加背压](#dztq-1725116764093)

<a name="wkuc-1740363637751"></a>[巨大运维优势：丢失消息仅影响当前消费者，不会中断其它消费者，可进行调试测试，不必中断生产服务。](#mgyh-1726767519795)

<a name="imgb-1740363637753"></a>[重播旧信息](#6tnb-1721932645175)

<a name="ji7l-1740363637755"></a>[删除消息：AMQP和JMS消息代理](#yygs-1726767645074)

<a name="w0th-1740363637757"></a>[只读操作：基于日志的代理。](#u81b-1726767864887)

<a name="oklr-1740363637759"></a>[更像上一章节的批处理。允许更多的实验操作，通过偏移量重播。](#opy5-1726767877078)

<a name="sfoc-1740363637761"></a>[流与数据库](#rnwj-1721932350699)

<a name="qmj0-1740363637763"></a>[保持系统同步](#ehyq-1721932450135)

<a name="4sv8-1740363637765"></a>[变更数据捕获](#1ako-1721932460819)

<a name="q3ec-1740363637767"></a>[变更数据捕获的实现](#xkpl-1721932670593)

<a name="ybjk-1740363637769"></a>[初始快照](#uxpn-1721932683846)

<a name="jpxy-1740363637771"></a>[日志压缩](#j0w6-1721932690312)

<a name="6awh-1740363637773"></a>[变更流的API支持](#5pqr-1721932694290)

<a name="yftp-1740363637775"></a>[事件溯源](#qkmx-1721932472062)

<a name="nsti-1740363637777"></a>[从时间日志中派生出当前状态](#vydq-1721932714045)

<a name="lgvo-1740363637779"></a>[命令和事件](#xbwr-1721932732154)

<a name="f638-1740363637781"></a>[状态，流和不变形](#k3v8-1721932742549)

<a name="nk3b-1740363637783"></a>[从同一事件日志中派生多个视图](#diql-1721932751200)

<a name="lcza-1740363637785"></a>[并发控制](#tzcl-1721932772042)

<a name="ts79-1740363637787"></a>[不变性的限制](#urmz-1721932775107)

<a name="osrm-1740363637789"></a>[流处理](#nbcs-1721932419014)

<a name="jfil-1740363637791"></a>[流处理的应用](#jf4x-1721932507881)

<a name="rrqg-1740363637793"></a>[复合时间处理](#80rp-1721932792357)

<a name="rlrt-1740363637795"></a>[流分析](#6jjt-1721932799443)

<a name="spmg-1740363637797"></a>[维护物化视图](#5iog-1721932801692)

<a name="lva1-1740363637799"></a>[在流上搜索](#0asi-1721932807278)

<a name="0wkh-1740363637801"></a>[消息传递和RPC](#10bm-1721932817553)

<a name="wjml-1740363637803"></a>[时间推理](#oca5-1721932519502)

<a name="6jah-1740363637805"></a>[事件时间和处理时间](#is6l-1721932844579)

<a name="zhfm-1740363637807"></a>[知道什么时候准备好](#aue5-1721932851975)

<a name="c71u-1740363637809"></a>[你用的是谁的时钟](#vsi1-1721932859473)

<a name="ftv1-1740363637811"></a>[窗口的类型](#gryf-1721932868260)

<a name="x3k1-1740363637813"></a>[流式连接](#jbet-1721932523864)

<a name="m1eg-1740363637815"></a>[流流连接(窗口连接)](#eaux-1721932880085)

<a name="unxi-1740363637817"></a>[流表连接(流扩展)](#hixz-1721932915139)

<a name="hyxb-1740363637819"></a>[表表连接(维护物化视图)](#zbsv-1721932945841)

<a name="0jlx-1740363637821"></a>[连接的时间依赖性](#xqtb-1721932962310)

<a name="pdkq-1740363637823"></a>[容错](#v1om-1721932530009)

<a name="5xsk-1740363637825"></a>[微批量与存档点](#pqfe-1721932996846)

<a name="yxzq-1740363637827"></a>[原子提交再现](#elio-1721933013244)

<a name="6tlw-1740363637829"></a>[幂等性](#bwyd-1721933023622)

<a name="ak2w-1740363637831"></a>[失败后重建状态](#dijm-1721933026909)

<a name="tgfo-1740363637833"></a>[12. 数据系统的未来](#vrhs-1739552413424)

<a name="y2pk-1740363637835"></a>[数据集成](#ede5-1739555478378)

<a name="1a0d-1740363637837"></a>[组合使用衍生数据的工具](#72md-1739555630486)

<a name="rpdq-1740363637839"></a>[理解流数据](#ws0u-1739555668111)

<a name="7dqq-1740363637841"></a>[衍生数据与分布式事务](#zqyv-1739555677949)

<a name="f4ik-1740363637843"></a>[全局有序的限制](#sdr6-1739555687850)

<a name="7qub-1740363637845"></a>[排序事件以捕捉因果关系](#zk4p-1739555695102)

<a name="3o1w-1740363637847"></a>[批处理与流处理](#niva-1739555642700)

<a name="wx41-1740363637849"></a>[维护衍生状态](#r4mh-1739555731398)

<a name="1wqr-1740363637851"></a>[应用演化后重新处理数据](#dx0m-1739555748166)

<a name="gt1q-1740363637853"></a>[Lambda架构](#2vm7-1739555772929)

<a name="haam-1740363637855"></a>[统一批处理和流处理](#6flf-1739555780198)

<a name="u04k-1740363637857"></a>[分拆数据库](#10z2-1739555560574)

<a name="aw6h-1740363637859"></a>[组合使用数据存储技术](#8wfw-1739555819342)

<a name="4yhs-1740363637861"></a>[创建索引](#havr-1739555874428)

<a name="mdp3-1740363637863"></a>[一切的元数据库](#ep2e-1739555885454)

<a name="qjmw-1740363637865"></a>[开展分拆工作](#am3j-1739555961678)

<a name="iu9f-1740363637867"></a>[分拆系统和集系统](#trtv-1739555969624)

<a name="fk3n-1740363637869"></a>[少了什么？](#lcy6-1739555980725)

<a name="7dcr-1740363637871"></a>[围绕数据流设计应用](#97j6-1739555836550)

<a name="avlb-1740363637873"></a>[应用代码所谓衍生函数](#gyfk-1739555997047)

<a name="lsbx-1740363637875"></a>[应用代码的状态和分离](#2njs-1739556023517)

<a name="vvhr-1740363637877"></a>[数据流：应用代码与状态变化的交互](#pgmn-1739556032065)

<a name="wspn-1740363637879"></a>[流处理器和服务](#fyub-1739556046567)

<a name="s74a-1740363637881"></a>[观察衍生数据状态](#dmmo-1739555844651)

<a name="1xbl-1740363637883"></a>[物化视图和缓存](#48oq-1739556059722)

<a name="ool0-1740363637885"></a>[有状态，可离线的客户端](#srii-1739556068892)

<a name="sgjy-1740363637887"></a>[将状态变更推送给客户端](#zdkz-1739556083230)

<a name="mqhz-1740363637889"></a>[端到端的事件流](#70bj-1739556096239)

<a name="0d77-1740363637891"></a>[读也是事件](#k9nk-1739556109784)

<a name="ttdx-1740363637893"></a>[多分区处理数据](#rknv-1739556117246)

<a name="sddy-1740363637895"></a>[将事情做正确](#ydeg-1739555534326)

<a name="pw3x-1740363637897"></a>[为数据库使用端到端的参数](#bool-1739556139461)

<a name="7ewo-1740363637899"></a>[正好执行一次操作](#utq9-1739556271989)

<a name="7vmt-1740363637901"></a>[抑制重复](#mxfy-1739556285089)

<a name="et4w-1740363637903"></a>[操作标识符](#9kug-1739556293281)

<a name="qe9r-1740363637905"></a>[在数据系统中应用端到端的思考](#dc4e-1739556300938)

<a name="xzgn-1740363637907"></a>[强制约束](#cai0-1739556155120)

<a name="ijll-1740363637909"></a>[唯一性的约束要达成共识](#jeqp-1739556425758)

<a name="nsc8-1740363637911"></a>[基于日志消息传递中的唯一性](#lcq0-1739556436827)

<a name="qfmd-1740363637913"></a>[多分区请求处理](#dk4a-1739556687945)

<a name="mx0s-1740363637915"></a>[及时性与完整性](#dbka-1739556159893)

<a name="thsj-1740363637917"></a>[数据流系统的正确性](#bmr3-1739556705098)

<a name="opjp-1740363637919"></a>[宽松地解释约束](#loih-1739556715504)

<a name="xsxq-1740363637921"></a>[无协调数据系统](#v94l-1739556733932)

<a name="jayc-1740363637923"></a>[信任但验证](#boru-1739556172269)

<a name="e2gr-1740363637925"></a>[维护完整性，尽管软件有bug](#zgrh-1739556749129)

<a name="ysae-1740363637927"></a>[不要盲目信任任何承诺](#irhz-1739556777111)

<a name="rucw-1740363637929"></a>[验证的文化](#1d8z-1739556789067)

<a name="ptwd-1740363637931"></a>[为可审计性而设计](#61de-1739556792067)

<a name="b2qu-1740363637933"></a>[端到端原则重现](#guck-1739556800394)

<a name="61yt-1740363637935"></a>[利用可审计数据系统的工具](#tjmv-1739556812856)

<a name="8jgn-1740363637937"></a>[做正确的事情](#dizf-1739555546308)

<a name="qzmc-1740363637939"></a>[预测性分析](#va2h-1739556847417)

<a name="l8qk-1740363637941"></a>[偏见与分析](#c1wq-1739556910451)

<a name="5q9q-1740363637943"></a>[责任与问责](#ijng-1739556917694)

<a name="zm2v-1740363637945"></a>[反馈循环](#thso-1739556928624)

<a name="qmwz-1740363637947"></a>[隐私和追踪](#gt9r-1739556854431)

<a name="09dw-1740363637949"></a>[监视](#qol8-1739556939696)

<a name="tvyq-1740363637951"></a>[同意与选择的自由](#zgzn-1739556948482)

<a name="ys5x-1740363637953"></a>[隐私和数据使用](#ewvo-1739557089382)

<a name="k02b-1740363637955"></a>[数据资产与权力](#vlsj-1739557096182)

<a name="dlt0-1740363637957"></a>[记着工业革命](#muzc-1739557108489)

<a name="l7fr-1740363637959"></a>[立法与法律](#7mjx-1739557115858)

<a name="sgc6-1740363637961"></a>[本章小结](#hmh3-1739556886643)



<a name="jeyl-1677787446995"></a><a name="nm5q-1706969255961"></a>**===数据密集型应用===**

<a name="ef5t-1644230945318"></a>数据系统基础

<a name="d3cb-1739990087327"></a>**序言**

<a name="j9wq-1739990271690"></a>**NOSQL!大数据!Web-Scale!分片!最终一致性!ACID! CAP定理!云服务!MapReduce!实时!**

<a name="wlxm-1739990097545"></a><a name="unbe-1677787447006"></a>**第一部分 数据系统的基石**

<a name="kwfx-1677787447007"></a>**1.可靠性、可拓展性、可维护性能**

<a name="zrzj-1642646974315"></a>**小结：一个应用必须满足各种需求才称得上有用**

<a name="lykw-1644227240038"></a>**-功能性需求：CRUD**

<a name="b2tu-1644227249556"></a>**-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性**

.数据密集型 data intensive -cpu 很少成为此类应用的瓶颈

.计算密集型 compute intensive  

<a name="kvjx-1708356889532"></a>.database   、cache 、 search indexes 、stream processing 、 batch processing

<a name="qqm5-1644227303238"></a>**.可靠性(即使发生故障，系统也能正常工作)**

<a name="mk9e-1644227360160"></a>**故障可能发生在硬件（通常是随机和不相关的）**

<a name="w7by-1644227387308"></a>**软件（通常是系统性的bug,很难处理）**

<a name="dozl-1644227415061"></a>**人类（不可避免的时不时出错）**

<a name="fvz4-1644227444254"></a>**容错技术可以对终端用户隐藏某些类型的故障。**

<a name="7xms-1644228225080"></a>**硬件故障**

<a name="3gfd-1708357730326"></a>**硬盘的平均无故障时间mean time to failure 约为10~50年**

<a name="yusj-1708357802977"></a>**aws设计优先考虑灵活性flexibility 和 弹性 elasticity,而非单机可靠性，所以虚拟机实例不可用却无任何告警**

<a name="dfpv-1708357497902"></a>**软件错误**

<a name="ptxr-1708357908223"></a>**系统性错误** 

<a name="ybic-1708358007856"></a>**测量监控系统行为，运行时不断自检，出现差异desrepancy时报警**

<a name="drpl-1708357507365"></a>**人为错误(如何让系统变得可靠)**

<a name="eb1v-1708358093033"></a>**既然人类不可靠，如何让系统变得可靠：**

<a name="i4we-1708358144376"></a>**。最小化犯错机会的方式设计系统,  但如果限制太多，人们可能会忽略它们的好处而绕开，很难把握其中微妙的平衡**

<a name="xzfa-1708358243121"></a>**。在易错地方和可能导致失效的地方解耦decouple,提供非生产环境沙箱sandbox-虚拟化环境，隔离真实系统进行安全测试**

<a name="9jaa-1708358634289"></a>**。彻底的测试，单元测试，集成测试，手动测试，自动化测试覆盖边缘场景corner case.**

<a name="zlp4-1708358698137"></a>**。滚动发布，快速回滚**

<a name="40us-1708358954660"></a>**。配置详细和明确的监控**

<a name="o66x-1708358967000"></a>**。良好的管理和充分的培训。一个复杂而重要的方面，但超出本书的范围**

<a name="x7co-1708357515795"></a>**可靠性有多重要**

<a name="nc0w-1708358745350"></a>**造成客户巨大损失-阿里云宕机造成的用户损失**

<a name="qopp-1708358856827"></a>**家长将孩子照片存储在你的应用里，数据库损坏，客户有何体验，他们可能会知道如何从备份恢复吗？**

<a name="uzlx-1708358804665"></a><a name="dsae-1708357483848"></a>**.可扩展性(即使在增加负载的情况下也能保持性能的策略)**

<a name="gqfn-1644228379215"></a>**定量描述负载和性能的方法。**

<a name="krij-1644228405843"></a>**推特主页时间线，介绍描述负载参数，并将响应时间百分点作为衡量性能的一种方式。头部阻塞、尾部延迟。**

<a name="unxv-1739960162350"></a>**(有很多人通过将工作负载迁移到低延迟、自适应的GC来控制尾部延迟-infoQ java趋势)**

<a name="bynr-1644228470161"></a>**在可扩展的系统中可以添加处理容量 以在高负载下保持可靠。**

<a name="eg4z-1708359118801"></a>**服务降级degradation的一个常见原因是负载的增加。**

<a name="qd5r-1739959711621"></a>**可拓展性Scalability是用来描述系统应对负载增长能力的术语。scalability: 可扩展性；可伸缩性；可量测性**

<a name="dgno-1739959800409"></a>☐ **PS:scale  n.规模,刻度，大小     健合架构师说开关增减功能是可扩展性LOL**

<a name="vja4-1708356470840"></a>**描述负载(tps-推特主页时间线扇出-查询性能优化)**

负载参数load parameters

推特2012年11月发布的数据，主要两个业务：

发布推文：

`    `用户可以向粉丝发布新消息（平均4.6k 请求/秒 ， 峰值超12k 请求/ 秒） TPS

主页时间线：

`    `用户可以查阅他们关注的人发布的推文（300K 请求/秒） 

处理每秒12k次的写入还是很简单的，拓展挑战主要来自扇出（fan-out),请求自己的主页时间线(查看关注的人的推文)。

方法1： 通过正常sql  select user.\*, tweets.\* form tweets join user join follows  查找关注的人推文

方法2： 为每个用户的主页时间线维护一个缓存 -根据时间线缓存用户id和推特id

4\.6k TPS 写入推特 -> 345K tps 写入主页时间线缓存 -> 300K tps查询主页

`    `推特的第一个版本使用了方法1，但系统很难跟上主页时间线查询的负载。所以转向方法2.方法2效果更好，发推频率比查询主页时间线的频率几乎低了两个数量级，这种情况下，最好在写入时做更多的工作，而在读取时做更少的工作。

`    `而方法2的缺点是，发推需要大量的额外工作。平均来说，一条推文会发往约75个关注者，所以每秒4.6k的发推写入，变成对时间线缓存每秒345k的写入。30m的粉丝，意味着一条推文需要3千万次的写入，及时完成是一个巨大挑战，且推特尝试在5秒内向粉丝发送推文(通知)。

<a name="mnug-1708269817280"></a>    推特轶事的最终转折：现在已经稳健的实现了方法2，逐步转向两种方法的混合。大多数用户发的推文会被扇出写入其粉丝主页时间线缓存中，名人则除外。当用户读取主页时间线时，分别获取每位名流的推文，再与用户的主页时间线缓存合并。

<a name="s6un-1708356581594"></a>**描述性能**

<a name="fcez-1708523606684"></a>**吞吐量throughput**

<a name="k30f-1708523620292"></a>**响应时间 response time.**

<a name="bogk-1708523658968"></a>**响应时间的高位百分点（也称为尾部延迟tail latencies**

<a name="uijc-1740357866390"></a>**优化99.99百分位点（一万个请求中最慢的一个-尾部延迟）则认为太昂贵了**

.增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？

.增加负载参数并希望保持性能不变时，需要增加多少的系统资源？

如何描述系统性能：

hadoop这样的批处理系统，通常关心的是吞吐量throughput,即每秒可以处理的记录数量

通常更重要的服务是响应时间 response time. (延迟latency，休眠latent)

算术平均值arithmetic mean ,典型typical ,百分位点percentiles, 中位数median

响应时间的高位百分点（也称为尾部延迟tail latencies）非常重要,直接影响用户服务体验。amazon响应时间要求时以99.9百分位点为准，即使它只影响一千个请求中的一个

优化99.99百分位点（一万个请求中最慢的一个）则认为太昂贵了

当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求-高扇出导致的不可确定性增加

排队延迟queueing delay    头部阻塞head of line blocking     

纵向扩展 scaling up  /垂直扩展vertical  scaling     

横向拓展scaling out   /水平扩展 horiziontal scaling 

<a name="tuzo-1708355786743"></a>无共享 shared-nothing   负载极难预测highly unpredictable of load    无状态服务stateless services

<a name="k1dg-1708355783343"></a>**.可维护性：（代码:设计模式  系统：检测健康性）**

<a name="mwlq-1739809481662"></a>**可操作性：人生苦短，关爱运维。**

<a name="zi2h-1739809499485"></a>**简单性：管理复杂度**

<a name="b64f-1739809505843"></a>**可演化性：拥抱变化**  

<a name="vg1v-1699843968229"></a>**可维护性关于工程师和运维团队生活质量的。**

<a name="mq1x-1644231096441"></a>**良好的抽象降低复杂度，系统易于修改和适应新的应用场景。**

<a name="qj5f-1644228656997"></a>**良好的可操作性对系统的健康状态具有良好的可见性，并拥有有效的管理手段。**

<a name="jufm-1677787447008"></a>**2.数据模型与查询语言**

<a name="moyn-1739958400668"></a>**数据模型是软件开发中最重要的部分，选择一个合适的模型非常重要。**

<a name="glyn-1739958437519"></a>**多数应用是层次结构，如何使用低一层的数据模型表示:**

<a name="itiw-1739958558955"></a>**1.开发人员用对象或数据结构API对现实世界对象进行建模**

<a name="zst8-1739958597323"></a>**2.存储选择：JSON，XML,关系型数据库中表、或图模型**

<a name="ndln-1739958769398"></a>**3.数据库工程师选定内存、磁盘或网络字节来表示存储便于crud处理**

<a name="87e2-1739958841062"></a>**4.硬件工程使用电流，脉冲，磁场等表示字节**

<a name="lynl-1739957541870"></a>**关系模型与文档模型**

<a name="jomv-1739958926076"></a>**70年代提出sql模型，80年代成为首选**

<a name="rcx8-1739958971699"></a>**典型事务处理：销售，银行交易，航司预定，库存管理**

<a name="jsln-1739959008693"></a>**批处理（客户发票，工资单，报告）**

<a name="8vxs-1739957588389"></a>**NoSQL的诞生**

<a name="h5mi-1739989893599"></a>**09年分布式，非关系数据库上的聚会传播NoSQL:**

<a name="i5dd-1739989949590"></a>**比关系数据库更好的可扩展性，大数据集高写入吞吐**

<a name="b0qv-1739989985562"></a>**一些特殊的查询操作**

<a name="cliq-1739989941345"></a>**渴望多动态多表现力的数据模型**

<a name="ciyc-1739957588391"></a>**对象关系不匹配（关系型需要ORM对数据进行转换映射-阻抗不匹配）**

<a name="idg9-1739990650566"></a>**Linkin简历则直接用Json更合适，使树状结构明确，减少阻抗不匹配**

<a name="rdhn-1739957588393"></a>**多对一和多对多的关系**

<a name="l9tl-1739990839589"></a>**特殊名词用ID限定：**

<a name="pr4x-1739990961816"></a>**避免歧义**

<a name="snq7-1739990965115"></a>**易于更新**

<a name="tbxm-1739990983886"></a>**标准化支持**

<a name="7rsr-1739991178955"></a>**linkin多对多关系关联指向**

<a name="ejgi-1739957588395"></a>**文档数据库是否在重蹈覆辙?**

<a name="ftqi-1739957588397"></a>**网络模型**

<a name="l5i7-1739991286971"></a>**遍历记录列和访问路径表**

<a name="jxjx-1739957588399"></a>**关系模型**

<a name="bwbl-1739991317494"></a>**没有复杂路径**

<a name="vlwx-1739991363241"></a>**查询优化器耗费多年研究和开发精力**

<a name="gkyb-1739991402751"></a>**只需构建一次查询优化器，所有应有程序都可以从中受益**

<a name="dgpl-1739957588401"></a>**与文档数据库相比**

<a name="2s88-1739991241151"></a>**外键-文档引用**

<a name="yecy-1739957588403"></a>**关系型数据库与文档数据库在今日的对比**

<a name="3kqq-1739957588405"></a>**哪个数据模型更方便写代码?**

<a name="glnq-1739991500088"></a>**文档数据库：类似文档结构（一对多关系树，一次加载整个树）**

<a name="r37b-1739991571636"></a>**关系型：高度相联数据**

<a name="wjtn-1739991541917"></a>**图数据库：图型模型**

<a name="ablj-1739957588407"></a>**文档模型中的架构灵活性**

<a name="aynf-1739991684573"></a>**无模式schemaless/读时模式schema-on-read**

<a name="dxob-1739991755087"></a>**不同类型对象放在表中不现实**

<a name="tfyl-1739991795457"></a>**数据结构由外部决定，无法控制外部系统且随时变化**

<a name="gre0-1739957588409"></a>**查询的数据局部性**

<a name="fr73-1739991930943"></a>**局部性原理：无需查询多次，所需数据在局部边缘**

<a name="jtgm-1739991998839"></a>**适用于需要文档绝大部分内容的情况**

<a name="oswg-1739957588411"></a>**文档和关系数据库的融合**

<a name="md2f-1739992070998"></a>**除mysql外都已支持xml格式**

<a name="qv8p-1739992118385"></a>**高版本开始支持Json格式**

<a name="hicx-1739957588413"></a>**数据查询语言**

<a name="3nio-1739957588415"></a>**Web上的声明式查询**

<a name="ltru-1739992165789"></a>**简洁容易，隐藏实现细节**

<a name="6fnh-1739992292353"></a>**声明式CSS比JS实现好得多**

<a name="9py6-1739992446867"></a>**声明式SQL比命令式查询API好得多**

<a name="19wu-1739957588417"></a>**MapReduce查询**

<a name="erlv-1739992560815"></a>**比SQL底层，可用于实现SQL查询功能**

<a name="ow5x-1739957588419"></a>**图数据模型**

<a name="p6tp-1739957588421"></a>**属性图**

<a name="xrco-1739957588423"></a>**Cypher查询语言**

<a name="wlr2-1739957588425"></a>**SQL中的图查询**

<a name="cqog-1739957588427"></a>**三元组存储和SPARQL**

<a name="z8sp-1739957588429"></a>**语义网络**

<a name="bqfx-1739957588431"></a>**RDF数据模型**

<a name="rbsb-1739957588433"></a>**SPARQL查询语言**

<a name="u7qx-1739957588435"></a>**基础:Datalog**

<a name="auej-1739957588437"></a>**本章小结：**

<a name="guby-1644404619396"></a>数据模型时一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。以便激起兴趣，更多的了解**最适合你的应用的需求模型**。（数据库选型）

<a name="o6we-1644404838474"></a>在历史上，**数据最开始被表示为一颗大树（层次型结构**），但是这不利于表示多对多的关系，所以发明了

<a name="pgu6-1699844351041"></a>**-关系模型**

<a name="jayo-1699844352979"></a>来解决这个问题。

<a name="kfpd-1644410618294"></a>**-NoSql (es,redis)**

<a name="uzbw-1699844301003"></a>**通常**不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。

<a name="0p23-1644410807294"></a>**1.文档数据库:MongoDB**

<a name="9rlb-1699844336493"></a>数据通常是自我包含的，而且文档之间的关系非常稀少

<a name="09bl-1644410666587"></a>  **2.图形数据库 ：**

<a name="imif-1699844337670"></a>与文档数据库相反的场景-任意事务都可能与任何事务相关联

<a name="6fxw-1644410924417"></a>**-其它模型(基因序列)**

<a name="he0m-1699844309707"></a>** 基因组 通常需要 **序列相似性搜索，意味着一**个很长的字符串，并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法。研究人员编写了想GenBank专门的基因组数据库软件。

<a name="opsf-1644411138194"></a>                 粒子物理学家进行大数据类型的大规模数据分析。粒子对撞机（LHC）这样的项目可以工作在数百亿兆字节的范围内。这样的规模下，需要指定解决方案来阻止硬件成本的失控。

<a name="sm0u-1677787447009"></a>**3.存储与检索**

<a name="eecw-1740153790262"></a>**两大类存储引擎：**

<a name="q4ii-1740155028973"></a>**日志结构：LSM树 - 段  追加**

<a name="0hl1-1740155034913"></a>**面相页面：B树   -  页面  就地更新覆盖**

<a name="wfwi-1740153581649"></a>**驱动数据库的数据结构**

<a name="tv8n-1740155156001"></a>**日志文件：db\_get查找最新值使用 tail -n 1 原因：日志文件末尾追加记录**

<a name="tug5-1740155286426"></a>**高效查找数据：索引**

<a name="p3si-1740155327190"></a>**权衡索引带来开销的利弊**

<a name="rlyu-1740153582091"></a>**哈希索引**

<a name="wwhy-1740155355395"></a>**key  ：byte offset    -key的字节偏移量（检索到对应的key位置）memtable内存表**

<a name="jmo1-1740156066924"></a>**Riak默认存储引擎Bitcask适合每个键经常更新**

<a name="lqhv-1740157192025"></a>**Bitcask压缩键值更新日志，只保留每个键最近值，为什么不用新值覆盖，只能追加设计的原因：**

<a name="fddz-1740156309455"></a>**顺序写入：追加和分段合并时，比随机写入快，基于闪存SSD优选**

<a name="3nar-1740156360507"></a>**并发和崩溃恢复简单：段文件是附加或不可变的，不必担心值覆盖时崩溃回滚丢失旧数据**

<a name="hx0m-1740156507858"></a>**避免数据文件分散：合并旧段避免其随时间分散问题**

<a name="fzjg-1740156686379"></a>**哈希局限性：**

<a name="ir0f-1740156695161"></a>**散列表必须放进内存： 变满增长时昂贵，磁盘哈希映射表现差，大量随机I/O, 且散列冲突需要很多逻辑。**

<a name="4hz0-1740157036066"></a>**范围查询效率不高：如查0~99999，需要单独查每个键**

<a name="fzxl-1740153582093"></a>**SSTables和LSM树**

<a name="rezu-1740157411774"></a>**SSTable-排序字符串表：键值对序列按键排序，优势**

<a name="ufmh-1740157485412"></a>**合并段简单高效，即使文件大于内存。类似归并排序算法**

<a name="bvrd-1740157454667"></a>**不再需要保存内存中所有键的索引，因为有序，可知目标键前后位置**

<a name="0yy6-1740157757279"></a>**节省磁盘空间，减少IO带宽： 写入磁盘前进行压缩，每个条目都指向压缩块开始处**

<a name="cecn-1740225640452"></a>**内存中为有序key : byte offset(MemTable内存表),   每个key是disk每段(SSTable)的头节点。**

<a name="z3in-1740250091207"></a>**PS: Log-Structured Merge Tree 专为写入密集设计：**

<a name="ezl0-1740250352949"></a>**旨在通过将数据分散存储在多个结构中优化写操作性能**

<a name="clsq-1740250357670"></a>**同时批量处理减少磁盘操作成本**

<a name="i5pu-1740153582095"></a>**构建和维护SSTables**

<a name="ygxv-1740164523160"></a>**1.平衡树：写入时，添加到内存中平衡树结构（例如红黑树），也称内存表**

<a name="yry5-1740164572357"></a>**2.入盘：当内存表大于某个阈值（通常几兆), 作为SSTable文件写入磁盘**

<a name="acht-1740164814071"></a>**3.读取：先在内存表中找关键字，然后在最近的磁盘段中**

<a name="jpws-1740164861028"></a>**4.压缩：后台运行合并压缩过程组合段文件覆盖删除旧值**

<a name="9uey-1740164946782"></a>**解决崩溃时内存数据丢失：保存一个单独日志，每个写入立即落盘，用于恢复。**

<a name="atfb-1740153582097"></a>**用SSTables制作LSM树**

<a name="r0ik-1740165041645"></a>**Cassandra, Hbase 受Bigtable影响，引入SSTable 和 memtable内存表**

<a name="j8ta-1740165140730"></a>**LSM存储引擎：基于合并和压缩排序文件原理的存储引擎**

<a name="ms2r-1740165303784"></a>**Lucene和ES、Solr全文搜索使用类似的方法来存储字典：**

<a name="x7ec-1740165389878"></a>**全文索引比键值复杂得多**

<a name="52hb-1740165392571"></a>**分词索引、二级索引**

<a name="gtdu-1740153582099"></a>**性能优化**

<a name="dvbd-1740165554199"></a>**查找不存在的键时：LSM树算法很慢；检查内存表，一直回到最老的，才能确定键不存在**

<a name="i4ew-1740166032050"></a>**解决：Bloom过滤器-近似集合内容的高效数据结构，告诉您数据库中是否出现键，从而节省磁盘读取**

<a name="uku4-1740166095455"></a>**压缩合并策略：规模级别调整-更新和更小的合并到大老的SSTable中，水平则拆分成更小。**

<a name="nogm-1740166206243"></a>**平坦压缩：LevelDB因此得名，RocksDB**

<a name="yrcs-1740166183634"></a>**大小分层：Hbase**

<a name="xbph-1740166243292"></a>**both: Cassandra**

<a name="obce-1740166273567"></a>**LSM树基本思想： 保存一系列在后台合并的SSTables，简单有效**

<a name="dmmn-1740166423949"></a> **即使数据集比内存大得多，仍能正常工作**

<a name="uc4r-1740166514362"></a>**按序存储可高效执行范围查询**

<a name="fc6o-1740166561440"></a>**磁盘写入是连续的，高写入吞吐量**

<a name="jidy-1740153582101"></a>**B树**

<a name="5mho-1740225282678"></a>**1970年提出**

<a name="1wbz-1740225295395"></a>**SSTable   有序  可变大小段（通常为几兆）**

<a name="eoxw-1740225354418"></a>**B树      有序页（通常为4k,innodb 64k/页） 页面树**

<a name="ilpu-1740227362881"></a>**算法分隔页面生长B树，四级树多达256TB**

<a name="tuyj-1740153582103"></a>**让B树更可靠**

<a name="5uig-1740227401618"></a>**崩溃B树产生孤儿页面风险**

<a name="hcsm-1740229623873"></a>**解决：预写式日志WAL ,也称为重做日志redolog，仅追加的文件**

<a name="tbc5-1740229671142"></a>**并发安全，避免多线程访问树数据不一致**

<a name="azii-1740229723964"></a>**解决：并发控制，轻量级锁，锁存器latches**

<a name="wout-1740153582105"></a>**B树优化**

<a name="odav-1740247750938"></a>**.写时复制 代替 WAL ,对并发控制也很有用**

<a name="yhsp-1740247793034"></a>**.节省页面空间，使具有更多键，使得层次/IO更少 ps:B+树**

<a name="itqr-1740247965059"></a>**.使得叶子页面顺序出现在磁盘，树增长后维持困难。LSM合并重写存储更易使顺序键在磁盘上彼此靠近**

<a name="ldlt-1740248368480"></a>**.额外指针指向左右兄弟节点，利于顺序扫描，无需返回父节点**

<a name="i95u-1740248417650"></a>**.借用日志结构思想减少磁盘寻道。如分形树（与分形无关）**

<a name="lerd-1740153582107"></a>**比较B树和LSM树**

<a name="cfuu-1740249099701"></a>**B树：实现更成熟  读取快写入慢**

<a name="ivvw-1740249108704"></a>**LSM树： 写入快读取慢  因为需在压缩阶段检查不同的数据结构和SSTable。**

<a name="q7gb-1740249591162"></a>**ps:但哈希索引O(1)特性一般用作读多写少的缓存LOL，LSM是指检索key，非O(1)通过key获取值**

<a name="7w72-1740153582109"></a>**LSM树的优点**

<a name="c6ai-1740249240366"></a>**写放大现象：写入数据库导致对磁盘多次写入** 

<a name="dv6j-1740249742983"></a>**B树一次写WAL, 一次写树页面本身**

<a name="anhw-1740249964228"></a>**LSM树反复压缩合并SSTable-较低的写放大**

<a name="xsly-1740250788941"></a>**写频繁应用性能瓶颈：写入速度，写放大导致性能代价-写入磁盘次数越多，可用磁盘带宽内每秒写入次数越少**

<a name="i5jw-1740250937048"></a>**LSM优点：**

<a name="ujpd-1740250987705"></a>**比B树支持更高写入吞吐量：较低的写放大-顺序写入紧凑的SSTable, 非必须覆盖树中几个页面。**

<a name="v8ct-1740251133848"></a>**压缩更好：比B树在磁盘产生更小文件，B树面相页，拆分时产生未使用空间；LSM树不是面相页，定期重写SSTable去除碎片，较低存储开销，特别是平坦压缩**

<a name="smi5-1740251352836"></a>**存储引擎写入模式影响不太明显：**

<a name="alfh-1740251452288"></a>**固态硬盘内部会使用日志结构化算法，将随机写入转变为顺序写入底层存储芯片**

<a name="l62m-1740251469313"></a>**但是，较低的吸入放大率和减少的碎片对SSD仍有利：更紧凑地表示数据可在可用的I/O带宽内提供更多读取和写入**

<a name="jks7-1740153582111"></a>**LSM树的缺点**

<a name="fsqo-1740251639777"></a>**.压缩过程干扰正在进行的读写操作：对吞吐和平均响应时间通常影响很小，但在更高百分比下，日志结构化存储引擎查询响应时间有时相当长，B树行为更具预测性。**

<a name="cp9q-1740251838486"></a>**.压缩跟不上写入速率：高写入吞吐量与压缩配置不匹配，需明确的监控来检测**

<a name="98ps-1740251976429"></a>**B树优点**

<a name="rhwe-1740252063459"></a>**强大的事务语义：**

<a name="ntqr-1740252170914"></a>**每个键只存在于索引中的一个位置，而日志化LSM树不同段中有相同键多个副本**

<a name="dakj-1740252235763"></a>**事务隔离通过键范围使用锁实现，B树索引锁可以之间连接到树**

<a name="xhzo-1740153582113"></a>**其他索引结构**

<a name="5rgs-1740252404764"></a>**主键索引**

<a name="knmi-1740252409865"></a>**二级索引**

<a name="pses-1740153582115"></a>**将值存储在索引中**

<a name="qv6w-1740252438746"></a>**堆文件：行被存储的地方**

<a name="pymp-1740252694481"></a>**某些情况下索引到对文件而外跳跃堆读取性能损失太大**

<a name="kmgw-1740252732413"></a>**聚集索引：索引中存储所有行数据**

<a name="kd3e-1740252804070"></a>**非聚集索引/二级索引：用于回表查询**

<a name="ptaw-1740153582117"></a>**多列索引**

<a name="zyq4-1740252955275"></a>**一个索引key对应多个列/多个字段**

<a name="bias-1740252877232"></a>**连接索引/复合索引：过个字段组成一个键**

<a name="qaxm-1740253057597"></a>**多维索引：地理空间经纬度**

<a name="ktpo-1740253096893"></a>**标准B树或者LSM树索引不够高效支持，经纬度可能是任意值**

<a name="rb86-1740253150498"></a>**解决：空间填充曲线将二维位置转换成单个数字，使用常规B树索引；**

<a name="60tv-1740253222093"></a>**空间索引R树**

<a name="vfjq-1740153582119"></a>**全文搜索和模糊索引**

<a name="pbup-1740253315216"></a>**没有确切值或排序的键场景：错写的单词，模糊查询**

<a name="bfha-1740253391849"></a>**全文搜索引擎：单词扩展同义词，朝文档分类和机器学习方向发展**

<a name="kczd-1740153582121"></a>**在内存中存储一切**

<a name="cxhv-1740253476516"></a>**随着RAM变得越来越便宜，磁盘GB价格优势被侵蚀数据集不大全部保存在内存是可行的**

<a name="ttcb-1740254156445"></a>**内存数据库的发展:Memcached VoltDB,MemSQL**

<a name="v0vo-1740254085247"></a>**支持持久化**

<a name="0h8m-1740254207754"></a>**反缓存anti-caching: 缓存内存中少使用的数据转移到磁盘**

<a name="gigc-1740254291162"></a>**新领域：非易失性存储器NVM,进一步改变存储引擎设计**

<a name="opxp-1740153582123"></a>**事务处理还是分析?**

<a name="l4km-1740344822931"></a>**起初相同数据库用于OLTP和OLAP, 查询效果很好**

<a name="gunc-1740345202551"></a>**80年代末和90年代初，开始在单独数据库上运行分析-数据仓库**

||<a name="geqy-1740344856959"></a><a name="lkro-1740344856962"></a>事务处理OLTP|<a name="dpie-1740344856965"></a>分析系统OLAP|
| :- | :- | :- |
|<a name="hacy-1740344856969"></a>主要读取模式|<a name="sprv-1740344856972"></a>查询少量记录，按键读取|<a name="ulmp-1740344856975"></a>在大批量记录上聚合|
|<a name="ejtp-1740344856979"></a>主要写入模式|<a name="mssh-1740344856982"></a>随机访问，写入要求延时低|<a name="oxyc-1740344856985"></a>批量导入(ETL), 事件流|
|<a name="wegg-1740344856989"></a>主要用户|<a name="wwfw-1740344856992"></a>终端用户，通过Web应用|<a name="yqah-1740344856995"></a>内部数据分析师，决策支持|
|<a name="m9bf-1740344857000"></a>处理的数据|<a name="co2p-1740344857003"></a>数据的最新状态（当前时间节点）|<a name="5fzw-1740344857006"></a>随时间推移的历史事件|
|<a name="giyt-1740344857010"></a>数据集尺寸|<a name="ufu2-1740344857013"></a>GB~TB|<a name="vxdg-1740344857016"></a>TB~PB|

<a name="a3ws-1740153582125"></a>**数据仓库**

<a name="f8mt-1740345620249"></a>**大公司多个OLTP系统： 线下实体店，仓库库存，车辆路线，供应商，员工等**

<a name="tkhz-1740345673586"></a>**小公司少量数据，可在传统SQL数据库中查询，甚至电子表格**

<a name="5lmq-1740345338991"></a>**OLTP下运行OLAP损耗事务性能**

<a name="qhmy-1740345391081"></a>**ETL: 从OLTP数据库提取数据-转换合适的分析模式-清理并加载到数仓**

<a name="omhz-1740345601517"></a>**索引算法对OLTP有效，对于回答分析查询并不是很好**

<a name="s1an-1740153582127"></a>**OLTP数据库和数据仓库之间的分歧**

<a name="vzyr-1740345853192"></a>**数仓对分析性查询进行了优化**

<a name="sx44-1740345915239"></a>**现在数据库供应商重点支持事务处理或分析工作负载其一**

<a name="ybnk-1740153582129"></a>**星型和雪花型:分析的模式**

<a name="jheq-1740348889870"></a>**星型模型/维度建模**

<a name="lwmn-1740348945086"></a>**非零售量而是分析流量- 每行是用户页面浏览量或点击量，**

<a name="mjj1-1740349156137"></a>**事实被视为单独事件，列为属性，其他是维表的外键引用(事件发生地点，时间，方式，原因)**

<a name="3nxf-1740349244410"></a>**雪花型，品牌和产品类别有单独表格，而非字符串。**

<a name="gy72-1740349701771"></a>**比星型更规范化，但星型通常为首选，使用简单**

<a name="u1pg-1740349755363"></a>**事实表格宽泛，通常有100列以上**

<a name="cvpc-1740153582131"></a>**列存储**

<a name="lknp-1740352332002"></a> **100列宽度，按行从磁盘加载到内存，解析过滤，耗时长**

<a name="hlpv-1740352397203"></a>      **解决：按列存储**

<a name="gsyu-1740153582133"></a>**列压缩**

<a name="ezrn-1740352503854"></a>**压缩进一步降低吞吐量需求，且列存储适合压缩，重复数值多**

<a name="l5z0-1740352533108"></a>**位图编码压缩**

<a name="mtsf-1740153582135"></a>**内存带宽和向量处理**

<a name="ksbk-1740352860514"></a>**矢量化处理： 按位"与"和“或”直接在这样的压缩列数据块上操作**

<a name="axhk-1740153582137"></a>**列存储中的排序顺序**

<a name="utbx-1740153582139"></a>**几个不同的排序顺序**

<a name="hw2b-1740153582141"></a>**写入列存储**

<a name="lmc7-1740153582143"></a>**聚合:数据立方体和物化视图**

<a name="hypc-1740153582145"></a>**本章小结**

<a name="ycte-1644935336049"></a>本章小结：数据库如何处理存储何检索。将数据存储在数据库中会发生什么，再次查询数据库会发生什么？

<a name="bivs-1644935398311"></a>在高层次上，存储引擎分两大类：

<a name="bhcv-1644935436804"></a>**-优化事务处理（OLTP）transaction** 

<a name="tbhw-1699844517372"></a>**1.OLTP系统通常面向用户，大量的请求。**

<a name="fnev-1644935714127"></a>**2.磁盘寻道时间往往是这里的瓶颈。**

<a name="cjwp-1644935609899"></a>**3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。**

<a name="jg7s-1699844443567"></a>**-优化分析（OLAP）analys**

<a name="n8me-1644935726822"></a>    OLTP数据 copy and translatin 转换为适合业务分析的数据副本 to 数据仓库（OLAP）

<a name="3cwp-1644935731444"></a>OLAP**数据仓库**和类似的分析系统不太知名，因为只要由业务分析人员使用，而不是由最终用户使用

<a name="s6pt-1644935799372"></a>处理比OLTP系统少得多得查询量，但是每个查询通常要求很高，短时间内扫描百万条记录。

<a name="cyhe-1644935862917"></a>磁盘带宽（不是查找时间）往往是瓶颈，列式存储是这种工作负载的流行解决方案。

<a name="pjd1-1703887811615"></a>**1.列式储存(投影操作，压缩技术，聚合过滤)**

OLAP TB,PB级别的数据(几百列)情况下，索引的相关性就会下降很多，磁盘带宽往往是瓶颈

解决方案-列式存储(将表右旋90度，每行为单个列文件)

1\.将表头设置为列文件名，文件存储单列内容、

2\.如需第23行，则将需要的列文件的第23项形成表的第23行

SSN            Name    Age    Addr    city    st    

101259797    SMITH     88    899 FIRST ST

892375862

318370701

block 1 SSN    101259797|l892375862|318370701|468248180|378568310/231346875|317346551|770336528|277332171

优势：

.投影操作：仅需检索所需的列，大大减少读取的数据量。

.压缩技术：通常采取高度优化的压缩技术。-相邻的数据通常具有相似的值。减少存储空间，提高查询性能

.向量化处理：通常采用向量化处理，意味着可以一次操作整个数据向量，而不是逐个处理行。

-并行处理和SIMD指令集优化非常有利

.聚合操作：在SUM、AVG等聚合操作上表现良好

.过滤操作：特定列过滤更快

.分析查询：部分查询而不是全部

<a name="kg2a-1703885936042"></a>Apache: Cassandra、 HBase

<a name="8sgm-1644935924013"></a>**-OLTP两大主流学派的存储引擎：**

<a name="i55y-1644935943748"></a>**1.日志结构学派**

<a name="4nm8-1644935988277"></a>只允许附加到文件和删除过时文件，但不会更新已经写入的文件。（高效，顺序IO?）

<a name="6ymo-1644936029696"></a>Bitcask, SSTables, LSM树，LevelDB, Cassandra, HBase, Lucene等都属于这个组。

<a name="h3il-1644935977285"></a>**2.就地更新学派**

<a name="2w0c-1644936091115"></a>将磁盘视为一组可以覆盖的固定大小页面。（随机IO?）

<a name="hpzs-1644936142472"></a>B树是这种哲学的最大例子，被用在所有主要的关系数据库中，还有许多非关系数据库。

<a name="fil5-1644936170765"></a><a name="vypn-1644936170925"></a>日志结构的存储引擎是相对较新的发展，他们的主要想法是，系统地将随机访问写入顺序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短的介绍。

<a name="a5tj-1644936526197"></a>然后我们从存储引擎的内部绕开，看看典型的数据仓库的高级架构。这一背景说明了为什么分析工作负载和OLTP差别很大：

<a name="nyml-1644936619727"></a>当您的查询需要在大量（几百列）的行中顺序扫描时，索引的相关性就会下降很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读取的数据量。我们讨论了列式存储如何帮助实现这一目标。

<a name="2akd-1644935679338"></a>作为一名应用开发人员，如果您掌握了有关存储引擎内部知识，那么就能更好地那种工具最适合您的特定应用程序。如果需要调整库的参数，这种理解可以让您设想一个更高或者更低的参数可能会产生什么效果。

<a name="ohao-1644936963029"></a>尽管本章不能让你成为一个特定存储引擎的调参专拣，但它至少有大概率使你有了足够的概念与词汇储备去读懂数据库的文档，从而选择合适的数据库。

<a name="en4q-1644936942676"></a><a name="lbs1-1677787447010"></a>**4.编码（序列化）与演化(XML,JSON,CSV)**

<a name="mbsl-1740362305245"></a>waite,back to interview

<a name="hnz2-1740362369788"></a>**编码数据的格式**

<a name="loua-1740362391326"></a>**语言特定的格式**

<a name="bvx6-1740362391328"></a>**JSON，XML和二进制变体**

<a name="vxuu-1740362391330"></a>**二进制编码**

<a name="mzz8-1740362391332"></a>**Thrift与Protocol Buffers**

<a name="bivf-1740362391334"></a>**字段标签和模式演变**

<a name="mshf-1740362391336"></a>**数据类型和模式演变**

<a name="defc-1740362391338"></a>**Avro**

<a name="rsr4-1740362391340"></a>**作者模式与读者模式**

<a name="dkzq-1740362391342"></a>**模式演变规则**

<a name="ndh2-1740362391344"></a>**但作者模式到底是什么?**

<a name="hxlw-1740362391346"></a>**动态生成的模式**

<a name="lq8a-1740362391348"></a>**代码生成和动态类型的语言**

<a name="dd97-1740362391350"></a>**模式的优点**

<a name="vcma-1740362391352"></a>**数据流的类型**

<a name="mmkb-1740362391354"></a>**数据库中的数据流**

<a name="dedw-1740362391356"></a>**在不同的时间写入不同的值**

<a name="gax1-1740362391358"></a>**归档存储**

<a name="0l6j-1740362391360"></a>**服务中的数据流:REST与RPC**

<a name="qik0-1740362391362"></a>**Web服务**

<a name="2jfn-1740362391364"></a>**远程过程调用(RPC)的问题**

<a name="olix-1740362391366"></a>**RPC的当前方向**

<a name="k8b3-1740362391368"></a>**数据编码与RPC的演化**

<a name="er0d-1740362391370"></a>**消息传递中的数据流**

<a name="0qtl-1740362391372"></a>**消息掮客**

<a name="a9jv-1740362391374"></a>**分布式的Actor框架**

<a name="hc4u-1740362391376"></a>**本章小结**

<a name="18rw-1644940257792"></a>在本章中，我们研究了将数据结构转换为网络中的字节或磁盘上的字节的几种方法。编码的细节影响其效率，更重要的是应用程序的体系结构和部署它们的选项。

<a name="bfvx-1644940365841"></a>特别是，许多服务需要支持滚动升级（灰度发布），其中新版本的服务逐步部署到少数节点，而不是同时部署到所有节点。滚动升级允许在不停机的情况下发布新版本的服务（从而鼓励在罕见的大型版本上频繁发布小型版本），并使部署风险降低（允许在影响大量用户之前检测并回滚有故障的版本）。这些属性对于可演化性，以及对应用程序进行更改的容易性都是非常有利的。

<a name="w4qv-1644940598057"></a>在滚动升级期间，或出于其它原因，我们必须假设不同的节点正在运行我们的应用程序代码的不同版本。因此，在系统周围流动的所有数据都是以提供向后兼容性（新代码可以读取旧数据-服务端）和向前兼容性（旧代码可以读取新数据-客户端）的方式进行编码是重要的。我们讨论了几种数据编码格式极其兼容性：

<a name="zw4l-1644940805237"></a>编程语言特定编码仅限于单一编程语言，并且往往无法提供向前和向后兼容性。

<a name="1zx9-1644940881501"></a>JSON, XML和CSV等文本格式非常普遍，其兼容性取决于如何使用它们。他们有可选模式语言，这有时是有用的，有时是一个障碍。这些数据格式对于数据类型有些模糊，所以你必须小心数字和二进制字符串。

<a name="q8m7-1644942050475"></a>像Thrift, Protocol Buffers和Avro这样的二进制模式驱动格式允许使用清晰定义的向前和向后兼容性语义进行紧凑，高效的编码。这些模式可以用于静态类型语言的文档和代码生成。但是，他们有一个去缺点，就是在数据可读之前需要对数据进行解码。

<a name="hqvm-1644942192088"></a>我们还讨论了几种数据流的几种模式，说明了数据编码是重要的不同场景：

<a name="c94y-1644942236778"></a>数据库，写入数据库的进程对数据进行编码，并从数据库读取进程对其进行解码

<a name="kcmv-1644942289426"></a>RPC 和 REST API, 客户端对请求进行编码，服务器对请求进行解码并对相应进行编码，客户端最终对相应进行解码。

<a name="nvcq-1644942366178"></a>异步消息传递（使用消息代理或参与者），其中节点之间通过发送消息进行通信，消息由发送者编码并由接收者解码。

<a name="oxsf-1644942481249"></a>我们可以小心地得出这样的结论：向前兼容性和滚动升级在某种成都上是可以实现的。愿您的应用程序的演变迅速，敏捷部署。

<a name="rmsh-1646310193756"></a><a name="4p9n-1677787447012"></a>**第二部分 分布式数据**

<a name="gr0m-1646310278506"></a>本章考察了复制的问题，复制可以用于几个目的：

<a name="o4ag-1646310813851"></a>**1.高可用性/容错**

<a name="r7ua-1646310833943"></a>即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行

<a name="snwm-1646310894841"></a>**2.断开连接的操作**

<a name="x2dq-1646310900787"></a>允许应用程序在网络中断时继续工作

<a name="evly-1646310918322"></a>**3.减少延迟(节点近)**

<a name="iz8f-1646310928916"></a>将数据放置在距离用户较近的地方，以便用户能够更快地与其交互

<a name="itsh-1646310968967"></a>**4.可拓展性**

<a name="ncek-1646310974776"></a>能够处理比单个机器更高的读取量可以通过对副本进行读取来处理

<a name="ybmg-1646311013702"></a><a name="a6ti-1646311014184"></a>尽管是一个简单的目标-在几台机器上保留相同数据的副本，但复制确实一个非常棘手的一个问题。它需要仔细考虑并发和所有可能出错的事情，并处理这些故障的后果。

<a name="cpjg-1646311086181"></a>至少，我们需要处理不可用的节点和网络中断（甚至不考虑更隐蔽的故障，例如由软件错误导致的无提示数据损坏）。

<a name="gjis-1708362947856"></a>**.拓展至更高的载荷**

<a name="mgia-1708362999715"></a>**垂直扩展scale up ：购买更强大的机器 cpu**

<a name="pdo8-1708363038596"></a>**共享内存架构shared-memory architecture：许多处理器、内存和磁盘再同一操作系统下相互连接，共享内存和磁盘**

<a name="wgwl-1708363065800"></a>**共享磁盘share-disk architecture：独立处理器和内存，数据存储在机器之间共享的磁盘阵列上，磁盘通过快速网络连接。数仓**

<a name="klw2-1708363340866"></a>**无共享架构**

<a name="z1yn-1708363411467"></a>share nothing/scale out: 水平拓展，单独节点，通过网络连接。

<a name="gbgq-1646311175182"></a>**.复制VS分区**

<a name="gd4q-1708363438406"></a>**5.复制**

<a name="ekkr-1708364726154"></a>-复制的三种主要方法：几乎所有分布式数据库都使用这三种方法之一

<a name="wg6v-1646311185918"></a><a name="ftqb-1646311200843"></a>**2.多主复制**

<a name="ak8v-1646311613462"></a>客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随着节点。

<a name="4xbf-1646311410600"></a>**3.无主复制**

<a name="b6zn-1646311685371"></a>客户端发送每个写入到几个节点，并从多个节点并行多去，以检测和纠正具有陈旧数据的节点。

<a name="tyus-1646311850435"></a><a name="dzsw-1646311850942"></a>单主复制是非常流行的。多领导和无领导复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。

<a name="sgmj-1646311002454"></a>我们讨论了一些有助于决定应用程序在复制滞后时的行为的

<a name="w1xl-1708441626775"></a><a name="eumz-1646312681469"></a>多领导者和无领导者复制方法所固有的并发问题：允许多个写入并发发生冲突。研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者他们是否同时发生。

<a name="xukg-1646312787143"></a>还谈到了通过合并并发更新来解决冲突的方法。

三种流行的变更复制算法：

单领导者single leader多领导者multi leader 无领导者leaderless 几乎所有分布式数据库都使用这三种方法之一。

<a name="hu8h-1708441083912"></a>最终一致性eventual consistency    读己之写read your write        单调读monotonic read

<a name="9hbs-1708441077626"></a>**.领导者与追随者-单主复制**

<a name="aucb-1708528116000"></a>**客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。**

<a name="wgge-1646311567456"></a>**读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）**

副本replica    基于领导者的复制leader based replication也称主动/被动active/passive  或 主/从master/slave复制

领导者leader    主库master primary    

<a name="evej-1708441699768"></a>追随者followers      只读副本read replicas    从库slaves 次要sencondaries  热备hot standby    复制日志replication log    变更流change stream

<a name="cbey-1646310922523"></a>**.同步复制与异步复制**

同步synchronously    异步asychronously

所有从库设置为同步复制：慢，低可用

<a name="tyba-1708441996611"></a>半同步semi synchronous 即至少在两个节点上拥有最新的数据副本：主库和同步从库    持久durable

<a name="j5o0-1704983008475"></a>**.设置新从库(快照复制+caught up binlog)**

增加副本数量 / 替换失败节点；如何确新的从库拥有主库数据的精确副本

.锁库后同步数据/备份  -mysql全局锁同步数据，低可用

.非阻塞性同步，快照同步，步骤如下：        -其实就是先快照复制/备份某个时间点前的数据，再通过binlog lsn同步后续变更

1\.在某个时刻获取主库的一致性快照 如mysql innobackupex

2\.将快照复制到新的从库节点

3\.连接主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。PostgreSQL称为日志序列号log sequence number-LSN，mysql将其称为二进制日志坐标binlog coordinates

4\.当从库处理完快照之后积压的数据变更，我们说它赶上caught up了主库。现在可以继续处理主库产生的数据变化了

<a name="rv7k-1708442520512"></a>-question :为什么不直接用binlog设置新从库？因为binlog日志文件占磁盘空间大，为了释放磁盘空间，会定时清理掉久远的数据。而快照备份原理则直接利用数据库数据文件进行复制/备份(如备份当前的数据)，参考mysql 快照备份。

<a name="bcod-1708442233018"></a>**.处理宕机节点**

<a name="5ufz-1708443850274"></a>**从库失效：追赶恢复**

<a name="r3tg-1708443904810"></a>比较容易恢复，从库可以从日志中知道，发生故障前处理的最后一个事务。

<a name="nsxx-1708443979184"></a>因此，从库可以连接到主库，并caught up后像之前一样继续接收数据变更流。

<a name="udix-1708443860752"></a>**主库失效：故障切换failover**

<a name="w3sj-1708523445192"></a>**自动切换步骤：1.确认主库失效**

<a name="y3qn-1708523480847"></a>**2.选举新主库：共识**

<a name="wua6-1708523497956"></a>**3.配置系统启用新主库**

<a name="z7mn-1708523814309"></a>**failover的麻烦：1.异步复制数据丢失**

<a name="mnjx-1708523836932"></a>**2.自增主键冲突**

<a name="dbhg-1708523873194"></a>**3.脑裂split brain**

<a name="561v-1708523878338"></a>**4.如何设置超时**

相当棘手：故障切换failover

其中一个从库需要被提升为新的主库，重新配置客户端，将写操作发送给新的主库，其他从库从新主库中拉取变更流。

自动故障切换可以手动进行（通知管理员，采取必要步骤创建新主库）

自动进行：

1\.确认主库失效。崩溃/超时

2\.选择新的主库。选举election 或 由之前选定的控制器节点controller node 来制定新的主库。主库最佳人选通常是拥有旧主库最新数据副本的从库。让所有节点同意一个新的领导者，是一个共识consensus问题

3\.重新配置系统以启用新主库。客户端需要将写请求发送给新主库（请求路由）。如果老主库回来，可能仍然认为自己是主库，系统需要确保就主库认可新主库，成为一个从库。

故障切换会出现很多大麻烦

1\.如果异步复制，可能会丢失数据

2\.如果数据库需要与其他外部存储相协调，那么丢弃写入内容是极其危险的操作。

github的一场事故中，一个过时的mysql从库被提升为主库，使用自增id作为主键，新主库计数器落后于老主库。重新分配一些id作为主键。这些主键在redis中使用。导致mysql和redis中数据产生不一致。导致一些私有数据泄露到错误用户手中。-是不是清缓存就可以,且详细验证

3\.脑裂split brain,出现两个节点都以为自己是主库。如果两个主库都接收写操作，却没有冲突解决机制，数据可能会丢失或损坏。

可以设计当检测到两主库，可以设置关闭其中一个节点，但粗糙的机制可能导致两个节点都被关闭

<a name="uv1j-1708443830595"></a>4.主库超时时间如何配置，如过在峰值中切换，可能让情况变得更糟。

<a name="8mem-1708442228760"></a>**.复制日志的实现**

<a name="k8yo-1708524004340"></a>**基于语句的复制(每个写入请求语句statment)**

<a name="hcqe-1708524155632"></a>**记录每个写入请求语句statment，语句日志传输给从库**

<a name="9xml-1708524182083"></a>**问题：非确定函数nondeterministic, NOW()  RAND()**

<a name="il4a-1708524271564"></a>    **自增列- 造成差异**

<a name="azmh-1708524331636"></a>**副作用的语句：用户自定义函数，触发器，存储过程**

<a name="rcfb-1708524371120"></a>**解决: 用固定值替换**

<a name="6uy2-1708524426849"></a>  **如语句存在任何不确定性，切换到基于行的数据**

<a name="ityn-1708524645902"></a><a name="rnmz-1708524013585"></a>**传输预写式日志(WAL)**

<a name="hze4-1708524498278"></a>**日志存储引擎SSTables LSM树**

<a name="qzop-1708524541132"></a>**磁盘块的B树  WAL, 崩溃恢复**

<a name="rh9a-1708524641979"></a><a name="a3ng-1708524040960"></a>**逻辑日志复制(基于行)**

<a name="jiiu-1708524648209"></a>**binlog**

<a name="ezoi-1708524083973"></a>**基于触发器的复制**

<a name="nyjo-1708527704881"></a><a name="jamd-1708524904250"></a>**.复制延迟问题(解决方法都是反分布式，或者趋于单机一致性。数据一致性模型：<https://jepsen.io/consistency>)**

<a name="w5nz-1708525244967"></a>**读己之写(读主库或带写时间戳查询)**

<a name="25nj-1708526407050"></a>**写后从旧副本读取数据-未同步**  

<a name="4st1-1708525569674"></a>**解决：写后读read after write 一致性 或叫做 read your write consistency 防止这种异常**

<a name="v4r0-1708525736897"></a>**1.都从主库读。适用仅由用户本人编辑的数据，如个人信息。大部分内容从主库读不适用，扩容读无效果**

<a name="vqjs-1708525818133"></a>**2. 扩容读需要保证更新时间，监控复制延迟，防止滞后超过一分钟从从库发出查询**

<a name="nmrh-1708525971734"></a>**3. 客户端记录写入时间戳，系统确保从库提供查询时，版本时间已覆盖，否则从另一个从库读，或者等待caught up-  等待不就相当弱可用状态，且时钟不可靠**

<a name="wmu9-1708526095856"></a>**4. 副本在多个数据中心，复杂度高，都需经过主库IDC**

<a name="o5gj-1708702027717"></a><a name="kwrd-1708525264596"></a>**单调读(基于id散列路由同一副本)**

<a name="npwe-1708527802311"></a>**先读到最新副本，后读到旧副本感觉数据消失**

<a name="4cn0-1708526272081"></a>**A看到B评论后消失，时光倒流moving backward in time** 

<a name="drqk-1708526396300"></a>**解决：单调读monotonic reads总是从同一个副本进行读取(基于用户散列id，如果副本失效则重新路由)**

<a name="s6u3-1708526566643"></a>  **比强一致性(同步复制/类比单机)弱，比最终一致性更强**

<a name="hfrl-1708527791940"></a><a name="bfps-1708525268614"></a>**一致前缀读(因果关系写到相同分区)**

<a name="q7p0-1711363121071"></a>**consistent prefix reads**

<a name="rqcm-1708527879976"></a>**不同分片副本同步先后问题导致读顺序错误**

<a name="bwov-1708526677620"></a>**分区partition/分片sharded数据库中的一个特殊问题，全局写入顺序**

<a name="7e9o-1708526727984"></a>**分区主库1写入 A:你吃饭了吗？ 分区主库2写入B:没有。 分区1副本同步主库1落后分区2副本同步主库2    C读取1副本: 没有，后读取2副本。你吃饭了吗？**

<a name="turn-1708527108521"></a>**解决：确保因果关系都写入到相同分区**

<a name="yygl-1708702065256"></a><a name="a2la-1708525420248"></a>**复制延迟解决方案**

<a name="x8ng-1708527233293"></a>**趋于反分布式，局部或者部分看做一个单机，做到强一致性**

<a name="gecf-1708527304184"></a>**写后读。**

<a name="zsq6-1708527307246"></a>**数据库通过事务提供强大保证。**

<a name="m7de-1708525314549"></a><a name="pbfd-1708528009698"></a>**.多主复制(主主复制，互为副本-写冲突。多主复制被认为是危险的领域)**

<a name="kxkx-1708441627686"></a>**多主复制的应用场景**

<a name="xrso-1708700002291"></a>**运维多个数据中心(IDC-主主间复制需要处理写冲突）**

<a name="06t6-1708700132681"></a>**性能(多活配置，写操作在本地IDC处理，其他IDC异步复制，性能更好)**

<a name="9sww-1708700267631"></a>**容忍IDC停机**

<a name="dtkl-1708700295371"></a>**容忍网络问题(临时的网络中断不会妨碍正在写入的处理)**

<a name="knxa-1708700020273"></a>**需要离线操作的客户端(支持多个终端离线操作couchDB)**

<a name="hvwb-1708700115895"></a>**协同编辑**

<a name="kjs9-1708701808580"></a><a name="fdot-1708700612321"></a>**处理写冲突(A将标题从1改2,B将1改3)**

<a name="u8bc-1708700824251"></a>**同步于异步冲突检测**

<a name="wfgd-1708700957597"></a>**同步：单主程序复制 - 不允许每个副本独立接受写入**

<a name="x6is-1708701017804"></a>**异步：独立接受写入- 异步检测，但为时已晚**

<a name="xg2a-1708700840681"></a>**避免冲突(特定记录写入都通过同一个领导者，主库切换或者用户迁移至更近的主库时会有同时写入的可能性)**

<a name="ucfn-1708700844474"></a>**收敛convergent至一致的状态(副本主库和其副本在复制完成时收敛至一个相同的最终值)**

<a name="cbla-1708701376316"></a>**最后写入胜利LWW,last write wins- 给每个写入一个唯一id, 挑选最高ID的写入作为胜利者，并丢弃其他写入-数据丢失**

<a name="40po-1708701481447"></a>**为每个副本分配一个唯一ID,ID编号更高的具有高优先级。数据丢失**

<a name="p4m4-1708701593939"></a>**将值合并在一起**

<a name="8fcs-1708701611999"></a>**记录冲突，并编写解决逻辑代码。如通过提醒用户方式**

<a name="yrdi-1708700860148"></a>**自定义冲突解决逻辑**

<a name="t4i7-1708702160004"></a>**自定义冲突解决逻辑(complex)**

<a name="pdql-1708702370625"></a>**写时执行-后台处理**

<a name="sksk-1708702376293"></a>**读时执行-提供多版本用户选择，回写数据库**

<a name="4bqp-1708702425059"></a>**亚马逊购物车移除的商品重新出现**

<a name="6x4i-1708700867996"></a>**什么是冲突(两个领导者预订同一个会议室，7章看冲突实例12章看检测解决)**

<a name="xotk-1708702756879"></a><a name="o41a-1708702111509"></a>**多主复制拓扑**

<a name="5feh-1708702903239"></a>**环形，星型，all to all -mysql仅支持环形**

<a name="ddyu-1708702949257"></a>**问题：多主复制时，可能在某些副本中写入错误的顺序。like A写主库1，B写主库2，主库3先同步2，再同步1。类似一致前缀读。**

<a name="ghp3-1708703247102"></a>**解决：时间戳是不够的-不可靠时钟，使用一种称为版本向量(version vectors)的技术-检测并发写入**

<a name="fdrv-1708759283998"></a><a name="bfz8-1708759285067"></a>**无主复制leaderless**

<a name="cvru-1708759359537"></a>**Amazon的Dynomo系统。**

<a name="wf6o-1708759707666"></a>**Riak, Cassandra，Voldmort 也称为Dynamo风格。**

<a name="xpqf-1708760120711"></a>**类型1：客户端直接将写入发送到几个副本中**

<a name="pl2z-1708760121090"></a>**类型2：coordinator协调者节点代表客户端写入。**

<a name="x6pj-1708759817229"></a><a name="qgpe-1708760989905"></a>**当节点故障时写入数据库(仲裁写⼊，法定读取，并在节点中断后读修复。)**

<a name="zfuz-1708760396929"></a>**如果主从复制，主故障/重启系统更新 则需进行故障切换**

<a name="3soj-1708760452090"></a>**无主复制： userA set piture\_url   -> replica1 ok    Then version=7**

<a name="4f05-1708760543198"></a>           **user set piture\_url   -> replica2 ok  Then version=7**

<a name="ynls-1708759898772"></a>**user set piture\_url   -> replica3 offline  fail   version= 6**

<a name="e1ur-1708760618873"></a>    **userB get piture  :  rp3(version6) rp1(version7)  rp2(version7)  Than fix rp3 value to version7**

<a name="tyv3-1708760780373"></a> **读修复和反熵(失效节点重新连机后如何caught up)**

<a name="wjho-1708761214792"></a>**读修复like userB get piture fixed rp3**

<a name="xblj-1708761286988"></a>**反熵 后台进程不断查找副本之间的数据差异。Voldmort无反熵过程，副本可能丢失数据**

<a name="w3ia-1708761120623"></a> **读写的法定人数（仲裁）**

<a name="ddkz-1708761600371"></a><a name="oj1i-1708759830121"></a>**仲裁一致性的局限性-最终一致，更强的保证需要事务或共识**

<a name="cu5q-1708759841416"></a>**松散法定人数与带提示的接力**

<a name="kzki-1708761744887"></a>**运维多个数据中心-将写入发送到所有副本，仅需本地IDC内法定节点确认**

<a name="pt1k-1708759856530"></a>**检测并发写入**

<a name="mu89-1708761978075"></a>**Dynamo风格的数据存储，没有明确定义的顺序。**

<a name="dbni-1708763823783"></a>**userA set x=A   get x**

<a name="auce-1708763993783"></a>**rp 1 A ok    B unresponsive   A**

<a name="kteo-1708764011894"></a>**rp2 A ok   B OK  B**

<a name="9xyy-1708764019308"></a>**rp3 B ok A ok A**

<a name="esiv-1708702764305"></a>**userB set x=B** 

<a name="wd1i-1708764197180"></a>**最后写入胜利(丢弃并发写入)**

<a name="uzhw-1708874432788"></a>**LLW 无法确定真实排序，强制排序，选择最新的最大时间戳，并丢弃较早的任何写入.Cassandra唯一支持的方式，Riak可选**

<a name="henp-1708874594301"></a>**缺点：数据丢失** 

<a name="hzwp-1708764215825"></a>**此前发生的关系和并发**

<a name="3wp0-1708874672763"></a>**因果依赖(causally dependent)  如果B后发与A, 则B因果依赖A,** 

<a name="1wzv-1708875051673"></a>**如果是并发，则存在需要解决的冲突**

<a name="j2r6-1708764228505"></a>**捕获此前发生的关系**

<a name="vv7q-1708875756229"></a>**捕获两个客户端间的因果关系，同时编辑购物车(示例为单副本)**

<a name="zp0i-1708874374616"></a>**合并同时写入的值**

<a name="wawo-1708876272614"></a>**客户端需额外工作，合并并发写入的值来擦屁股。Riak称这些并发值兄弟(sibings)**

<a name="arlv-1708874381589"></a>**版本向量**

<a name="b1ov-1708700703636"></a>**所有副本的版本号集合称为版本向量(version vector)**

<a name="hdj8-1708940956650"></a><a name="dyz5-1709800112532"></a>**6.分区**

<a name="twd1-1709800204792"></a>**.分区与复制(分区与复制方案是独立的)**

<a name="efhv-1709800783933"></a>分区⽅案的选择与复制⽅案的选择是独⽴的，为简单起⻅，本章中将忽略复制。

<a name="cbpl-1709800862211"></a>图例：组合使用复制和分区，同一分区不同数据分片可为其他区分片主从。

<a name="fbqg-1709800263679"></a>**.键值数据的分区**

<a name="s7ju-1709801062977"></a>**偏斜skew：分区过多数据或过多查询**

<a name="u0d3-1709801107270"></a>**热点hot spot:高负载的分区**

<a name="lqbu-1709800332210"></a>**根据键的范围分区**

<a name="i2ju-1709801151406"></a>**Bigtable, HBase, RethinkDB 和 MongoDB2.4**

<a name="np00-1709801582805"></a>**按照一定的顺序保存键（SSTbale和LSM-树）**

<a name="evhb-1709801683166"></a>**按时间分区当日写过载（需加传感器保证日期+传感主键均匀分布）**

<a name="a1yy-1709800347130"></a>**根据键的散列分区(可将偏斜数据均匀分布)**

<a name="mdg4-1709801628016"></a>**不适合分区的简单哈希函数：java .hashCode-同键不同进程不同哈希值**

<a name="7rkg-1709802019859"></a>**一致性哈希consistent hashing:哈希键分区边界均匀间隔，也可伪随机选择（CDN均匀分配负载）。**

<a name="iktb-1709802309508"></a>**缺点：无序，低效范围查询(需发送到所有分区)**

<a name="zznq-1709802490074"></a>**折中方案：复合主键/组合索引。(uid,time).不同用户在不同分区，每个用户按时间搓顺序存储在单个分区上。**

<a name="ed70-1709800357523"></a>**负载倾斜与消除热点**

<a name="403a-1709802593546"></a>**数百万追随者做某事-大量写入同一个键**

<a name="wx5s-1709802730512"></a>**解决：火爆主键+随机数即可将主键分散为100个分区**

<a name="h0b7-1709802773377"></a>**缺点：数据合并，跟踪火爆主键。需权衡利弊。**

<a name="ekdv-1709800287975"></a>**.分片与次级索引**

<a name="n3vk-1709803239471"></a>**次级索引通常并不能唯一标识记录。**

<a name="q1u5-1709803293988"></a>**HBase Volde-mort为了减少实现复杂度放弃了次级索引。**

<a name="fhpr-1709803333585"></a>**Riak开始添加， 次索是Solr Elasticesearch 搜索的基石**

<a name="mwm0-1709800370635"></a>**按文档的二级索引**

<a name="ud7o-1709803718409"></a>**文档分区索引/本地索引**

<a name="zlhf-1709803740582"></a>**每个分区独立维护自己的二级索引。**

<a name="bkj3-1709803789802"></a>**查询发送所有分区，并合并所有返回结果，分散/聚集scatter/gather-容易导致尾部延迟放大。**

<a name="ghpm-1709803878421"></a>**缺点：可能使二级索引读取查询相当昂贵。**

<a name="itl0-1709800380617"></a>**根据关键词(Term)的二级索引**

<a name="8bw4-1709804016790"></a>**全局索引：覆盖所有分区数据的索引，也须分区。**

<a name="qc2d-1709913637902"></a>**关键词分区：关键词本身或它的散列进行分区。**

<a name="jmj8-1709913775261"></a>**优点：只需请求包含关键词的分区，读取更有效率**

<a name="i7kp-1709913825503"></a>**缺点：写入慢且复杂。需支持分布式事务。**

<a name="mv7j-1709913923874"></a>**理想下总是最新，实践中更新通常为异步。Amazon DynamoDB声称全局次级索引不到1s内更新。**

<a name="hpnd-1709800294747"></a>**.分区再平衡(reblancing)**

<a name="1f0n-1709914101899"></a>**吞吐量增加：加cpu**

<a name="vjb0-1709914129763"></a>**数据集大小增加：加磁盘和RAM**

<a name="smcd-1709914153882"></a>**机器故障：其他机器接管**

<a name="2efu-1709916803909"></a>**----------再平衡应满足--------------**

<a name="20wj-1709916807951"></a>**发生时：数据库应该继续接受读取和写入**

<a name="cxoi-1709916893371"></a>**节点之间只移动必须数据(分区)，以便快速再平衡，减少网络和磁盘io负载。**

<a name="cj8j-1709916938075"></a>**平衡后：存储，读取和写入公平共享**

<a name="cavd-1709800402611"></a>**平衡策略**

<a name="6f6z-1709800409866"></a>**反面教材：hash mod N**

<a name="anib-1709916997775"></a>**$hash(key)=22  22mod10..2  22mod 11...0  22 mod 9 ...4** 

<a name="anz7-1709917243580"></a>**节点需要转移秘钥及次数过多，过于昂贵。**

<a name="7ytl-1709917334275"></a>**解决：更换为只移动必须数据的方法。**

<a name="8l9j-1709800420954"></a>**固定数量的分区(加节点时分配分区)**

<a name="vmsm-1709917322722"></a>**新增/减少节点时，将现存部分数据转移到节点新增/现存节点(Riak,es,couchbase Voldemort使用这种再平衡）**

<a name="ktrd-1709917648400"></a>**适用：分区数量第一次建立时确定。**

<a name="vw7j-1709917692466"></a>**缺点：数据集总量大小难以预估时；分区大再平衡代价昂贵，分区小产生额外开销。**

<a name="eszc-1709921747523"></a>**分区大小与集群数据总量成比例增长**

<a name="tkjw-1709800428033"></a>**动态分区(适用键范围的分区)**

<a name="itsg-1709917825657"></a>**解决：使用键范围分区，固定边界的固定数量的分区不便。出现边界错误，手动重新去配分区边界将非常繁琐。**

<a name="05rm-1709917996703"></a>**动态分区：与B树类似，分区数据增长超过配置时将分成两区，大量数据删除分区缩小低于阈值则合并(HBase RethinkDB)**

<a name="v8uv-1709918235496"></a>**优点：分区数量适应总数据量-动态划分分区数量。**

<a name="cdjv-1709918375629"></a>**注意：空库分区开始，未绘制边界先验信息。所有写操作都必须由单个节点处理。其它节点空闲**

<a name="3uee-1709918458100"></a>**解决：配置一组初始分区-预分割 Hbase MongoDb。配需提前知道键分配方式。**

<a name="tlmq-1709918504615"></a>**MongoDB同时支持范围和哈希分区且动态分割分区。**

<a name="xqee-1709921516740"></a>**分区数量与数据集大小成正比**

<a name="kcsr-1709800432396"></a>**按节点比列分区**

<a name="xscz-1709920011051"></a>**新增节点，分区将变小。随机选择固定数量的现有分区进行拆分,最终获得公平的负载份额。cassandre ketama.**

<a name="pmpc-1709920187661"></a>**随机选择分区边界要求使用基于散列的分区-一致性哈希。**

<a name="a0l0-1709923420226"></a>**分区数量与节点数量无关**

<a name="w6ob-1709800443454"></a> **运维：手动还是自动平衡**

<a name="qobk-1709920292898"></a>**自动：与故障检测结合将十分危险，高负载节点响应慢被视为死亡被踢掉，重新平衡集群时其他超负荷节点可能级联失败**

<a name="a05n-1709920414620"></a>**手动人为监控+自动**

<a name="qxk3-1709800301840"></a>**.请求路由**

<a name="sd2e-1709921854453"></a>**分区再平衡后的服务发现(IP 端口)**

<a name="gliq-1709921964410"></a>**-------方案-------**

<a name="ibln-1709921978507"></a>**1.循环策略：Round-Robin load balancer，轮询节点看是否有请求的分区。**

<a name="gjxa-1709922094115"></a>**2.路由层：有中间层的路由决定请求的节点，由路由层负载均衡**

<a name="ukz9-1709922149547"></a>**3.要求客户端知道分区和节点的分配。客户端可直连节点。**

<a name="1c54-1709922244119"></a>**具有挑战性的问题。重要的是所有参与者都同意-否则将被发送到错误的节点，而不是正确处理。分布式中的共识协议-但很难正确实现。**

<a name="c7dc-1709922373821"></a>**Zookeper分区分配改变时通知路由层保持最新信息。**

<a name="ne7u-1709922442881"></a>**LinkedIn的Espressor使用Heix进行集群管理(依靠Zookeeper）**

<a name="41cr-1709922584212"></a>**Hbase,SolrCloud 和kafka也是用Zookeeper来跟踪分区分配。**

<a name="kg5k-1709922347652"></a>**Cassandra  Riaks节点间使用留言协议gossip protocol来传播群集状态变化。请求发送任意节点，该节点转发到含有请求分区的节点。模型增加数据库节点的复杂性。但避免对Zookeeper这类外部协调服务的依赖**

<a name="uohs-1709922928889"></a>**Couchbash不会自动再平衡，简化了设计。moxi路由层。**

<a name="h26t-1709800460759"></a>**执行并行查询**

<a name="oj8k-1709923010027"></a>**大规模并行处理(MPP,massively parallel processing)-数仓**

<a name="7qvp-1708523954496"></a>**7.事务**

<a name="wk3n-1710172857428"></a>**简化故障失败的机制-强大的事务！！**

<a name="pzui-1710172844274"></a>**故障**

<a name="znoj-1710172848152"></a>**崩溃**

<a name="vovu-1710172885568"></a>**网络中断**

<a name="sxty-1710172894683"></a>**多线程/客户端写入覆盖**

<a name="hbqy-1710172933218"></a>**读取无意义中间态数据**

<a name="jlng-1710172974900"></a>**多线程/客户端竞争**

<a name="5vwc-1710172919264"></a><a name="rhog-1710172796700"></a>数据库软件、硬件可能在任意时刻发⽣故障（包括写操作进⾏到⼀半时）。 -回滚，原子性  undolog， 

<a name="hfad-1704983671342"></a>应⽤程序可能在任意时刻崩溃（包括⼀系列操作的中间）。                    -恢复(已提交的部分)，持久性redolog

<a name="3lnd-1704983671344"></a>⽹络中断可能会意外切断数据库与应⽤的连接，或数据库之间的连接。   

<a name="av8h-1704983671346"></a>多个客户端可能会同时写⼊数据库，覆盖彼此的更改。           -隔离性，锁 + mvcc（隐藏字段+版本链+readview），并发安全级别是串行化。

<a name="emwl-1704983671348"></a>客户端可能读取到⽆意义的数据，因为数据只更新了⼀部分。 -一致性  原子性+隔离性(并发访问安全问题)=原子操作 

<a name="wimr-1709303907049"></a>即单线程 Transaction 、 分布式式事务、或者x86 的cas操作(不加锁的方式)

<a name="cbjd-1708942581743"></a>   

<a name="nhvj-1704983671350"></a>客户之间的竞争条件可能导致令⼈惊讶的错误。

<a name="bhvp-1708940338863"></a>**原子操作-原子性(共同成功失败)且有隔离性(高并发下数据安全)才能保证数据一致性（符合预期，强一致性)** 

<a name="739h-1708940746090"></a>什么数据库缓存双写一致性，都是只考虑了高并发下数据接近一致，实际上不能避免短时间数据不一致的情况，除非保证原子操作，加入事务可简化问题。


<a name="rpud-1708940366352"></a><a name="offx-1708940363646"></a><a name="vo8p-1704983742288"></a>**事务（transaction）** ⼀直是简化这些问题的⾸选机制。整个事务要么成功（**提交（commit）**）要么失败（**中⽌（abort）**，**回滚（rollback）**）

<a name="pnng-1646310922957"></a>**简化应⽤编程模型  安全保证（safety guarantees）**

<a name="lyog-1646310871301"></a>深⼊**并发控制**的领域   如何实现**读已提交**，**快照隔离**和**可串⾏化**等隔离级别

<a name="58hv-1710167822460"></a>**.事务的棘手概念**

<a name="eae5-1710239842883"></a>第一个sql数据库：IBM System R 于1975年引用的事务风格

<a name="nfd5-1710239927223"></a>2000年以后，NoSQL开始普及。

<a name="yxrp-1710167867782"></a>**ACID的含义**

<a name="hryj-1710167943276"></a>**原子性atomicity**

<a name="v62c-1710173076601"></a>能够在错误时中⽌事务，丢弃该事务进⾏的所有写⼊变更的能⼒。** 或许 **可中⽌性（abortability）是更好的术语**

<a name="6b47-1705118743952"></a>要么全部成功，要么全部失败，简化系统复杂度， **避免“部分成功失败”等中间态复杂逻辑的修正**。

<a name="xlmq-1709304402238"></a>原子在不同分支代表不同。**多线程编程当中，原子操作包含了 原子性+隔离性，保证了数据一致性。**

<a name="9aal-1710167983379"></a>**一致性consistency**

<a name="dsf1-1710173128804"></a>**对数据的⼀组特定陈述必须始终成⽴**。即**不变量（invariants）**

<a name="jkse-1710173130714"></a>**—致性这个词重载的很厉害:**

<a name="k1fa-1708878764771"></a>在第5章中，我们讨论了副本数据一致性，以及异步复制系统中的**最终一致性问题**（参阅“复制延迟问题") 。

<a name="t3tg-1708878764773"></a>一致性散列(Consistency Hash)\_)是某些系统用于重新分区的一种分区方法。

<a name="iwwj-1708878795623"></a>在CAP定理中，一致性一词用于表示**可线性化 -** 指分布式系统在发生网络分区时的一致性保证。

<a name="uzzc-1708878764775"></a>在ACID的上下文中，一致性是指数据库在应用程序的特定概念中处于“良好状态" -要么全部成功，要么全部失败，保证数据一致性。

<a name="7nnu-1708878764777"></a>很不幸，这一个词就至少有四种不同的含义。但大多都可归为符合数据预期

<a name="ovbp-1709306759049"></a><a name="vfh3-1709306802566"></a>异步复制中的一致性和CAP理论中的一致性都属于弱一致性，事务中的一致性更强调数据严格的一致性。

<a name="ov0g-1709306808935"></a>- 数据符合预期、分布式事务借鉴CAP 和Base理论(弱一致性，柔性事务)。最终一致是数据符合分布式     

<a name="nvqd-1709305291223"></a>              事务预期

<a name="hzf3-1708881156903"></a>-黑马上的CAP：一致性-任意节点数据一致  可用性-访问任意健康节点不能中断拒绝服务  分区-容错 分布式网络必定中断必定会产生分区，分区后必须对外提供正常服务。     举例分区后中断的副本未同步不能提供服务则强一致，未同步能提供服务则为高可用。

<a name="gfkv-1710171645686"></a>**隔离性isolation**

<a name="znac-1710240177722"></a>并发问题（**竞争条件race conditions**）

<a name="7fbu-1710173195291"></a>**同时执⾏的事务是相互隔离的，快照隔离（snapshot isolation）** 的功能-MVCC，**这是⼀种⽐可序列化更弱的保证**【8,11】

<a name="7kja-1710171663168"></a>**持久性durability**

<a name="x5so-1710173216536"></a>硬件故障或数据库崩溃，写⼊的任何数据也不会丢失。

<a name="sesd-1646310817481"></a><a name="yi8z-1704985578742"></a>参考mysql的事务、MVCC及锁

<a name="rlxa-1705080720222"></a>**弱隔离级别**：读已提交，可重复读，序列化

<a name="2jhg-1705080777447"></a>并行事务非阻塞态，MVCC快照读

<a name="avnt-1705080821368"></a>比较并设置(CAS)

<a name="pblh-1710167919896"></a>**单对象与多对象操作**

<a name="42qx-1710250188446"></a>**违反隔离性：一个事务读取另一个事务未被执行的写入（脏读）**

<a name="daxd-1710250201202"></a> **原⼦性确保发⽣错误时，事务先前的任何写⼊都会被撤消，以避免状态不⼀致（all or nothing）**

<a name="7ymn-1710171710772"></a>**单对象写入**

<a name="h5aa-1710250215106"></a>**单对象写入崩溃，原子性通过日志实现恢复**

<a name="ihdr-1710250368749"></a>**原子操作：CAS也是流行的操作**

<a name="a1qj-1710250481310"></a>**事务通常被理解为：将多个对象上的多个操作合并为一个执行单元的机制**

<a name="afyc-1710171718578"></a>**多对象事务的需求**

<a name="t9gh-1710251706186"></a>**是否需要多对象事务？** 

<a name="9b6e-1710251739137"></a>**是否有可能只用键值模型和单对象来实现应用程序？**

<a name="ormg-1710250533532"></a> **关系型数据库：多表关联插入操作**

<a name="opfe-1710250566216"></a> **文档数据模型：多个字段常在同一个文档(被视为单个对象），缺乏连接功能的文档DB会鼓励非规范化(操作非规范化信息需要更新多个文档)。事务可防止非规范化数据不同步。**

<a name="syt6-1710251863622"></a> **二级索引的数据库中：一二级索引的同步更新**

<a name="ymgi-1710251891615"></a>**无原子性:复杂的错误处理**

<a name="ovhl-1710251918119"></a>**无隔离性：并发问题**

<a name="g5o1-1710171723084"></a>**处理错误和中止**

<a name="ygfp-1710251941752"></a>**···   ACID哲学：违反规则宁可放弃，不留半成品。**

<a name="0hze-1710252188073"></a>**无主复制则是尽力而为：数据库将做尽可能多的事。错误时不会撤销已经完成的事。-错误恢复是应用程序的责任。**

<a name="7mbo-1710252298563"></a>**Rails的ActiveRecord、Django这样的orm框架不会重试中断的事务。丢弃用户输入。**

<a name="p2mf-1710253466041"></a>**中止的重点应该是允许安全的重试。但它并不完美：**

<a name="lmfw-1710253530673"></a>**事务成功，网络故障可能导致执行两次。除非有额外应用级除重机制。**

<a name="nxyx-1710253675080"></a>**负载过大，重试将更槽糕。限制重试次数，指数退避算法。并单独处理和过载相关的错误**

<a name="njy9-1710253740189"></a>**仅在临时性错误才值得重试（死锁，异常，网络中断和切换）。发生永久性错误的重试是无意义的**

<a name="auy9-1710253799114"></a>**数据库外的副作用：重试每次重发电子邮件。不同系统事务。两阶段提交2PC.**

<a name="mtpo-1710253936214"></a> **客户端重试失效则丢失数据。**

<a name="jngf-1710167840980"></a>**.弱隔离级别**

<a name="wdhp-1710263089880"></a>**安全并行parallel：事务不触及相同数据**

<a name="ykgs-1710263216103"></a>**竞争条件：**

<a name="er05-1710263177909"></a>**读：事务读取另一个事务同时修改的数据**

<a name="pypw-1710263203957"></a>**写：事务同时修改相同的数据**

<a name="xps5-1710263234506"></a>**事务隔离：**

<a name="ghkk-1710263260640"></a>**可序列化(一次一个执行，没有任何并发)**

<a name="a876-1710263299289"></a>**性能损失**

<a name="nqm3-1710263313752"></a>**弱隔离级别(非串行化nonserializable)**

<a name="e7nl-1710263334073"></a>**较弱的隔离级别防止一部分，而非全部的并发问题**

<a name="2xxd-1710331395046"></a>**资金损失，耗费财务调查，财务数据请使用ACID数据库(注意：流行的数据库也使用弱隔离级别，不一定能防止并发错误)**

<a name="pjqb-1710171742279"></a>**读已提交**

<a name="7h42-1710171796899"></a>**没有脏读**

<a name="lyju-1710332135761"></a>**dirty reads：事务看到另一个事务未提交的值**

<a name="x8ch-1710333899846"></a>**为什么要防止dirty reads：**

<a name="pwpa-1710333902582"></a>**更新多对象：脏读以为只看到部分数据**

<a name="jcj0-1710333902583"></a>**事务中止：回滚后，看到的是未提交的数据**

<a name="3mi1-1710332238978"></a>**解决：只能读取提交后的数据，且不会阻塞，并行时保存已提交的旧值 -mvcc**

<a name="vmfl-1710171803833"></a>**没有脏写**

<a name="hvah-1710332040048"></a>**dirty write: 事务同时更新相同对象。后面的写入覆盖尚未提交的值。**

<a name="chr0-1710333916523"></a>**避免的问题：**

<a name="14wx-1710333919188"></a>**混乱写入，导致bob后买车先更新发票commit而alic先买车后更新发票commit(buyer=bob but recipient=alice)**

<a name="g1sw-1710332222649"></a>**解决：延迟/阻塞第二次的写入，直到第一次写入事务提交或终止。**

<a name="ujzx-1710333397576"></a>**但不能防止计数器增量的竞争状态。(读写非原子性，写依赖读的副本)**

<a name="ugiq-1710333641028"></a>**计数器增量安全：防止更新丢失 -版本号**

<a name="z96g-1710171821987"></a>**实现读已提交**

<a name="tays-1710333754461"></a>**默认的隔离级别：oracle,postgreSQL,sql server ,memSql**

<a name="svaf-1710333809593"></a>**行锁row-level lock**

<a name="fsbu-1710334081090"></a>**读写锁防止脏读：读写锁互斥，只有读锁拥有者可持有写锁。**

<a name="xj1j-1710334321006"></a>**缺点：阻塞，性能损失。**

<a name="7klj-1710334353854"></a>**优化：所以一般用mvcc的模式。-或者copy on write**

<a name="bww4-1710171760070"></a>**快照隔离和可重复读**

<a name="wjut-1710343195467"></a>**不可重复读nonrepeatable read/读取偏差read skew**

<a name="jmuu-1710343248537"></a>**skew重载：在热点指的是不平衡，这里指异常时机  alice两个账号各500，alice先读acount1=500,转账员将acount1+100,acount2-100后commit，alice读acount2=400.commit.导致Alice看起来少了100。-暂时不一致。**

<a name="gwgf-1710343469620"></a>**提交后，刷新网页即可。有些情况不能容忍暂时不一致：**

<a name="m0km-1710345572560"></a>**备份：数据库备份需要几小时，期间接收写入包含新老数据。如果备份用于恢复，不一致就变成永久的了。-解决：全局锁/快照备份**

<a name="i5pt-1710345666724"></a>**分析查询和完整性检查：扫描大部分数据库，查询在不同时间点观察数据库产生不同，可能返回无意义的结果。**

<a name="p7tm-1710345899708"></a> **快照隔离snapshot isolation 对长时间运行的只读查询非常有用（备份和分析）。**

<a name="q8oz-1710345935366"></a> **即 一致快照consistent snapshot,即使被另一个事务更改，每个事务只能看到该特定时间的旧数据（特定时间点冻结的一致快照）。**

<a name="mo1i-1710346175801"></a>**PostgerSQL, mysql innoDB, Oracle, sqlServer**

<a name="2hpt-1710171981487"></a>**实现快照隔离**

<a name="49s0-1710346236063"></a>**关键原则：读不阻塞写，写不阻塞读。两者没有任何锁定争用。**

<a name="w8v8-1710346319154"></a>**多版本并发控制mvcc,multi-version concurrentcy contorl**

<a name="fh82-1710346453757"></a>**读已提交不提供快照隔离，保留对象的一两个版本就足够。通常支持快照隔离也是用mvcc来实现读已提交隔离级别：**

<a name="3xbw-1710346540026"></a>**读已提交为每个查询使用单独的快照-每个select单独生成。**

<a name="xqhm-1710346554737"></a>**快照隔离对整个事务使用相同的快照-复用第一个select生成的快照**

<a name="pmk8-1710351883488"></a>**update操作在内部翻译为Delete 和 insert**

<a name="vnfd-1710351911457"></a>**-innoDB实际上delete将旧数据版本移到undolog版本链中。垃圾收集会删除任何事务不可见的就对象版本。**

<a name="box0-1710171988275"></a>**观察一致性快照的可见性规则**

<a name="yapf-1710408915465"></a>**从来不更新值，而是每次值改变时创建一个新版本。使得数据库提供一致快照产生的开销很小。**

<a name="ecrk-1710408160769"></a>**事务id决定它可以看到哪些对象，规则如下：**

<a name="ogtp-1710408539120"></a>**事务开始时列出当时所有事务清单，即使之后提交，这些事务的写入也都会被忽略。**

<a name="unjc-1710408595672"></a>**忽略被中止事务任何写入**

<a name="ofbz-1710408626209"></a>**较晚(当前事务之后开始)的写入都被忽略，不管是否提交**

<a name="hgwi-1710408682423"></a>**所有其他写入，对应用都是可见的。**

<a name="rg1c-1710408738736"></a>**对象可见的两条规则**

<a name="weyp-1710408754844"></a>**读事务开始时，创建该对象的事务已提交。**

<a name="xqky-1710408773006"></a>**请求删除的事务在读事务开始时未提交。**

<a name="ai77-1710171999516"></a>**索引和快照隔离(索引如何在多版本数据库中工作)**

<a name="kanl-1710410047690"></a>**同一对象不同版本放在同一个页面中，PostgreSQL的优化可以避免更新索引**

<a name="yv2q-1710410120895"></a>**仅追加/写时拷贝apeend-only/copy-on-wirte的变体B树：更新不覆盖树的页面，为每个修改页创建副本。**

<a name="etza-1710410471666"></a>**每个写入事务/一批事务都会创建一个新的B树，当创建时，从该特定树根生长的树就是数据库的一个一致性快照。**

<a name="79xv-1710410561061"></a>**需要负责压缩和垃圾收集的后台进程。**

<a name="xr4f-1710172004472"></a>**可重复读与命名混淆**

<a name="nohd-1710417835613"></a>**原因：System R定义隔离级别时并未有快照隔离**

<a name="uwdp-1710417928621"></a>**oracle DB2 称为序列化**

<a name="f5te-1710417946615"></a>**postgreSql mySql称为可重复读**

<a name="e9wg-1710171770800"></a>**防止丢失更新**

<a name="ajmt-1710418075399"></a>**脏写导致丢失更新lost update**

<a name="c7rv-1710418271703"></a>**读取-修改-写入序列的狠揍clobber：第二个事务并没有包括第一个事务的修改: -写依赖读**

<a name="uvoq-1710418375497"></a>**增加计数器或更新账户余额(需读取当前值，计算新值并写回更新后的值)**

<a name="ro12-1710418458493"></a>**进行本地修改： 解析文档，更改后回写修改的文档**

<a name="9n83-1710418515773"></a>**同时编辑wiki页面：整个页面覆盖当前内容。**

<a name="lftw-1710172034957"></a>**原子写(x排它锁)**

<a name="6jim-1710418574114"></a>**数据库原子更新操作保证并发安全**

<a name="dxgy-1710419672127"></a>**mysql: 行级写锁**

<a name="bqxj-1710419591972"></a>**MongoDB：对JSON文档一部分进行本地修改的原子操作**

<a name="wxju-1710419646040"></a>**redis提供了优先队列等修改数据的原子操作。**

<a name="h0ip-1710421887552"></a>**原子操作/游标稳定性cursor stability：通常在读取对象时获取其上的排它锁，以便提交前没有事务可以读取它。另一个选择是将所有原子操作在单一线程上执行。-redis**

<a name="6hwo-1710422121598"></a>**unfortunately,ORM框架易执行读取-修改-写入序列，而不是使用数据库提供的原子操作。如果你知道自己在做什么那当然不是问题**

<a name="vysa-1710172041914"></a>**显式锁定(for update：读-改-写序列)**

<a name="oknq-1710422501689"></a>**让应用程序显示锁定更新的对象，直到一个读取-修改-写入序列完成**

<a name="89ij-1710422624973"></a>**select ..... for update;**

<a name="50q1-1710422845671"></a>**--更新先前select 返回棋子的位置。**

<a name="rmgw-1710422637550"></a> **update**

<a name="euv5-1710422671170"></a>**for update-对返回的所有行加锁，忘记加锁很容易引入竞争条件(同时修改)**

<a name="jpu5-1710172058032"></a>**自动检测丢失的更新(管理器检测处理并发问题)**

<a name="8ytj-1710423161566"></a>**允许并行执行，事务管理器检测到丢失更新，中止事务并强制重试读-改-写序列。**

<a name="w9el-1710423029153"></a>**Oracle可串行化(快照隔离)和sqlServer的快照隔离级别会自动检测到丢失更新，中止惹麻烦的事务。一些作者认为能防止丢失更新才算提供快照隔离。这个定义下，mysql不算提供快照隔离**

<a name="qg6e-1710423330067"></a>**优点：是一个很好的功能，不需要应用代码使用任何特殊数据库功能。允许你忘记加锁或原子操作，由管理器检测丢失更新。**

<a name="ftwe-1710172063360"></a>**比较并设置(CAS)**

<a name="os3h-1710424617661"></a>**不提供事务的数据库中的原子操作：比较并设置（CAS compare and set）**

<a name="hlfh-1710425612756"></a>**update table set content='new content' where id=123 and content = 'old content'  必要时重试**

<a name="rxcv-1710425806449"></a>**问题：数据库允许where子句从旧快照读取，此语句无法防止丢失更新。即另一个并发写入，where条件也为真。-非当前读或非原子写。**

<a name="zss4-1710425865867"></a>**解决：检查数据库的CAS是否安全。保证比较交换为当前读且写是否加锁/原子写**

<a name="bvrp-1710172079412"></a>**冲突解决与复制(多个数据库副本的并发)**

<a name="ewf7-1710434904534"></a>**基于锁和cas操作不适用于多个数据库副本**

<a name="8dx4-1710434970886"></a>**如检测并发写入：允许并发吸入创建多个冲突版本(也称兄弟），应用代码或特殊数据结构在发生之后解决合并这些版本。**

<a name="gl8j-1710435048968"></a>**原子操作可在复制的上下文中很好工作，尤其具有可交换性时。Riak2.0不同客户端同时更新一个值是，Riak将自动更新合并在一起，以免丢失更新。防止复制副本丢失更新。**

<a name="gdtn-1710435259414"></a>**最后写入LWW解决冲突很容易丢失更新。unfortunately,许多复制数据库默认LWW。**

<a name="rkev-1710172453385"></a>**写入偏差与幻读（两个事务更新两个不同的对象）**

<a name="itfd-1710436127298"></a>**select count(\*) where oncall=true....alice 和 bob分别查在职医生人数**

<a name="leam-1710436160580"></a>**update...set oncall=false 然后将自己的记录更新为请假，违反至少一医生在职。**

<a name="ovid-1710172462835"></a>**写偏差的特征**

<a name="iedp-1710437034438"></a>**特征：涉及多个对象，单对象的原子操作不起作用**

<a name="wszw-1710437034814"></a>**快照隔离实现中，自动检测丢失更新对此无帮助。postgred,innodb的可重复读，oracle序列化或sql server的快照隔离级别中，都不会自动检测写入偏差。写入偏差需要真正的可序列隔离-业务上的问题。**

<a name="hn04-1710437034815"></a>**数据库配置约束，指定至少一个值为true.大多数不支持这种配置，可以使用触发器或者物化视图实现。**

<a name="crrt-1710437034816"></a>**显示锁定。 select ...fro update -锁定返回的所有行，锁定两个医生（行锁+间隙锁）**

<a name="4jr1-1710172470885"></a>**写偏差的更多例子**

<a name="0hyt-1710437389755"></a>**读数据为空，分别插入一条数据的会议室预定系统：select count(\*) from bookings where roomid=123 and time...，insert into bookings....不能防止另一个用户插入冲突会议。解决：又需要串行化执行。**

<a name="pgcb-1710437636980"></a>**多人游戏：棋盘用锁防止丢失更新，但锁定不能妨碍将不同的棋子放在相同位置。产生写入偏差 。解决：使用唯一约束。**

<a name="bwel-1710437042998"></a>**抢注用户名：和会议系统一样。不过唯一性约束可以解决该问题。**

<a name="ogt8-1710438166946"></a>**防止双重开支；用户花钱和积分服务，检查支付数不超过余额，有了写入偏差，可能会发生两个支出项目同时插入，导致余额变为负值，两个事务都不会注意到另一个。**

<a name="8gty-1710172478550"></a>**导致写入偏差的幻读**

<a name="tw0y-1710438423955"></a>**所有以上例子都遵循类似的模式**

<a name="bngi-1710438445792"></a>**Select查询符合条件的行，至少两名医生值班；不存在该会议室同一时段的预定；棋盘位置未被占据；用户未被抢注；账户还有足够余额**

<a name="l6p0-1710438590471"></a>**按照第一个查询的结果，应用代码决定是否继续**

<a name="qt10-1710438739456"></a>**应用决定继续操作，执行写入(插入更新删除），并提交事务**

<a name="cdmo-1710438899441"></a>**步骤3修改的行，是步骤1中返回的行之一，可以使用select for update来使事务安全避免写入偏差.**

<a name="caet-1710439501945"></a>**但检查是否不存在满足条件行，写入添加一个匹配相同条件的行。如果步骤1中的查询没有返回任何**

<a name="bsm5-1739288894816"></a>**⾏，则 SELECT FOR UPDATE 锁不了任何东⻄（读已提交） 。PS:innodb可重复读读null数据会加间隙锁，不走索引则锁表。**

<a name="cwgh-1710440241091"></a>       **这种效应：一个事务中的写入改变另一个事务的搜索查询结果，被称为幻读。快照隔离避免了只读查询中的幻读。以上的读写事务中，幻影会导致特别棘手的写歪斜情况。**

<a name="1cjy-1710172485201"></a>**物化冲突**

<a name="fv3x-1710440426895"></a>**物化冲突：将幻读变为数据库中一组具体行上的锁冲突。**

<a name="laff-1710440634993"></a>**通过创建时间槽和房间的表，提前出入房间和时间的所有可能组合。创建预定的事务可以select for update锁定房间和时间段对应的行，在获得锁定后，可以检查重叠的预定并插入新的预定。该表不是存储预定相关的信息，它完全就是一组锁，用于防止同时修改同一房间和时间范围内的预定。**

<a name="dngy-1710441936216"></a>**缺点：弄清除如何物化冲突可能很难，也很容易出错，而让并发控制机制泄露到应用数据模型是很丑陋的做法。**

<a name="i0he-1710441997817"></a>**物化冲突应为最后的手段。可序列化Serializeble级别是更可取的。**

<a name="di29-1710167844061"></a>**.可序列化**

<a name="ztac-1710587737356"></a>**弱隔离级别读已提交和快照隔离不能解决写入偏差幻读：**

<a name="ky3h-1710588699885"></a>**隔离级别难以理解，且不同数据库中实现不一致，可重复读概念不一样**

<a name="tpbs-1710588738858"></a>**光检查应用代码很难判定在特定隔离界别是否安全**

<a name="jp98-1710588779920"></a>**无检测竞争条件的好工具，往往倒霉时才会出现问题。**

<a name="sqvc-1710588820273"></a>**20世纪70年代system R就已经是这样，研究人员的答案都很简单：可序列化（serializeble）级别（但非人见人爱），都使用三种技术之一。**

<a name="mqa4-1710589545518"></a>**字面意义上的串行顺序执行事务**

<a name="neot-1710589568078"></a>**两相锁定2PL two-phase locking,几十年来唯一的可行选择**

<a name="pizj-1710589721553"></a>**乐观并发控制，可序列话的快照隔离serializable snapshot isolation**

<a name="2oi3-1710172506817"></a>**真的串行执行(单线程执行事务)**

<a name="o5af-1710589822067"></a>**数据库设计人员07年才确定，单线程循环执行事务时可行的。（多线程过去30年中被认为是获得良好性能的关键所在）**

<a name="phuh-1710609564138"></a>**两个进展引发了这个反思：**

<a name="owi7-1710609747624"></a>**RAM足够便宜，许多场景可以将完整的活跃数据保存在内存中。-redis**

<a name="vhy4-1710609817752"></a>**数据库设计人员意识到OLTP事务很短，只进行少量的读写操作。长时间的分析查询通常是只读的，可以用一致快照（快照隔离）上运行。**

<a name="xcax-1710609934885"></a>**VoltDB/H-Store, Redis 和 Datomic中实现。避免锁的协调开销。吞吐量仅限单个cpu**

<a name="xh4n-1710172519134"></a>**在存储过程中封装事务(优化交互式单线程事务)**

<a name="xthc-1710757083497"></a>**数据库设计者认为，机票全流程是一个事务，可以被原子化执行。缺点：交互式会使流程性能直接下降。**

<a name="oo8b-1710757291600"></a>**解决：单线程串行执行事务的系统不允许交互式的多语句事务。提前将整个事务作为存储过程提交数据库：**

<a name="9fzd-1710757436562"></a>**Interactive transaction :bob医生请假 1.select count  2.if count>=2 3.update false**

<a name="gegl-1710763202697"></a>**stored procedure: execute stored take doctor of call**

<a name="t47s-1710763179337"></a>**事务所需的数据都在内存中，快速执行，无需等待网络和磁盘IO**

<a name="7ksv-1710172529258"></a>**存储过程的优点和缺点**

<a name="jfoa-1710763413471"></a>**名声不好：**

<a name="4qhf-1710763421594"></a>**陈旧丑陋无库生态，数据库存储过程各自的语言没跟上通用编程语言的发展**

<a name="96la-1710763483936"></a>**管理困难，调试困难，版本控制测试部署困难，和监控指标的系统集成困难**

<a name="idii-1710763602399"></a>**单个数据库通常由多个应用共享，写得不好的存储过程（占用大量内存和cpu）会比代码造成更大麻烦**

<a name="1w0a-1710763899035"></a> **这些问题都可以克服。现代存储过程放弃了PL/SQL,使用现有通用编程语言：VoltDB使用java或Groovy, Datomic使用Java或Clojure, Redis使用Lua.**

<a name="bp68-1710767504595"></a>**存储过程与内存存储，使得单线程执行事务可行，**

<a name="ahfz-1710767568244"></a>**无需等待I/O,**

<a name="mfvt-1710767570930"></a>**避免并发控制机制的开销，可以在单线程实现相当好吞吐量**

<a name="7m1p-1710767621202"></a>**VoltDB还用存储过程进行复制，在每个节点上执行相同的存储过程，所以要求存储过程是确定性的。比如使用当前日期，需要通过特殊的确定性API实现。**

<a name="xxtp-1710172539181"></a>**分区**

<a name="rqu5-1710767939361"></a>**顺序执行事务使并发控制简单多，但吞吐限制为单机单核。吞吐量高的应用，单线程将可能成为严重瓶颈。**

<a name="puih-1710768082742"></a>**扩展多核多节点，可以对数据进行分区，每个事务只需在单个分区中读写数据，事务吞度量就可以与cpu保持现行扩展。**

<a name="jpiw-1710768164695"></a>**对于需要访问多个分区的任务事务，需要进行协调，存储过程跨所有分区锁定执行，保证串行。**

<a name="fgu3-1710768218238"></a>**缺点：协调开销性能比单区事务慢得多。VoltDB吞吐量每秒1000个跨分区写入，比单分区低几个数量级，且通过增加机器来提高**

<a name="8lf4-1710768407791"></a>**事务是否可划分-应用的数据结构，键值数据，多个二级索的数据引需要大量跨分区协调。**

<a name="zyih-1710172540516"></a>**串行执行小结**

<a name="dibg-1710768638498"></a>**需每个事务小而快，一个缓慢的事务拖慢所有事务。**

<a name="22nq-1710768681244"></a>**可放入内存仅限活跃数据集，少量数据会移动到磁盘。但需要访问执行中的事务，系统会变慢。**

<a name="jmsk-1710768781527"></a>**写入吞吐量必须低到能在单个cpu运行，否则事务能划分至但分区，且无需分区协调**

<a name="wlnd-1710769060180"></a>**跨分区事务使用程度受限。**

<a name="uhxa-1710172558745"></a>**两阶段锁定（2PL）**

<a name="nhdj-1710769248115"></a>**30年高使用的序列化算法：两阶段锁定2PL two phase locking ,独占访问exclusive access:**

<a name="khdp-1710769659952"></a>**事务A读取对象，阻塞B写入，直至A提交；**

<a name="elpw-1710769685611"></a>**事务A写入对象，阻塞B读取,直至A提交；**

<a name="6ja2-1710769959539"></a>**快照隔离使得不会阻塞读，2PL提高序列化性质，解决丢失更新和写入偏差。**

<a name="lfuv-1710172605096"></a>**实现两阶段锁**

<a name="8oif-1710770052594"></a>**2PL即innoDB可序列化级别及DB2可重复读隔离级别。**

<a name="6wad-1710770158675"></a>**读写阻塞为每个对象添加锁。共享模式shared mode 与独占模式exclusive mode:**

<a name="1dyc-1710770195788"></a>**读取对象需以共享模式获取锁。读共享**

<a name="bshw-1710770251530"></a>**写入需独占模式取锁。写互斥。**

<a name="r0b0-1711207524774"></a>**事务获得锁必须持有锁知道事务结束(提交或中止)。即一阶段获取锁，二阶段释放所有锁。**

<a name="iuyh-1710770211133"></a>**死锁deadlock, 数据库会自动检测死锁，并中止其中一个。被中止的事务充实需应用程序实现。**

<a name="qi7j-1710172616303"></a>**两阶段锁定的性能**

<a name="vz0p-1711207837446"></a>**比弱隔离差得多**

<a name="ienx-1711207878742"></a>**锁开销、串行并发性降低**

<a name="z85f-1711207913718"></a>**交互式事务形成等待队列、高百分位响应慢**

<a name="kmkr-1711207799940"></a>**死锁频繁时重试造成浪费**

<a name="ccq8-1710172621528"></a>**谓词锁predicate lock**

<a name="kfpi-1711208306292"></a>**谓词锁：属于符合搜索条件的对象，解决幻读phantoms**

<a name="6dqd-1711208459688"></a>**事务A获取共享谓词锁shared-mode predicate lock读取匹配对象，与排它互斥**

<a name="p3er-1711208588906"></a>**事务A写入需等待其他事务谓词锁释放。**

<a name="bdwj-1711208433268"></a>**适用于尚不存在，将可能添加的对象（幻象），如果两阶段包含谓词锁，可实现串行化。**

<a name="zv5c-1710172626404"></a>**索引范围锁next-key lock**

<a name="a3ce-1711208973949"></a>**谓词锁性能不佳：活跃事务持锁多，检查匹配非常耗时**

<a name="ayfb-1711209059199"></a>**2PL采用索引范围锁-简化版谓词锁：**

<a name="qmbu-1711212311152"></a>**索引位于roomid, 指示room123用于预定**

<a name="ajbo-1711212362665"></a>**或者索引位于时间上，指示12:00~13:00用于预定。**

<a name="k1ie-1711212755816"></a>**以上任何一条件，当另一个事务想写入时，需要更新索引-叶子节点，会收到共享锁。解决幻读和写入偏差**

<a name="6lzs-1711212829915"></a>**索引范围锁不如谓词锁精确，但开销低**

<a name="bofb-1711212877091"></a>**无可挂载索引，将退化为表锁，性能不利，但这是回退到一个安全位置。**

<a name="slwa-1710172573367"></a>**序列化快照隔离SSI（高性能序列化算法）**

<a name="lnci-1711213123166"></a>**新算法：可序列化快照隔离SSI serializeble snapshot isolation 仅与快照隔离有很小性能损失. 08年 micheal cahill博士论文。**

<a name="weo0-1711213307841"></a>**用于单节点PostgreSQL9.1后序列化和分布式数据库**

<a name="ue1s-1711213377985"></a>**处于实践证明阶段**

<a name="yq9i-1710172639651"></a>**悲观pessimistic与乐观optimistic的并发控制**

<a name="54jr-1711213690005"></a>**极致悲观：串行排它锁**

<a name="bjxf-1711213769533"></a>**序列化快照隔离SSI是乐观技术：** 

<a name="mefw-1711213819265"></a>**缺点：多事务争用contention时性能不佳，大部分事务中止，吞吐量极限下有重试机制将使性能变差。**

<a name="nk1s-1711213915330"></a>**优点：有备用容量，竞争不高场景比悲观好，可交换的原子操作可减少争用。**

<a name="snvf-1711214019984"></a>**SSI在快照隔离基础上添加算法检测写入的序列化冲突，并决定中止哪些事务。**

<a name="9lgw-1710172651041"></a>**基于过时前提的决策**

<a name="td4m-1711214184809"></a>**医生值班读取-修改-写入。数据库检测过时并终止：**

<a name="t08a-1711215992016"></a>**检测对旧MVCC对象版本的读取(读之前存在未提交的写入)**

<a name="aego-1711216030637"></a>**检测影响先前读取的写入（读之后发生写入）**

<a name="5smj-1710172660675"></a>**检测旧MVCC读取**

<a name="z7u2-1711216050316"></a>**事务提交时，检测是否有被忽略的写入已被提交。**

<a name="afqq-1711216243096"></a>**SSI支持一致快照中长时间运行的读取-仅在提交时中止检测的陈旧读取。因为只读不产生幻读和写入偏差风险**

<a name="mvok-1710172671381"></a>**检测影响之前读取的写入**

<a name="mo5j-1711216452745"></a>**事务写入提交时，在索引中查找最近读取受影响的其他事务，通知读取的事务非最新。并中止未提交写入的其他事务。**

<a name="0sq6-1710172685702"></a>**可序列化的快照隔离的性能**

<a name="g2eg-1711216636788"></a>**粒度granularity，精准哪些事务需要中止，但簿记开销显著。**

<a name="ux2m-1711216812849"></a>**简略的跟踪速度快（粗粒度），但导致不必要的事务中止。**

<a name="jzqb-1711216700614"></a>**相比2PL, 不需要锁定阻塞，读性能高**

<a name="qm51-1710756953994"></a>**相比串行化，可扩展多台机器提高吞吐量，可跨分区读。**

<a name="wvsk-1711216911828"></a>**SSI要求事务尽量短，避免长事务发生冲突中止。慢事务SSI比2PL或串行执行更不敏感**

<a name="enui-1704985776096"></a>**8.分布式系统的麻烦**

<a name="e2bp-1711387736669"></a>**前几章failover故障切换, 复制延迟 与事务控制 处理各种可能发生的边缘情况，本章则是彻底的悲观总结。**

<a name="4yaw-1711386647072"></a>**故障与部分失效**

<a name="9d0g-1711387883443"></a>**部分失效partial failure  不确定性的nondeterministic: IDC配电单元故障**

<a name="w7ln-1711386736921"></a>**云计算与超级计算机**

<a name="ynhs-1711386665148"></a>**不可靠的网络(Timeout)**

<a name="fav6-1711388032544"></a>**请求丢失： 拔网线**

<a name="znsf-1711388048086"></a>**请求排队：**

<a name="gmdu-1711388084834"></a>**请求失效：**

<a name="dssu-1711388054944"></a>**.....**

<a name="y933-1711387087536"></a>**真实世界的网络故障**

<a name="aywv-1711387099045"></a>**检测故障**

<a name="z4hi-1711387103669"></a>**超时与无穷的延迟**

<a name="qs2e-1711388153448"></a>**级联失效cascading failure**

<a name="gttn-1711387323883"></a>**网络拥塞和排队**

<a name="v9f2-1711388199023"></a>**TCP执行流量控制flow control**

<a name="up7k-1711389082773"></a>**视频、语音会议使用UDP，折中丢包与流畅**

<a name="t56p-1711387113980"></a>**同步网络vs异步网络**

<a name="fmrl-1711389283437"></a>**有限延迟bounded delay：同步网络，不收排队影响**

<a name="bwvp-1711387335617"></a>**我们不能简单地使用网络延迟可预测吗**

<a name="l3p1-1711386676597"></a>**不可靠的时钟**

<a name="faqp-1711469591901"></a>**机器的时钟：硬件设备，石英振荡器，**

<a name="xtjc-1711469629964"></a>**不是完全准确的。**

<a name="knwp-1711469656643"></a>**同步时钟：网络时间协议NTP**

<a name="pfpq-1711469689783"></a>**服务器从精确时间源获取时间-GPS接收器**

<a name="qoxv-1711387218692"></a>**单调钟与时钟**

<a name="wu2k-1711387376627"></a>**时钟**

<a name="obwb-1711469781129"></a>**Linux: clock\_gettime(CLOCK\_REALTIME)**

<a name="uxdp-1711469821742"></a>**java:system.currentTimeMilis**

<a name="gwyx-1711469840905"></a>**通常与NTP同步，但举例NTP服务器太远，则可能被强制重置(及时跳回）**

<a name="hl1a-1711387385739"></a>**单调钟**

<a name="uzaz-1711470052827"></a>**保证总是前进**

<a name="tbmn-1711469988760"></a>**Linux:CLOCK\_MONOTONIC**

<a name="fb70-1711470014393"></a>**java:System.nanoTime**

<a name="sn42-1711470028035"></a>**调整频率：NTP检测到计算机石英钟更快或更慢，则调整单调钟频率（偏移skewing时钟）.**

<a name="ct3v-1711470667953"></a>**不假定不同节点时钟存在同步：分布式系统用单调钟效果好，对测量的不准确不敏感**

<a name="a7gy-1711387238026"></a>**时钟同步与准确性**

<a name="pbyu-1711470750697"></a>**漂移drifts: 计算机石英钟不准确原因,取决机器温度。**

<a name="kgdy-1711470917769"></a>**实现精确度：GPS接收机，精确时间协议PTP**

<a name="kgez-1711470944635"></a>**同步错误的原因：NTP守护进程配置错误，防火墙阻止NTP通信。**

<a name="vo0i-1711387245745"></a>**依赖同步时钟**

<a name="zm2f-1711471000801"></a>**使用需要同步时钟的软件需监测所有机器间的时钟偏移**

<a name="fnxq-1711387475761"></a>**有序事件的时间戳**

<a name="n1pp-1711471283186"></a>**写入排序问题：B客户端写入比A晚但具有更早的时间戳。** 

<a name="50kp-1711471399605"></a> **最后写入为准LWW**

<a name="axgx-1711471482711"></a> **版本向量**

<a name="ofpq-1711387431462"></a>**时钟读数存在置信区间**

<a name="aihs-1711471513794"></a> **置信区间的不确定性：NTP服务器的不去定性，加上服务器网络往返时间**

<a name="aave-1711471693187"></a>**当clock\_gettime()返回值不会告诉你预期错误，不知道置信区间是5毫秒还是5年**

<a name="znqm-1711471741654"></a>**例外：Spanner Google TureTime API明确报告本地时钟置信区间（最早，最晚）。**

<a name="bfz6-1711387449885"></a>**全局快照的同步时钟**

<a name="dpco-1711471815493"></a>**分布式的事务快照隔离，分布式事务ID时序成为站不住脚瓶颈**

<a name="2ihe-1711471939317"></a>**Spanner通过置信区间来比较A,B发生的时序。**

<a name="9qfk-1711471991096"></a>**分布式事务语义使用时钟同步是一个活跃的研究领域，没有在谷歌之外的主流数据库中实现。**

<a name="3mnj-1711387250438"></a>**暂停进程**

<a name="ui0e-1711472636558"></a>**如何确保分布式主节点仍未领导者**

<a name="yh9a-1711472775035"></a>**方式一：从其他节点获得租约lease, 类似一个带超时的锁，周期性过期前续约。-和redison续约类似**

<a name="kqwv-1711472837428"></a>**过期时，由另一个节点接管。**

while(true){

` `request=getIncomingRequest();

` `// 确保租约还剩下⾄少10秒

` `if (lease.expiryTimeMillis-System.currentTimeMillis()< 10000){

` `lease = lease.renew();

` `}

` `if(lease.isValid()){

` `process(request);

` `}}

<a name="nmd5-1711472763779"></a>}

<a name="gi5a-1711473874947"></a>**缺点：依赖同步时钟**

<a name="93uw-1711473992955"></a>**意外的时间停顿：**

<a name="7kp7-1711474017909"></a>**stop-the-world  HotSpot GC**

<a name="6ejp-1711474059672"></a>**suspend虚拟机**

<a name="92se-1711474080346"></a>**随意暂停恢复：关闭笔记本盖子**

<a name="tfxw-1711474128862"></a>**窃取时间steal time:虚拟机切换或cpu上下文切换，在其他机器中花费的时间.**

<a name="7jwg-1711474280466"></a>**同步时的阻塞io：java惰性加载类文件；磁盘为网络文件系统或网络块设备-亚马逊EBS**

<a name="kvsa-1711474441136"></a>**磁盘交换内存抖动thrashing: 允许交换到磁盘（分页），内存访问可能导致页面错误page fault .话费大量时间将页面交换到内存，实际完成的工作很少thrashing。 服务器机器禁用页面调度，干掉进程释放内存。**

<a name="ocvk-1711474648160"></a>**SIGSTOP暂停unix进程:Ctrl-Z立即阻止进程的CPU周期**

<a name="t1w7-1711474768157"></a>**这些都可以随时抢占preempt正在运行的线程。**

<a name="cirf-1711473855327"></a>**响应时间保证**

<a name="r1ji-1711474887529"></a>**硬实时hard real-time系统: 不满足特定截止时间deadline可能会导致整个系统故障。**

<a name="pgjw-1711475001376"></a>**嵌入式系统精心设计和测试：安全气囊不会因系统GC暂停弹出。**

<a name="urp5-1711475089330"></a>**大量的额外工作，昂贵。**

<a name="i1wt-1711387521748"></a>**限制垃圾收集的影响**

<a name="oxal-1711475134772"></a>**通知GC暂停，停止接收新请求-对延迟敏感的金融系统**

<a name="ho3v-1711475217820"></a>**变种：GC只收集新生代，积累老年代，一次重启一个节点，类似滚动升级。**

<a name="ujyf-1711386681865"></a>**知识、真相与谎言**

<a name="hdwi-1711387268312"></a>**真理由多数所定义**

<a name="rxcy-1711561420884"></a>**stop the world 一分钟，被其他节点宣告死亡，重新选举。**

<a name="3zea-1711387542106"></a>**领导者与锁定**

<a name="b6am-1711561462773"></a>**数据库分区领导者只能有一个节点：避免脑裂**

<a name="3ynw-1711561525662"></a>**特定资源的锁和对象只允许一个事务/客户端持有**

<a name="hqa3-1711561556083"></a>**用户唯一标识**

<a name="rv2w-1711561875596"></a>**节点认为它是天选者the choosen one**

<a name="gu25-1711561617808"></a>**HBase例子：分布式锁的实现不正确，客户端1持有锁stop the world导致lease超时,客户端2获得锁进行处理，客户端1仍认为它具有有效的租约，即使它已经过期，从而破坏了存储的文件。**

<a name="mhlf-1711387550649"></a>**防护令牌**

<a name="gw5w-1711561950975"></a>**解决天选者问题：防护fencing**

<a name="vi5w-1711562021406"></a>**fencing token :只允许增加屏蔽令牌的顺序进行写操作。**

<a name="2yxl-1711562140276"></a>**服务器端检查token,获取锁时token增加33+1，存储服务器记录更高令牌34的写入，拒绝令牌33的请求。-一般是redisson续期，这个更像乐观锁。**

<a name="e6n2-1711562077138"></a>**ZooKeeper将事务标识zxid和节点版本conersion用作屏蔽令牌。保证了单调递增**

<a name="uujk-1711564755459"></a>**如文件存储服务器可将令牌卸载文件命中**

<a name="bsay-1711387279845"></a>**拜占庭故障**

<a name="id0b-1711628556885"></a>**拜占庭故障Byzantine fault: 在不信任的环境中达成共识的问题称为拜占庭将军问题。**

<a name="lxw6-1711628612728"></a>**拜占庭将军问题：n位将军需要同意，一些叛徒通过发送虚假或不真实信息来混淆欺骗他人。**

<a name="lpn6-1711628716132"></a>**拜占庭容错：系统在部分节点发生故障、不遵守协议，恶意攻击，扰乱网络时仍能继续正确工作：**

<a name="py6z-1711638469892"></a>**航空航天环境计算机被辐射破坏，不可预知方式响应其他节点**

<a name="csli-1711638605446"></a>**多个参与组织系统中，参与者试图欺骗他人。比特币等区块链对等网络让互不信任的各方同意交易不依赖中央当局。**

<a name="f38o-1711387557457"></a>**弱谎言形式**

<a name="eepx-1711638744038"></a>**添加防止撒谎弱形式机制；**

<a name="yseh-1711638821915"></a>**校验和防止数据包被破坏**

<a name="2a8h-1711638847924"></a>**公开访问的系统需仔细清理来自用户的任何输入**

<a name="zcdt-1711638888096"></a>**NTP多数对时间范围达成一致，配置错误的服务器将被排除**

<a name="x4lu-1711387293192"></a>**系统模型与实现**

<a name="iyps-1711639179162"></a>**定时假设三种系统模型：**

<a name="pgo0-1711640511485"></a>**同步模型synchronous model: 网络延迟，暂停和时钟漂移不会超过某个固定上限；**

<a name="h1x4-1711640383000"></a>**部分同步模型partial synchronous：大多数情况像一个同步系统一样运行，有时出现超时，进程暂停和时钟漂移界限**

<a name="vkkn-1711640459345"></a>**异步模型：一个算法不允许对实际做任何假设，事实上它甚至没有时钟。**

<a name="lg5f-1711640536166"></a>**节点系统模型：-节点失效问题**

<a name="ahco-1711640498506"></a>**崩溃停止crash-stop:只能由崩溃失效，且永远不会回来。**

<a name="35nl-1711640632666"></a>**崩溃恢复crash-recovery: 具有稳定存储（非易失性磁盘），崩溃中保留，内存中状态会丢失-innodb三阶段提交**

<a name="rpmc-1711640822813"></a>**拜占庭（任意）故障：节点可以做任何事情，包括戏弄和欺骗其他节点**

<a name="6gea-1711640879281"></a>**具有崩溃恢复的部分同步模型是最有用的模型。分布式算法如何应用这种模型**

<a name="hwoz-1711387576180"></a>**算法的正确性**

<a name="i9kv-1711640972087"></a>**描述属性：定义算法的正确性**

<a name="qsck-1711641049261"></a>**锁生成屏蔽令牌，要求具有以下属性：**

<a name="tvxj-1711641079676"></a>**唯一性：没有两个屏蔽令牌请求返回相同的值**

<a name="2d0a-1711641105012"></a>**单调序列：时序实现单调**

<a name="mlbd-1711641130527"></a>**可用性：请求防护令牌且不会崩溃的节点，最终会收到响应**

<a name="1lz8-1711387585629"></a>**安全性和活性**

<a name="hctm-1711641203049"></a>**澄清这种情况，需区分两种不同性质**

<a name="k48b-1711641295367"></a>**安全性safety: 唯一性和单调序列**

<a name="fmy7-1711641313609"></a>**活性：可用性**

<a name="ndiw-1711387592922"></a>**将系统模型映射到现实世界**

<a name="rp9s-1705080859004"></a>**9.一致性共识**

<a name="vrvh-1712996687843"></a>**共识consensus: 让所有节点对某件事达成一致**

<a name="oqcs-1712996726634"></a>**脑裂brain split: 两个节点都认为自己是master, 经常导致数据丢失；**

<a name="obqn-1711730044966"></a>**一致性保证**

<a name="ku5g-1712996774138"></a>**最终一致性：收敛convergence, 最终收敛到相同的值**

<a name="ga60-1712996859001"></a>**事务一致性：避免同时执行事务导致的竞争状态**

<a name="eovi-1712996916251"></a>**分布式一致性模型：面对延迟和故障时，如何协调副本间的状态**

<a name="thyh-1711730049653"></a>**线性一致性**

<a name="bvre-1712997165569"></a>**背后的想法：原子一致性atomic consistency, 强一致性strong consistency, 立即一致性 immediate consistency ,外部一致性 external consistency**

<a name="qbsw-1712997247742"></a>**看起来只有一个数据副本，实际有多个副本 - 强一致性就是逆分布式化，看成一个整体。**

<a name="f0su-1712997377059"></a>**线性一致是一个新鲜度保证 recency gurantee;**

<a name="mtb7-1712997407717"></a>**非线性一致的例子： world cup ,  alice refresh - DB1 return germany 1: 0 argentina won ;  bob refresh website - DB2(un asychronize) return still playing;**

<a name="qimr-1711730403998"></a>**为什么使得系统线性一致？**

<a name="ffat-1712998155207"></a>**例子：CAS使得多个客户端并发按序更新**

<a name="3elk-1712997586736"></a>**线性一致性与可序列化是两种完全不同的保证：**

<a name="qpvu-1712998010030"></a>**可序列化serializeble: 单对象或者多对象操作，确保按照某种顺序执行**

<a name="ojsh-1712998125336"></a>**线性一致性Linearizability:是读取和写入寄存器（单个对象）的新鲜度保证，不会将操作组合为事务，不会阻止写入偏差等问题**

<a name="5hda-1712998332148"></a>**单副本强可串行性strong-1SR: 一个数据库可提供可串行性和线性一致, 基于两阶段锁2PL和实际串行执行通常是线性一致的**

<a name="obfn-1712998432352"></a>**SSI一致性快照不是线性一致的：不会包括比快照更新的写入；-不会阻塞非写的读。**

<a name="bje8-1711730427157"></a>**依赖线性一致性**

<a name="xyll-1711730652620"></a>**锁定与领导选举**

<a name="2fqs-1712998599719"></a>**领导选举的一种方法：每个节点启动时尝试获取锁，成功者称为领导者。**

<a name="cbzr-1712998723133"></a>**保证锁时线性一致的： zookeeper 和 etcd 协调服务的一致性算法。curator基于zookeeper上更高级别的配方**

<a name="gpva-1711730659968"></a>**约束和唯一性保证**

<a name="9jmj-1712998930168"></a>**这种情况类似于一个锁，锁定用户名。该操作与原子性的cas类似：**

<a name="lhyk-1712999021176"></a>**用户名和邮箱；**

<a name="7sgo-1712999031257"></a>**银行账号不为负数；**

<a name="so5k-1712999045093"></a>**航班剧院预定了同一时间同一位置**

<a name="q05j-1712999070223"></a>**实际应用中，处理这些限制有时可以接受。如调换位置并补偿。**

<a name="7cbv-1711730671963"></a>**跨信道的时序依赖**

<a name="cqkp-1712999245541"></a>**将用户上传的照片降低分辨率以加快下载速度：**

<a name="3zoo-1712999362806"></a>**步骤：消息队列一般针对较短的消息而设计，一张图片可能达到几M.所以步骤为**

<a name="umkb-1712999318589"></a>**1.上传照片-  web server-2.  (store img) 存储文件服务器**  

<a name="er8u-1712999518585"></a>  **| 3. send message  || 5.fetch full size img  6.store resized img**

<a name="iiv4-1712999532781"></a>**消息队列   - 4.deliver message     image resizer**

<a name="0yys-1712999647965"></a>**问题：存储和缩放存在两个不同的信道，没有线性一致的新鲜度保证**

<a name="xtun-1712999768959"></a>**3和4可能比存储服务器内部的复制更快，当5时，可能会看到图像旧版本或者什么都没有，如果处理的是旧版本，则产生不一致。**

<a name="ytt0-1711730433598"></a>**实现线性一致性的系统**

<a name="j997-1712999879559"></a>**单主复制（可能线性一致）protential潜在线性一致：**

<a name="t174-1712999979364"></a>**快照隔离并发错误；**

<a name="hh6o-1712999996439"></a>**脑裂；异步复制延迟，故障切换**

<a name="z3nq-1713000050923"></a>**共识算法（线性一致）：共识算法可以安全实现线性一致性的存储，zookeeper 和 etcd**

<a name="q0kz-1713000066034"></a>**多主复制（非线性一致）：同时多个节点上处理写入，异步复制到其他节点，会产生冲突的写入**

<a name="ca4m-1713030167882"></a>**无主复制（也许不是线性一致的）：Dynamo风格，法定人数读写获得强一致性。通常不完全正确**

<a name="9gst-1711730681011"></a>**线性一致性和法定人数**

<a name="sqvx-1713030399799"></a>**最安全的做法是：假设采用Dynamo风格的无主复制的系统是不能提供线性一致性。**

<a name="vpxf-1711730440465"></a>**线性一致性的代价**

<a name="fqqf-1711730717308"></a>**CAP定理**

<a name="8hzl-1713030564813"></a>**不仅是单主多主复制的后果，任何线性一致性的数据库都有这个问题：**

<a name="7lux-1713030592466"></a>**.应用需要线性一致性，副本因为网络问题断开连接，请求必须等到网络问题解决或直接返回错误（不可用unavailable）**

<a name="48wk-1713031150235"></a>**.网络断开也可独立处理请求（如多主复制），可以在网络问题前保持可用，但其行为不是线性一致的。**

<a name="lsdc-1713031249676"></a>**CAP定理没有帮助：网络分区是不可避免的，所以只能是AP 或 CP。**

<a name="kxsm-1711730728177"></a>**线性一致性和网络延迟**

<a name="lbl2-1713031508671"></a> **线性一致的系统惊人的少。例如多核CPU并没有保证一定能读到第一个线程写入的值（除非使用内存屏障memory barrier或围栏fence）**

<a name="pnsn-1713031585885"></a> **牺牲线性一致性的原因是性能performance. 内存访问先走缓存，副本都是异步更新的，所以失去了线性一致性。**

<a name="8y6v-1713031685808"></a>**搞笑的线性一致性存储不可实现。**

<a name="on5f-1711730057760"></a>**顺序保证**

<a name="dhiv-1713031758875"></a>**写入顺序order of write: 单主复制的主要目的就是复制日志中确定写入顺序。**

<a name="cyfr-1713031815356"></a>**序列顺序serial order：某种序列顺序some sequential order**

<a name="z48k-1711730472679"></a>**顺序与因果**

<a name="khzl-1713031939113"></a>**顺序有助于保持因果关系causality**

<a name="nbes-1713031966982"></a>**一致前缀读：先看到答案再看到问题。违背因cause果effect. 存在因果依赖causal dependency**

<a name="xehj-1713032060272"></a>**更新不存在的记录：3位领导者间的复制，一些写入会压到其他写入。一条记录需被创建才能更新。**

<a name="v1kv-1713032135082"></a>**检测并发写入：A和B并发，则不知道顺序，A和B不知道彼此。**

<a name="ozi8-1713032226341"></a>**快照隔离：写偏差read skew，读取的数据违反因果关系（不可重复读）**

<a name="pgzq-1713032264605"></a>**事务的写偏差write skew：幻读和值班。**

<a name="3ang-1713032756197"></a>**世界杯球赛结果，跨信道的时序依赖。**

<a name="tryg-1713032788961"></a>**因果一致causally：系统服从因果关系锁规定的顺序。**

<a name="niwx-1711730751513"></a>**因果顺序不是全序的**

<a name="x8gk-1713086054855"></a>**全序total order: 自然数更大或更小，总是有序的**

<a name="wvsa-1713086222914"></a>**偏序partially order: 一个集合大于另一个集合，但是其它情况下无法比较**

<a name="u7jq-1713086312064"></a>**线性一致性：操作是全序的，系统表现好像只有一个副本，所有操作都是原子性的。意味对每个操作总能判定发生顺序**

<a name="xa0w-1713086399916"></a>**因果性：两个操作没在彼此之前发生，即并发无法比较顺序，意味着因果关系定义了一个偏序，而不是全序。一些有序一些无序**

<a name="uaxz-1713086531138"></a>**线性一致的数据存储中是不存在并发操作的。确保每个请求都是在唯一时间线上自动处理**

<a name="qs64-1713086635361"></a>**并发意味着时间线会分叉然后合并。操作的偏序：**

<a name="ctkd-1713086670170"></a>**类似git系统，一个提交commit发生在另一个提交之后。分支合并merge会在这些并发创建的提交相融合时创建。**

<a name="qdnf-1711730766239"></a>**线性一致性强于因果一致性**

<a name="dam4-1713086279684"></a>**线性一致性隐含implies着因果关系;**

<a name="uqqx-1711730776113"></a>**捕获因果关系**

<a name="agrw-1713086796608"></a>**为了维持因果性，需确认操作发生在哪个操作之前happened before:**

<a name="rys3-1713086865582"></a>**刑侦决定Y时是否知到X与Y因果关系**

<a name="znup-1713086911030"></a>**检测并发写入：推广版本向量解决因果依赖**

<a name="1ivk-1713086936754"></a>**SSI序列化隔离快照：事务提交时，检测读取是否最新，为此跟踪哪些事务被那些事务锁读取。**

<a name="jsuf-1711730485869"></a>**序列号顺序**

<a name="y9ti-1713091524670"></a>**序列号sequence number或时间戳timestamp**

<a name="qpya-1711730796494"></a>**非因果序列号生成器**

<a name="mtzj-1711730811106"></a>**兰伯特时间戳**

<a name="f8uv-1713091653199"></a>**兰伯特时间戳提供了与因果关系一致的总排序：施行一个全序**

<a name="2ayx-1713091789731"></a>**检测并发写入有着不同目的：区分两个操作是并发的，一个因果依赖另一个。**

<a name="elc6-1711730816628"></a>**光有时间戳排序还不够**

<a name="aw2l-1711730490423"></a>**全序广播**

<a name="axul-1713091937508"></a>**可靠交付reliable delivery：没有消息丢失，如果消息被传递到一个节点，它将被传递到所有节点**

<a name="cruc-1713091989510"></a>**全序交付totally ordered delivery: 消息以相同的顺序传递给每个节点。**

<a name="hp3a-1711730834892"></a>**使用全序广播**

<a name="ztws-1713108978601"></a>**zookeeper和etcd共识服务实际上实现了全序广播**

<a name="i8bk-1713109007327"></a>**状态机复制state machine repliacation: 每个副本都按相同的顺序处理相同的写入。**

<a name="8jch-1713109071990"></a>**与之类似，使用全序广播来实现可序列化的事务：真的串行执行，确定的事务以存储过程来执行，每个节点以相同的顺序处理这些消息。**

<a name="w19a-1713109204107"></a>**以及防护令牌的锁服务，全序广播使得所有消息按顺序一次编号，序列号可当做防护令牌(单调递增)，zookeeper中这个序列号称为zxid;**

<a name="i3vg-1711730844593"></a>**使用全序广播实现线性一致的存储**

<a name="xlae-1711730855140"></a>**使用线性一致性存储实现全序广播**

<a name="y1bv-1711730380233"></a>**分布式事务与共识**

<a name="yt5r-1713109388776"></a>**让几个节点达成一致get serveral nodes to agree on somthing**

<a name="d7t7-1713109479427"></a>**领导选举：避免脑裂**

<a name="frsp-1713109508353"></a>**原子提交atomic commit：多节点事务提交/中止/回滚**

<a name="abk6-1711730509647"></a>**原子提交与两阶段提交2PC**

<a name="0h2f-1713110484428"></a>**原子性可以避免中间态，多对象事务原子性确保二级索引与主数据库保持一致。**

<a name="iqfd-1711730882368"></a>**从单节点到分布式原子提交**

<a name="h1ym-1713110537245"></a>**从数据库的角度看，这是单独的事务，任何跨事务正确性的保证都是应用自己的问题。**

<a name="roa9-1711730906391"></a>**2PC两阶段提交简介**

<a name="vaax-1705118249954"></a>**coodinator协调子事务，子事务单独执行完，在准备阶段询问是否可提交**

<a name="7zwc-1705118288968"></a>**.全部为是，则分别提交。**

<a name="3b8s-1705118337513"></a>**.其中有否，则中断回滚。**

<a name="kpgk-1711730913393"></a>**系统承诺**

<a name="wkui-1713110739239"></a>**一旦协调者做出决定，这一决定是不可撤销的。**

<a name="qhdj-1711730921387"></a>**协调者失败**

<a name="jpd8-1713110804532"></a>**参与者投赞成票后，参与者协调者崩溃，数据库1不知道是否提交或中止。**

<a name="ixzv-1711730924556"></a>**三阶段提交**

<a name="edp3-1713111179295"></a>**阻塞blocking原子提交协议, 2PC可能卡主等待协调者恢复的情况。**

<a name="llyc-1711731148564"></a>**在提交阶段，如果子事务进程crash,或者协调者崩溃的时的解决方案，弱原子性，最终一致性。**

<a name="nlrk-1705118500709"></a>**许多coodinator不支持高可用或者只支持基本的复制**

<a name="xexf-1711730524691"></a>**实践中的分布式事务**

<a name="inqh-1713111548114"></a>**云服务由于其导致的运维问题而选择不实现分布式事务。**

<a name="zuho-1713111590325"></a>**两阶段难以实现安全保证，且导致的运维问题造成性能下降。**

<a name="gf92-1711731287296"></a>**数据库内部的分布式事务**

<a name="jhqw-1705080950920"></a>**VoltDB 与mysql Cluster 的NDB引擎就有这样的内部事务支持。**

<a name="gvng-1713111648038"></a>**异构分布式事务**

<a name="st60-1713111659854"></a>**保证异构数据库的事务更有挑战性**

<a name="btdt-1711730944613"></a>**恰好一次的消息处理**

<a name="rawn-1713111843767"></a>同一个事务中的原子提交消息确认和数据库写入两个操作实现。

<a name="8joh-1713111889782"></a>原子提交消息处理及其副作用，成功之前需重试几次确保有效处理一次。

<a name="7d9r-1713111936062"></a>原子提交协议atomic commit protocl

<a name="qvbk-1711730954739"></a>**XA事务eXtended Architecture**

<a name="0thc-1711731206081"></a>跨异构技术实现两阶段提交的标准，：许多传统关系数据库（包括PostgreSQL，MySQL，DB2，SQL Server和Oracle）和消息代理（包括ActiveMQ，HornetQ，MSMQ和IBM MQ）都⽀持XA。

<a name="otul-1705081462777"></a>XA事务是使⽤**Java事务API（**JTA, Java Transaction API）实现的，⽽许

<a name="wfx9-1705081463074"></a>多使⽤Java数据库连接（**JDBC**, Java Database Connectivity）的数据库驱动，以及许多使⽤Java消息服务（JMS）API的消息代理**都⽀持Java事务API**（JTA）。

<a name="0dfj-1705081511181"></a>Spring事务基于JDBC事务。

<a name="med0-1711730959684"></a>**怀疑时持有锁**

<a name="l5tj-1711731251968"></a>读已提交，数据库事务通常获取待修改的⾏上的⾏级排他锁，以防⽌脏写(值为NULL，事务A先写，事务B写后提交，A回滚，值变NULL)。

<a name="ue7i-1705118474108"></a>在协调者崩溃时，这些锁将会被coodinator永久持有，如果管理员不手动释放。

<a name="ouyq-1711730969007"></a>**从协调者故障中恢复**

<a name="ouur-1713116418144"></a>**唯一的出路是让管理员手动决定提交还是回滚事务**

<a name="gzya-1711730975747"></a>**分布式事务的限制**

<a name="jkt3-1713116480399"></a>**协调者本身就是一种数据库，存储了事务的结果。**

<a name="mcvv-1713116529836"></a>**协调者默认不是高可用的，只有基本的复制**

<a name="h6gt-1713116550997"></a>**应用服务器不再是无状态的了**

<a name="rrrl-1713116568769"></a>**不能检测不同系统间的死锁，且无法与SSI协同工作**

<a name="wbzw-1713116600081"></a>**与构建容错系统的目标背道而驰，分布式事务有扩大失效amplifying failures的趋势**

<a name="npne-1713118985168"></a>**容错共识**

<a name="beiq-1713118985169"></a>**一个或多个节点提议propose某些值，共识算法决定decides采用其中的某个值。**

<a name="pq0x-1713118985170"></a>**一致同意Uniform agreement:  没有两个节点的决定不同-核心 决定了相同的结果，一旦决定不能改变**

<a name="xnwp-1713118985171"></a>**完整性Integrity: 没有节点决定两次-核心**

<a name="2bty-1713118985172"></a>**有效性validity: 如果一个节点决定了值v, 则v由某个节点所提议-排除平凡的解决方案**

<a name="9k32-1713118985173"></a>**终止Termination由所有为崩溃的几点来最终决定值。-活性属性，必须取得进展，即使部分节点出现故障，其他节点也必须达成一致。不超过一般的节点崩溃或不可达**

<a name="scne-1713118985174"></a>**稳健达成共识：只要少于三分之一的节点存在拜占庭故障**

<a name="prxr-1713118985175"></a>**共识算法和全序广播**

<a name="zmcg-1713118985176"></a>**视图戳复制VSR viewstamped repliacation, Paxos，Raft, Zab**

<a name="1u8f-1713118985177"></a>**全序广播相当于重复进行多轮共识：**

<a name="d2l2-1713118985178"></a>**一致同意属性，所有节点决定以相同的顺序传递相同的消息**

<a name="z7u4-1713118985179"></a>**完整性属性，消息不会重复**

<a name="pphb-1713118985180"></a>**有效性属性，消息不会被破坏，也不能凭空编造**

<a name="gqmq-1713118985181"></a>**终止属性,消息不会丢失**

<a name="lxll-1713118985182"></a>**视图戳复制，raft和zab直接实现了全序广播，比重复一次一致one value a time的共识更高效， paxos 下这种优化称为multi-paxos.**

<a name="krsz-1713118985183"></a>**单领导者复制和共识**

<a name="7euj-1713117457957"></a>在第5章中，我们讨论了单领导者复制（参⻅“领导者和追随者”），它将所有的写⼊操作都交给主库，并

<a name="9ytr-1713117492801"></a>以相同的顺序将它们应⽤到从库，从⽽使副本保持在最新状态。这实际上不就是⼀个全序⼴播吗？为什

<a name="35n1-1713117492803"></a>么我们在第五章⾥⼀点都没担⼼过共识问题呢？

<a name="k34n-1713117492805"></a>答案取决于如何选择领导者。如果主库是由运维⼈员⼿动选择和配置的，那么你实际上拥有⼀种**独裁类**

<a name="tzgp-1713117492807"></a>**型**的“共识算法”：只有⼀个节点被允许接受写⼊（即决定写⼊复制⽇志的顺序），如果该节点发⽣故

<a name="kjgb-1713117492809"></a>障，则系统将⽆法写⼊，直到运维⼿动配置其他节点作为主库。这样的系统在实践中可以表现良好，但

<a name="g6oo-1713117492811"></a>它⽆法满⾜共识的**终⽌**属性，因为它需要⼈为⼲预才能取得**进展**

<a name="o7n2-1713117530542"></a>但是还有⼀个问题。我们之前曾经讨论过脑裂的问题，并且说过所有的节点都需要同意是谁领导，否则

<a name="bfcv-1713117531477"></a>两个不同的节点都会认为⾃⼰是领导者，从⽽导致数据库进⼊不⼀致的状态。因此，选出⼀位领导者需

<a name="dbrc-1713117531479"></a>要共识。但如果这⾥描述的共识算法实际上是全序⼴播算法，并且全序⼴播就像单主复制，⽽单主复制

<a name="qeja-1713117531481"></a>需要⼀个领导者，那么...

<a name="lka8-1713117531483"></a>这样看来，要选出⼀个领导者，我们⾸先需要⼀个领导者。要解决共识问题，我们⾸先需要解决共识问

<a name="xeaw-1713117531485"></a>题。我们如何跳出这个先有鸡还是先有蛋的问题？

<a name="90tt-1713118985184"></a>**时代编号和法定人数**

<a name="yumy-1713117567016"></a>迄今为⽌所讨论的所有共识协议，在内部都以某种形式使⽤⼀个领导者，但它们并不能保证领导者是ᇿ

<a name="3hxy-1713117568546"></a>⼀⽆⼆的。相反，它们可以做出更弱的保证：协议定义了⼀个**时代编号（epoch number）**（在Paxos

<a name="rl3b-1713117568548"></a>中称为**投票编号（ballot number）**，视图戳复制中的**视图编号（view number）**，以及Raft中的**任**

<a name="zcxk-1713117568550"></a>**期号码（term number）**），并确保在每个时代中，领导者都是唯⼀的。

<a name="nmn5-1713117568552"></a>每次当现任领导被认为挂掉的时候，节点间就会开始⼀场投票，以选出⼀个新领导。这次选举被赋予⼀

<a name="rw3m-1713117568554"></a>个递增的时代编号，因此时代编号是全序且单调递增的。如果两个不同的时代的领导者之间出现冲突

<a name="rvcj-1713117568556"></a>（也许是因为前任领导者实际上并未死亡），那么带有更⾼时代编号的领导说了算。

<a name="vfaq-1713117568558"></a>在任何领导者被允许决定任何事情之前，必须先检查是否存在其他带有更⾼时代编号的领导者，它们可

<a name="hzjw-1713117568561"></a>能会做出相互冲突的决定。领导者如何知道⾃⼰没有被另⼀个节点赶下台？回想⼀下在“真理在多数⼈⼿

<a name="cf3k-1713117568563"></a>中”中提到的：⼀个节点不⼀定能相信⾃⼰的判断—— 因为只有节点⾃⼰认为⾃⼰是领导者，并不⼀定

<a name="aouf-1713117568565"></a>意味着其他节点接受它作为它们的领导者。

<a name="qywj-1713118985185"></a>**共识的局限性**

<a name="jcey-1713117608200"></a>⼤多数共识算法假定参与投票的节点是固定的集合，这意味着你不能简单的在集群中添加或删除节点。

<a name="citk-1713117610002"></a>共识算法的**动态成员扩展（dynamic membership extension）**允许集群中的节点集随时间推移⽽变

<a name="cbbk-1713117610004"></a>化，但是它们⽐静态成员算法要难理解得多。

<a name="oet6-1713117610006"></a>共识系统通常依靠超时来检测失效的节点。在⽹络延迟⾼度变化的环境中，特别是在地理上散布的系统

<a name="3pqb-1713117610008"></a>中，经常发⽣⼀个节点由于暂时的⽹络问题，错误地认为领导者已经失效。虽然这种错误不会损害安全

<a name="0mpm-1713117610010"></a>属性，但频繁的领导者选举会导致糟糕的性能表现，因系统最后可能花在权⼒倾扎上的时间要⽐花在建

<a name="3vkb-1713117610012"></a>设性⼯作的多得多。

<a name="taga-1713117610014"></a>有时共识算法对⽹络问题特别敏感。例如Raft已被证明存在让⼈不悦的极端情况【106】：如果整个⽹

<a name="xgwm-1713117610016"></a>络⼯作正常，但只有⼀条特定的⽹络连接⼀直不可靠，Raft可能会进⼊领导频繁⼆⼈转的局⾯，或者当

<a name="0pdg-1713117610018"></a>前领导者不断被迫辞职以致系统实质上毫⽆进展。其他⼀致性算法也存在类似的问题，⽽设计能健壮应

<a name="wmjy-1713117610020"></a>对不可靠⽹络的算法仍然是⼀个开放的研究问题。

<a name="8qzt-1713118985186"></a>**成员与协调服务**

<a name="kco9-1713117676659"></a>ZooKeeper和etcd被设计为容纳少量完全可以放在内存中的数据（虽然它们仍然会写⼊磁盘以保证持久

<a name="bx7d-1713117678374"></a>性），所以你不会想着把所有应⽤数据放到这⾥。这些少量数据会通过容错的全序⼴播算法复制到所有

<a name="rktv-1713117678376"></a>节点上。正如前⾯所讨论的那样，数据库复制需要的就是全序⼴播：如果每条消息代表对数据库的写

<a name="zzw0-1713117678378"></a>⼊，则以相同的顺序应⽤相同的写⼊操作可以使副本之间保持⼀致。

<a name="oyah-1713117678380"></a>ZooKeeper模仿了Google的Chubby锁服务【14,98】，不仅实现了全序⼴播（因此也实现了共识），

<a name="dsal-1713117678382"></a>⽽且还构建了⼀组有趣的其他特性，这些特性在构建分布式系统时变得特别有⽤：

<a name="egix-1713117730152"></a>**线性⼀致性的原⼦操作**

<a name="tbjq-1713117730935"></a>使⽤原⼦CAS操作可以实现锁：如果多个节点同时尝试执⾏相同的操作，只有⼀个节点会成功。共识协

<a name="sw1a-1713117730937"></a>议保证了操作的原⼦性和线性⼀致性，即使节点发⽣故障或⽹络在任意时刻中断。分布式锁通常以**租约**

<a name="tnrf-1713117730939"></a>**（lease）**的形式实现，租约有⼀个到期时间，以便在客户端失效的情况下最终能被释放（参阅“进程暂

<a name="eplh-1713117730941"></a>停”）。

<a name="vfgm-1713117730943"></a>**操作的全序排序**

<a name="qgmi-1713117730945"></a>如“领导者与锁定”中所述，当某个资源受到锁或租约的保护时，你需要⼀个防护令牌来防⽌客户端在进

<a name="qp5h-1713117730947"></a>程暂停的情况下彼此冲突。防护令牌是每次锁被获取时单调增加的数字。 ZooKeeper通过全局排序操作

<a name="8ex8-1713117730949"></a>来提供这个功能，它为每个操作提供⼀个单调递增的事务ID（ zxid ）和版本号（ cversion ）

<a name="koeo-1713117730951"></a>【15】。

<a name="uwks-1713117730953"></a>**失效检测**

<a name="garl-1713117730956"></a>客户端在ZooKeeper服务器上维护⼀个⻓期会话，客户端和服务器周期性地交换⼼跳包来检查节点是否

<a name="g30e-1713117730958"></a>还活着。即使连接暂时中断，或者ZooKeeper节点失效，会话仍保持在活跃状态。但如果⼼跳停⽌的持

<a name="ti3d-1713117730960"></a>续时间超出会话超时，ZooKeeper会宣告该会话已死亡。当会话超时（ZooKeeper调⽤这些临时节点）

<a name="golx-1713117730962"></a>时，会话持有的任何锁都可以配置为⾃动释放（ZooKeeper称之为**临时节点（ephemeral**

<a name="yrcg-1713117730964"></a>**nodes）**）。

<a name="oomn-1713117730966"></a>**变更通知**

<a name="nxl7-1713117730968"></a>客户端不仅可以读取其他客户端创建的锁和值，还可以监听它们的变更。因此，客户端可以知道另⼀个

<a name="pakj-1713117730970"></a>客户端何时加⼊集群（基于新客户端写⼊ZooKeeper的值），或发⽣故障（因其会话超时，⽽其临时节

<a name="ixqt-1713117730972"></a>点消失）。通过订阅通知，客户端不⽤再通过频繁轮询的⽅式来找出变更。

<a name="pzpu-1713117730974"></a>在这些功能中，只有线性⼀致的原⼦操作才真的需要共识。但正是这些功能的组合，使得像ZooKeeper

<a name="rv3m-1713117730976"></a>这样的系统在分布式协调中⾮常有⽤。

<a name="4tlb-1713118985187"></a>**将工作分配给节点**

<a name="rvkw-1713117826927"></a>通常，由ZooKeeper管理的数据的类型变化⼗分缓慢：代表“分区 7 中的节点运⾏在 10.1.1.23 上”的

<a name="igbk-1713117797151"></a>信息可能会在⼏分钟或⼏⼩时的时间内发⽣变化。它不是⽤来存储应⽤的运⾏时状态的，每秒可能会改

<a name="bflq-1713117797153"></a>变数千甚⾄数百万次。如果应⽤状态需要从⼀个节点复制到另⼀个节点，则可以使⽤其他⼯具（如

<a name="k5yb-1713117797155"></a>Apache BookKeeper 【108】）。

<a name="tbbj-1713118985188"></a>**服务发现**

<a name="c1wh-1713117870132"></a>ZooKeeper，etcd和Consul也经常⽤于服务发现——也就是找出你需要连接到哪个IP地址才能到达特定

<a name="ps7b-1713117870759"></a>的服务。在云数据中⼼环境中，虚拟机连续来去常⻅，你通常不会事先知道服务的IP地址。相反，你可

<a name="6wf0-1713117870761"></a>以配置你的服务，使其在启动时注册服务注册表中的⽹络端点，然后可以由其他服务找到它们。

<a name="azmc-1713117870764"></a>但是，服务发现是否需要达成共识还不太清楚。 DNS是查找服务名称的IP地址的传统⽅式，它使⽤多层

<a name="c70a-1713117870766"></a>缓存来实现良好的性能和可⽤性。从DNS读取是绝对不线性⼀致性的，如果DNS查询的结果有点陈旧，

<a name="enhw-1713117870768"></a>通常不会有问题【109】。 DNS对⽹络中断的可靠性和可靠性更为重要。

<a name="v8vn-1713117870770"></a>尽管服务发现并不需要共识，但领导者选举却是如此。因此，如果你的共识系统已经知道领导是谁，那

<a name="ef5x-1713117870772"></a>么也可以使⽤这些信息来帮助其他服务发现领导是谁。为此，⼀些共识系统⽀持只读缓存副本。这些副

<a name="bovk-1713117870774"></a>本异步接收共识算法所有决策的⽇志，但不主动参与投票。因此，它们能够提供不需要线性⼀致性的读

<a name="sdj5-1713117870776"></a>取请求。

<a name="1lld-1713118985189"></a>**成员服务**

<a name="plrd-1713118986300"></a>ZooKeeper和它的⼩伙伴们可以看作是成员服务研究的悠久历史的⼀部分，这个历史可以追溯到20世纪

<a name="5q4w-1713117889767"></a>80年代，并且对建⽴⾼度可靠的系统（例如空中交通管制）⾮常重要【110】。

<a name="17wf-1713117889770"></a>成员资格服务确定哪些节点当前处于活动状态并且是群集的活动成员。正如我们在第8章中看到的那

<a name="quas-1713117889772"></a>样，由于⽆限的⽹络延迟，⽆法可靠地检测到另⼀个节点是否发⽣故障。但是，如果你通过⼀致的⽅式

<a name="vojh-1713117889774"></a>进⾏故障检测，那么节点可以就哪些节点应该被认为是存在或不存在达成⼀致。

<a name="np5u-1713117889776"></a>即使它确实存在，仍然可能发⽣⼀个节点被共识错误地宣告死亡。但是对于⼀个系统来说，在哪些节点

<a name="jks7-1713117889778"></a>构成当前的成员关系⽅⾯是⾮常有⽤的。例如，选择领导者可能意味着简单地选择当前成员中编号最⼩

<a name="tvgk-1713117889780"></a>的成员，但如果不同的节点对现有成员的成员有不同意⻅，则这种⽅法将不起作⽤。

<a name="crbx-1713118986331"></a><a name="e8vp-1713117935189"></a>像ZooKeeper这样的⼯具为应⽤提供了“外包”的共识、故障检测和成员服务。它们扮演了重要的⻆⾊，

<a name="2omq-1713117935440"></a>虽说使⽤不易，但总⽐⾃⼰去开发⼀个能经受第8章中所有问题考验的算法要好得多。如果你发现⾃⼰

<a name="vdni-1713117935442"></a>想要解决的问题可以归结为共识，并且希望它能容错，使⽤⼀个类似ZooKeeper的东⻄是明智之举。

<a name="y9xj-1713118594943"></a>save

<a name="rehq-1705081588086"></a><a name="46k8-1705118453932"></a>**第三部分：衍生数据**

<a name="rboc-1716226529015"></a>**记录和衍生数据系统**

<a name="cmdh-1716226737947"></a>**从高层次看，存储和处理数据的系统可以分为两大类**

<a name="1dmv-1716226552894"></a>**记录系统System of record**

<a name="dh96-1716226777418"></a>**真相源source of truth. 记录用户输入新数据，标准化normalized**

<a name="qjlf-1716226568395"></a>**衍生数据系统Derived data system**

<a name="igtl-1716226871151"></a>**缓存cache, 衍生数据是冗余的，重复了已有的信息。**

<a name="ypgi-1716226504586"></a><a name="0bgb-1716226496297"></a>**10.批处理**

<a name="yygb-1720542683707"></a>**服务（在线系统）：高可用性，性能指标-响应时间**

<a name="goo7-1720542700859"></a>**批处理系统（离线系统）：定时任务job，性能指标-吞吐量**

<a name="mv2a-1720542952432"></a>**流处理系统（准实时系统）：介于在线离线系统之间**

<a name="6lu4-1716228538928"></a>**使用Unix工具的批处理**

<a name="hyii-1716228597300"></a>**分析简单日志**

<a name="smoq-1720543218731"></a>**Unix命令链：网站上找到五个最受欢迎的网页（nginx/access.log）**

cat /var/ log/ nginxl access.log |#1

`    `awk '{print $7}’│#2

`    `sort

`            `|#3

`    `uniq -c

`         `|#4

`    `sort -r -n

`      `|#5

`    `head -n 5

`        `#6



1．读取日志文件

2\.将每一行按空格分割成不同的字段，每行只输出第七个字段，恰好是请求的URL。在我们的例子中是/css/typography.css 。

3\.按字母顺序排列请求的URL列表。如果某个URL被请求过n次，那么排序后，文件将包含连续重复出现n次的该URL。

4\. uniq命令通过检查两个相邻的行是否相同来过滤掉输入中的重复行。(-c则表示还要输出一个计数器:对于每个不同的URL，它会报告输入中出现该URL的次数。

5．第二种排序按每行起始处的数字(-n）排序，这是URL的请求次数。然后逆序（-r)返回结果，大的数字在前。

<a name="cxil-1720543264072"></a>6．最后，只输出前五行（-n 5)，并丢弃其余的。该系列命令的输出如下所示:

<a name="ukyi-1716228816049"></a>**命令链与自定义程序Ruby**

counts = Hash. new ( o )    #1

File.open( ' /var/log/nginx/access.log ' ) do |file |

`    `file.each do | linel

`        `url = line.split[ 6]# 2

`        `counts [ url] += 1 #3

`      `end

end

top5 = counts.map{ |url,count/ [count,url] }.sort.reverse[0...5] #4

top5.each{ |count, url/ puts "#{count} #{url} "}  #5

1\. counts是一个存储计数器的哈希表，保存了每个URL被浏览的次数，默认为0。

2\.逐行读取日志，抽取每行第七个被空格分隔的字段为URL(这里的数组索引是6，因为Ruby的数组

索引从o开始计数)

3．将日志当前行中URL对应的计数器值加一。

4\.按计数器值(降序)对哈希表内容进行排序，并取前五位。

<a name="rvvh-1720543511029"></a>5.打印出前五个条目。

<a name="cnuw-1716228829632"></a>**排序 VS 内存中的聚合**

<a name="siiu-1720543940755"></a>**工作集working set(作业需要随机访问的内存大小)，单个url 重复出现百万次，哈希表性能好**

<a name="lms0-1720544023798"></a>**工作集大于内存，排序优，与SSTables 和 LSM树一样，内存聚合归并排序，GNU 中的sort通过溢出至磁盘自动应该大于内存大额数据集，瓶颈可能是磁盘io。-MQ的死信处理也是溢出到磁盘。**

<a name="mgei-1716228613042"></a>**Unix哲学**

<a name="zkda-1720544383841"></a>一部分——这一组设计原则在Unix用户与开发者之间流行起来，该哲学在1978年表述如下【12,13】:

<a name="xxwb-1720544385739"></a>1.让每个程序都做好一件事。要做一件新的工作，写一个新程序，而不是通过添加"功能"让老程序复杂化。

<a name="gwvc-1720544385743"></a>2期待每个程序的输出成为另一个程序的输入。不要将无关信息混入输出。避免使用严格的列数据或二进制输入格式。不要坚持交互式输入。

<a name="krq3-1720544385745"></a>3.设计和构建软件，甚至是操作系统，要尽早尝试，最好在几周内完成。不要犹豫，扔掉笨拙的部分，重建它们。

<a name="qmam-1720544385747"></a>4.优先使用工具来减轻编程任务，即使必须曲线救国编写工具，且在用完后很可能要扔掉大部分。这种方法――**自动化，快速原型设计，增量式迭代，对实验友好，将大型项目分解成可管理的块**—一听起来非常像今天的**敏捷开发**和**DevOps**运动。奇怪的是，四十年来变化不大。

<a name="ofel-1720544385749"></a>sort工具是一个很好的例子。可以说它比大多数编程语言标准库中的实现〈(即使有很大好处，也不会溢出到磁盘或使用多线程）要更好。然而，单独使用sort几乎没什么用。它只能与其他Unix工具(如uniq）结合使用。

<a name="x4qr-1720544385751"></a>像bash这样的Unix shell可以让我们轻松地将这些小程序组合成令人讶异的强大数据处理任务。

<a name="07ut-1720544385753"></a>尽管这些程序中有很多是由不同人群编写的，但它们可以灵活地结合在一起。Unix如何实现这种可组合性?

<a name="sk3b-1716228852580"></a>**统一的接口**

<a name="33ju-1720874904091"></a>**Unix中统一的接口是一个文件file**

<a name="yogq-1720875513301"></a>**ASCII文本，\n 分隔，**

<a name="7fvb-1720875542091"></a>**CSV， ，号分隔**

<a name="3oxq-1716228869387"></a>**逻辑与布线相分离**

<a name="0zy9-1720876020643"></a>**松耦合loose coupling**

<a name="226j-1720876035472"></a>**晚期绑定late binding**

<a name="zedb-1720876065554"></a>**控制反转inversion of control**

<a name="ftj8-1716228879278"></a>**透明度与实验**

<a name="bkmj-1720876137206"></a>Unix使查看正在发生的事情变得非常容易：

<a name="ydul-1720876167067"></a>输入文件通常视为不可变，即可随意运行命令

<a name="hktc-1720876202052"></a>任何时候结束管道，输出到less

<a name="d0kj-1720876219720"></a>输出写入文件，作为下一个阶段输入-可重启后面阶段而无需全部重启

<a name="puey-1720876267234"></a>Unix局限：只能运行为一台机器上。  Hadoop应运而生。

<a name="djdy-1716228554334"></a>**MapReduce和分布式文件系统**

<a name="illh-1720876369554"></a>**MapReduce像是分布在数前台机器上的Unix。**

<a name="e1cy-1720876447842"></a>**Hadoop的Map-Reduce视线中，文件系统成为HDFS,基于google文件系统GFS的开源实现。**

<a name="mapk-1720876955975"></a>**Amazon S3，  Azure blob** 

<a name="kdge-1716228625984"></a>**MapReduce作业执行**

<a name="vleh-1720877349422"></a>**Mapper在每条输入记录上调用一次,从输入记录中提取键值（提取键值）**

<a name="aol7-1720877397533"></a>**Reduce拉取Mapper生成的键值对，收集属于同一个键的所有值。（收集同键的所有值）**

<a name="kv6u-1716231603620"></a>**分布式执行MapReduce**

<a name="wy7r-1720877483243"></a>**即在不同服务器上执行mapper reduce 的task。**

<a name="d0qe-1716231619319"></a>**MapReduce工作流**

<a name="rvme-1720877910897"></a>**workflow。一系列命令，输出写入临时文件，下一个命令从临时文件中读取-物化中间状态**

<a name="pyoc-1716228643855"></a>**Reduce端连接与分组**

<a name="1pza-1716231634942"></a>**用户活动事件**

<a name="4l72-1720878002631"></a>**左侧是事件日志/活动事件activity events/点击流事件clickstream evnets**

<a name="hivt-1720878131008"></a>**右侧是用户数据库**

<a name="cvii-1720878237531"></a>**用户行为日志与用户档案的连接**

<a name="eiqe-1720878248508"></a>**原始:逐个遍历活动事件关联查询。缺点：吞吐量受限数据库服务器且容易压垮**

<a name="iueg-1720878322010"></a>**改良：获取用户数据库副本（ETL进程从数据库备份中提取数据，参考数仓），放在同一个分布式文件系统中。将用户数据库存储HDFS中的一组文件中，用户活动记录存储另一组文件中，**

<a name="ruua-1720878498786"></a>**并能用MapReduce将左右相关记录集中到同一个地方进行高效处理。**

<a name="fihy-1716231663765"></a>**排序合并连接**

<a name="q51q-1720947527716"></a>**1.map提取键值(userid-url  usrid-do)和reduce(userid all url do)**

<a name="4kvv-1720947648039"></a>**2.二次排序secondary sort ：对1的合并按时间戳排序**

<a name="j8br-1720947805879"></a>**排序合并连接sort-merge join: reduce一次处理一个特定用户所有记录，只需将一条用户记录保存在内存中，无需发送网络请求**

<a name="8vrk-1716231670998"></a>**把相关数据放在一起**

<a name="t1tc-1720947947656"></a>**Mapper和排序过程确保特定用户id连接操作的必须数据都放在同一个地方**

<a name="9j4s-1716228658160"></a>**GROUP BY**

<a name="a6wg-1720952083180"></a>**除了连接之外，“把相关数据放在一起”的常见模式是记录分组。SQL中的Group By**

<a name="qa24-1716231688547"></a>**处理倾斜**

<a name="f55j-1720952155251"></a>**名流热点数据hot spot**

<a name="julg-1720952222343"></a>**参考负载倾斜和消除热点**

<a name="akfb-1720952286891"></a>**Mapper将热键的关联记录随机发送到几个Reduce之一**

<a name="2tox-1716228671225"></a>**Map端连接**

<a name="qiil-1720971178915"></a>**预处理输入数据**

<a name="wjhj-1716231713037"></a>**广播散列连接**

<a name="k3se-1720971260954"></a>**broadcast hash join**

<a name="su27-1716231723170"></a>**分区散列连接**

<a name="5h9a-1720971514797"></a>**Map桶端连接bucketd map jons**

<a name="ftdq-1716231736611"></a>**Map端合并连接**

<a name="yrmc-1716231744413"></a>**MapReduce工作流与Map端连接**

<a name="zzir-1716228678980"></a>**批处理工作流的输入**

<a name="hiqn-1720971586510"></a>**OLTP ：查找少量记录，使用索引，呈现给用户**

<a name="cqba-1720971612883"></a>**OLAP：扫描大量记录，执行分组与聚合，输出有着报告的形式，商业决策的分析。**

<a name="bwjf-1716231761454"></a>**建立搜索索引**

<a name="lypn-1720971694941"></a>**MapReduce最初作为google搜索引擎的索引**

<a name="iijq-1720971776882"></a>**全文搜索和模糊索引  Lucene**

<a name="vcun-1720971828838"></a>**分区和二级索引**

<a name="8fix-1716231782091"></a>**键值存储作为批处理输入**

<a name="audd-1716231802005"></a>**批处理输入的哲学**

<a name="6i34-1720972317458"></a>**视为不可变且避免副作用：**

<a name="zciu-1720972319614"></a>**人类容错human fault tolerance**

<a name="oolm-1720972319615"></a>**最小化不可逆性mininizing irreversibility**

<a name="lp33-1716228684462"></a>**Hadoop与分布式数据库的对比**

<a name="g0vj-1720972341966"></a>**Hadoop 像Unix的分布式版本，HDFS是它的文件系统，而MapReduce是Unix进程的怪异实现**

<a name="gjbt-1720972427948"></a>**MapReduce论文发表前，并行连接算法已在数据库实现-大规模并行处理MPP massively parallel processing** 

<a name="go7m-1720972523351"></a>**Gamma database machine, Teradata, Tandem NonStop SQL**

<a name="5mnr-1720972551600"></a>**区别：MMP专注一组及骑行并行执行分析SQL 查询**

<a name="gx7b-1720972580058"></a>**MapReduce和分布式文件系统的组合是一个可以运行任意程序的通用操作系统**

<a name="eebl-1716231817367"></a>**存储多样性**

<a name="5lga-1720972673599"></a>**数据湖data lake / 企业数据中心enterprise data hub**

<a name="jrhw-1720972777529"></a>**Hadoop 常用于实现数仓ETL Extract, Transform, Load**

<a name="ysfv-1716231826972"></a>**处理模型多样**

<a name="kwz4-1716231831752"></a>**针对频繁故障设计**

<a name="p0zx-1716228568687"></a>**MapReduce之后**

<a name="wcyn-1721117329960"></a>**建立在MapReduce上的高级编程模型**

<a name="l9ug-1721117359714"></a>**Pig，Hive, Cascading, Crunch**

<a name="bz2s-1721117576614"></a>**流处理：加速批处理的另一种方法**

<a name="fvak-1716228706372"></a>**物化中间状态**

<a name="npb7-1721117756510"></a>**中间状态intermediate state**

<a name="0rlu-1721117876651"></a>**物化materialization:中间态写入文件的过程**

<a name="fnqf-1721117967688"></a>**MapReduce完全物化中间态的方法不足：**

<a name="pood-1721117984973"></a>**只有在前驱作业生成其输入完成时才能启动**

<a name="iljf-1721118032959"></a>**mapper通常是多余的：仅仅读取由Reducer写入的同样文件**

<a name="tghz-1721118071785"></a>**临时文件（数据）被复制到多个节点**

<a name="aer2-1721118148615"></a>**解决：数据流引擎**

<a name="sdac-1716231877023"></a>**数据流引擎**

<a name="4gu5-1721118111495"></a>**分布式批处理新引擎：**

<a name="nfnv-1721118162692"></a>**spark,  Flink: 独立的网络通信层，调度器，用户向API**

<a name="0kbz-1721123564974"></a>**Tez : 薄库，依赖YARN shuffle服务实现节点间的数据复制**

<a name="jojo-1721118227522"></a>**dataflow engines模型:**

<a name="kstp-1721118246090"></a>**函数/算子operators: 一个算子的输出连接到另一个算子的输入**

<a name="zbrh-1721118327524"></a>**优点：**

<a name="8oqo-1721118330975"></a>**排序等昂贵工作只需在实际需要地方执行，不是默认在Map和Reduce阶段间**

<a name="amzf-1721118375240"></a>**没有不必要的Map任务**

<a name="bunw-1721118382779"></a>**连接和数据依赖都是显示声明的**

<a name="bzui-1721122836028"></a>**算子中间态足以保存内存或写入本地磁盘，比HDFS需要更少I/O**

<a name="ka7f-1721123164712"></a>**算子可在输入就绪后立即执行，不许等待前驱完成**

<a name="rmr3-1721123191298"></a>**MapReduce为每个任务启动新JVM, 而df enginer可重用现有JVM，减少启动开销**

<a name="mp4i-1721123431562"></a>**执行速度更快**

<a name="2cxo-1721123304059"></a>**使用：**

<a name="vyfa-1721123442398"></a>**算子是Map和Reduce的泛化/抽象，相同处理代码可在任意引擎上运行**

<a name="qxck-1721123483308"></a>**Pig Hive Casacding中实现的工作流无需修改代码，修改配置，从MapReduce切换到Tez 或spark.**

<a name="glfr-1716231882229"></a>**容错**

<a name="neqa-1721499456929"></a>**重启，算子重新计算**

<a name="npsg-1716231884238"></a>**关于物化的讨论**

<a name="dvkh-1716228727874"></a>**图与迭代处理**

<a name="y476-1721499725472"></a>**图数据模型常用于机器学习应用**

<a name="ld62-1721499760165"></a>**图形算法PageRank:根据连接到某个网页的其他网页来估计该网页的流行度**

<a name="et5r-1721499798288"></a>**闭包传递transitive clousure: 重复跟进标明地点归属关系的边，生成数据库中北美地点列表**

<a name="x4m1-1721499995671"></a>**MapReduce低效：没考虑算法迭代性**

<a name="lf5y-1716231892007"></a>**Pregel处理模型**

<a name="1faf-1721499959178"></a>**图批处理的优化：批量同步并行（BSP）计算模型。**

<a name="3mh8-1721500149918"></a>**Pregel模型：Google的Pregel论文推广了处理图的方法。Apache Giraph , Spark GraphX API 和 Flink Gelly API**

<a name="pxnd-1716231909468"></a>**容错**

<a name="v8gr-1716231912877"></a>**并行执行**

<a name="cxqk-1716228736349"></a>**高级API和语言**

<a name="qlnr-1721841646688"></a>**Hive,pig, Cascading,Crunch等高级语言和API, Tez**

<a name="dfa6-1716231923208"></a>**向声明式查询语言的转变**

<a name="zman-1721841903902"></a>**声明式declarative**

<a name="inea-1721841971310"></a>**与SQL的完全声明式查询有很大的区别：**

<a name="ahki-1721842021736"></a>**围绕回调函数的概念建立，自由调用任意代码来决定输出什么。**

<a name="bdyf-1721842047384"></a>**可基于大量已有库的生态系统创作： 解析、自然语言分析，图像分析以及运算数值算法或统计算法等。**

<a name="m2pu-1716231937991"></a>**专业化的不同领域**

<a name="wpot-1721842227412"></a>**空间算法：最近邻搜索K-nearest neghbors**

<a name="a2en-1721931596260"></a><a name="iwmv-1721931597264"></a>**11.流处理**

<a name="yeid-1722103475505"></a>**流处理Stream processing: 当事件发生时就可以立即处理**

<a name="08iq-1721844360659"></a>**传递事件流**

<a name="n0th-1722103658739"></a>**事件event：流处理的上下文件记录**

<a name="titb-1722103707652"></a>**生产者producer/发布者publisher/发送者sender**

<a name="yhbb-1722103745716"></a>**消费者consumer/订阅者subscribers/接收者recipients**

<a name="jdqp-1722103794393"></a>**主题topic/流stream：相关事件的聚合**

<a name="2buw-1722103875913"></a>**通知机制：数据库触发器trigger(算是弥补机制)、消息传递系统messaging system**

<a name="ipga-1721932434160"></a>**消息系统**

<a name="qm3o-1722104029796"></a>**两个关键问题：**

<a name="sztq-1722104046748"></a>**1.生产者快于消费者：丢掉消息/将消息放入缓冲队列/背压backpressure(流量控制flow control) 阻塞生产者，以免其发送更多消息**

<a name="5ycq-1722104289674"></a>**2.节点崩溃或脱机，是否有消息丢失： 持久性，高吞吐和低延迟则接收丢失**

<a name="cj2t-1721932544748"></a>**直接从生产者传递给消费者**

<a name="hjhp-1722104612024"></a>**直接网络通信，而不通过中间节点：**

<a name="0ggy-1722104631748"></a>**UPD组播，金融行业，低延时，不可靠，应用层协议可恢复丢失的包（生产者必须记住发送的包，按需重新发送）**

<a name="hnj8-1722104735615"></a>**无代理的消息库，ZeroMQ、nanomsg, TCP或IP多播**

<a name="pcd7-1722104800545"></a>**StatsD 和 Brubeck 使用UDP**

<a name="3se2-1722104863261"></a>**消费者在网络上公开了服务，生产者可以直接发送HTTP和RPC请求将消息推送给使用者webhooks.**

<a name="jwkh-1721932555905"></a>**消息代理**

<a name="dtlb-1722106424439"></a>**消息代理message broker(也称为消息队列message queue)**

<a name="fyus-1721932559957"></a>**消息代理与数据库对比**

<a name="aj3x-1722106519844"></a>**.数据存储：数据库保留数据直至显示删除；大多数消息代理在消息成功传递给消费者时地总删除**

<a name="pkoh-1722106591225"></a>**.删除消息快，所以队列可以很短。如过缓冲很多消息可能会溢出到磁盘，吞吐量会下降**

<a name="lfst-1722106688956"></a>**.匹配方式：数据库通常支持二级索引和各种搜索数据的方式；消息代理按照模式匹配订阅子集**

<a name="q13l-1722106755764"></a>**.最新数据：数据库通常支持事务，基于某个时间点数据快照；消息代理不支持任意查询，有新消息会通知客户端**

<a name="v0lh-1721932568637"></a>**多个消费者**

<a name="enlv-1722191268259"></a>**负载均衡load balance: 多个客户端从同一个队列中消费。JMS中称为共享订阅shared subscripiton**

<a name="bjqd-1722191397355"></a>**扇出fan-out:将每条消息传递给多个消费者**

<a name="aoas-1721932573289"></a>**确认与重新交付**

<a name="8lsc-1723155930519"></a>**消息代理使用确认acknowlegements:客户端需显示告知代理消息处理完毕的时间，代理将消息从队列中移除。**

<a name="w6ac-1723156157534"></a>**确认丢失：需一种原子提交协议才能处理，如分布式事务。**

<a name="zlnz-1723156224601"></a>**负载均衡与重传的组合不可避免导致消息顺序(JMS，AMQP标准要求保留消息的顺序。)重新排序**

<a name="fovj-1725028626326"></a>**解决：每个消费者使用单独的队列-即不适用负载均衡功能**

<a name="3kzh-1725028667923"></a>**消息完全独立，消息重排序并不是个问题，消息之间存在因果依赖关系则是个重要问题**

<a name="9bmj-1721932438668"></a>**分区日志**

<a name="xree-1725028818863"></a>**消息传递/不留痕迹：网络数据包 和 消息代理 (可抓包和日志持久)**

<a name="sbbo-1725028858585"></a>**持久化：数据库和文件系统，显式删除前将永久记录**

<a name="n6lq-1725028981222"></a>**消息代理log-base message brokers: 既有数据库的持久化，又有消息传递的低延迟通知。**

<a name="keft-1721932590686"></a>**使用日志进行消息存储**

<a name="tlnm-1725029031868"></a>**生产者通过将消息追加到日志末尾来发送消息，消费者通过以此读取日志来接收消息。**

<a name="1606-1725029123561"></a>**Unix tail -f 监视文件被追加写入的数据就是这样工作的。**

<a name="aq8x-1725029525384"></a>**Apache Kafka, Amazon Kinesis Streams , Twitter DistributedLog都是基于日志的消息代理**

<a name="0wz5-1725029598472"></a>**Google Cloud Pub/Sub在架构上类似，单对外暴露的是JMS风格的API，而不是日志抽象**

<a name="zqkl-1725029648581"></a>**尽管写入磁盘，但通过跨多台机器分区，每秒能实现数百万消息的吞吐量，并通过复制来实现容错性。**

<a name="pr6y-1721932607757"></a>**日志与传统消息相比**

<a name="i3q5-1725115574888"></a>**天然支持扇出式消息传递：过个消费者独立读取日志，而不相互影响**

<a name="ymqj-1725115609372"></a>**负载平衡：读取消息不会从日志中删除，代理可以将整个分区分配给消费者组中的节点，而不是单挑消息分配给客户端。**

<a name="o0ft-1721932621047"></a>**消费者偏移量**

<a name="emow-1725115793168"></a>**和单领导者数据库复制中常见的日志序列号非常相似，代理无需跟踪每条消息，只需定期记录消费者偏移即可。有助于提高基于日志的系统吞吐量**

<a name="gmal-1725115911246"></a>**问题：消费者节点失效而没有记录偏移量，重启后这些消息将被处理两次。本章后续讨论。**

<a name="ipmx-1721932629330"></a>**磁盘空间使用**

<a name="5ep6-1725115987947"></a>**只追加写入日志，回收时将旧段删除或移动到归档存储**

<a name="kjgm-1725116313754"></a>**问题，消费者跟不上生产者，指向删除段，错过一些消息。**

<a name="k3hi-1725116359622"></a>**日志实现一个有限大小的缓冲区：循环缓冲区circular buffer/环形缓冲区，填满时将丢弃旧消息**

<a name="jjma-1725116440115"></a>**设 大型硬盘容量为 6TB, 顺序写入为150MB/s， 最快需要约11小时填满磁盘，之后开始覆盖旧消息。实践中的部署很少能用满磁盘的写入带宽。所以通常可保留一个几天甚至几周的日志缓冲区**

<a name="bdoa-1725116521841"></a>**以上保留多长时间的消息，日志吞吐量或多或少保持不变，因为每个消息都写入磁盘。**

<a name="rxx7-1725116637183"></a>   **而默认将消息保存在内存中，当队列很短，系统很快；当系统开始写入磁盘，就慢得多，所以吞吐量取决于保留的历史数量。**

<a name="91b6-1721932634947"></a>**当消费者更不上生产者时**

<a name="dztq-1725116764093"></a>**3种选择：丢弃信息、进行缓冲或施加背压**

<a name="mgyh-1726767519795"></a>**巨大运维优势：丢失消息仅影响当前消费者，不会中断其它消费者，可进行调试测试，不必中断生产服务。**

<a name="6tnb-1721932645175"></a>**重播旧信息**

<a name="yygs-1726767645074"></a>**删除消息：AMQP和JMS消息代理**

<a name="u81b-1726767864887"></a>**只读操作：基于日志的代理。**

<a name="opy5-1726767877078"></a>**更像上一章节的批处理。允许更多的实验操作，通过偏移量重播。**

<a name="rnwj-1721932350699"></a>**流与数据库**

<a name="ehyq-1721932450135"></a>**保持系统同步**

<a name="1ako-1721932460819"></a>**变更数据捕获**

<a name="xkpl-1721932670593"></a>**变更数据捕获的实现**

<a name="uxpn-1721932683846"></a>**初始快照**

<a name="j0w6-1721932690312"></a>**日志压缩**

<a name="5pqr-1721932694290"></a>**变更流的API支持**

<a name="qkmx-1721932472062"></a>**事件溯源**

<a name="vydq-1721932714045"></a>**从时间日志中派生出当前状态**

<a name="xbwr-1721932732154"></a>**命令和事件**

<a name="k3v8-1721932742549"></a>**状态，流和不变形**

<a name="diql-1721932751200"></a>**从同一事件日志中派生多个视图**

<a name="tzcl-1721932772042"></a>**并发控制**

<a name="urmz-1721932775107"></a>**不变性的限制**

<a name="nbcs-1721932419014"></a>**流处理**

<a name="jf4x-1721932507881"></a>**流处理的应用**

<a name="80rp-1721932792357"></a>**复合时间处理**

<a name="6jjt-1721932799443"></a>**流分析**

<a name="5iog-1721932801692"></a>**维护物化视图**

<a name="0asi-1721932807278"></a>**在流上搜索**

<a name="10bm-1721932817553"></a>**消息传递和RPC**

<a name="oca5-1721932519502"></a>**时间推理**

<a name="is6l-1721932844579"></a>**事件时间和处理时间**

<a name="aue5-1721932851975"></a>**知道什么时候准备好**

<a name="vsi1-1721932859473"></a>**你用的是谁的时钟**

<a name="gryf-1721932868260"></a>**窗口的类型**

<a name="jbet-1721932523864"></a>**流式连接**

<a name="eaux-1721932880085"></a>**流流连接(窗口连接)**

<a name="hixz-1721932915139"></a>**流表连接(流扩展)**

<a name="zbsv-1721932945841"></a>**表表连接(维护物化视图)**

<a name="xqtb-1721932962310"></a>**连接的时间依赖性**

<a name="v1om-1721932530009"></a>**容错**

<a name="pqfe-1721932996846"></a>**微批量与存档点**

<a name="elio-1721933013244"></a>**原子提交再现**

<a name="bwyd-1721933023622"></a>**幂等性**

<a name="th0v-1739552666630"></a>通过额外的元数据做成幂等的。特征数据来判断幂等。

<a name="dijm-1721933026909"></a>**失败后重建状态**

<a name="vrhs-1739552413424"></a>**12. 数据系统的未来**

<a name="ede5-1739555478378"></a>**数据集成**

<a name="72md-1739555630486"></a>**组合使用衍生数据的工具**

<a name="ws0u-1739555668111"></a>**理解流数据**

<a name="zqyv-1739555677949"></a>**衍生数据与分布式事务**

<a name="sdr6-1739555687850"></a>**全局有序的限制**

<a name="zk4p-1739555695102"></a>**排序事件以捕捉因果关系**

<a name="niva-1739555642700"></a>**批处理与流处理**

<a name="r4mh-1739555731398"></a>**维护衍生状态**

<a name="dx0m-1739555748166"></a>**应用演化后重新处理数据**

<a name="2vm7-1739555772929"></a>**Lambda架构**

<a name="6flf-1739555780198"></a>**统一批处理和流处理**

<a name="10z2-1739555560574"></a>**分拆数据库**

<a name="8wfw-1739555819342"></a>**组合使用数据存储技术**

<a name="havr-1739555874428"></a>**创建索引**

<a name="ep2e-1739555885454"></a>**一切的元数据库**

<a name="am3j-1739555961678"></a>**开展分拆工作**

<a name="trtv-1739555969624"></a>**分拆系统和集系统**

<a name="lcy6-1739555980725"></a>**少了什么？**

<a name="97j6-1739555836550"></a>**围绕数据流设计应用**

<a name="gyfk-1739555997047"></a>**应用代码所谓衍生函数**

<a name="2njs-1739556023517"></a>**应用代码的状态和分离**

<a name="pgmn-1739556032065"></a>**数据流：应用代码与状态变化的交互**

<a name="fyub-1739556046567"></a>**流处理器和服务**

<a name="dmmo-1739555844651"></a>**观察衍生数据状态**

<a name="48oq-1739556059722"></a>**物化视图和缓存**

<a name="srii-1739556068892"></a>**有状态，可离线的客户端**

<a name="zdkz-1739556083230"></a>**将状态变更推送给客户端**

<a name="70bj-1739556096239"></a>**端到端的事件流**

<a name="k9nk-1739556109784"></a>**读也是事件**

<a name="rknv-1739556117246"></a>**多分区处理数据**

<a name="ydeg-1739555534326"></a>**将事情做正确**

<a name="bool-1739556139461"></a>**为数据库使用端到端的参数**

<a name="utq9-1739556271989"></a>**正好执行一次操作**

<a name="mxfy-1739556285089"></a>**抑制重复**

<a name="9kug-1739556293281"></a>**操作标识符**

<a name="dc4e-1739556300938"></a>**在数据系统中应用端到端的思考**

<a name="cai0-1739556155120"></a>**强制约束**

<a name="jeqp-1739556425758"></a>**唯一性的约束要达成共识**

<a name="lcq0-1739556436827"></a>**基于日志消息传递中的唯一性**

<a name="dk4a-1739556687945"></a>**多分区请求处理**

<a name="dbka-1739556159893"></a>**及时性与完整性**

<a name="bmr3-1739556705098"></a>**数据流系统的正确性**

<a name="loih-1739556715504"></a>**宽松地解释约束**

<a name="v94l-1739556733932"></a>**无协调数据系统**

<a name="boru-1739556172269"></a>**信任但验证**

<a name="zgrh-1739556749129"></a>**维护完整性，尽管软件有bug**

<a name="irhz-1739556777111"></a>**不要盲目信任任何承诺**

<a name="1d8z-1739556789067"></a>**验证的文化**

<a name="61de-1739556792067"></a>**为可审计性而设计**

<a name="guck-1739556800394"></a>**端到端原则重现**

<a name="tjmv-1739556812856"></a>**利用可审计数据系统的工具**

<a name="dizf-1739555546308"></a>**做正确的事情**

<a name="va2h-1739556847417"></a>**预测性分析**

<a name="c1wq-1739556910451"></a>**偏见与分析**

<a name="ijng-1739556917694"></a>**责任与问责**

<a name="thso-1739556928624"></a>**反馈循环**

<a name="gt9r-1739556854431"></a>**隐私和追踪**

<a name="qol8-1739556939696"></a>**监视**

<a name="zgzn-1739556948482"></a>**同意与选择的自由**

<a name="ewvo-1739557089382"></a>**隐私和数据使用**

<a name="vlsj-1739557096182"></a>**数据资产与权力**

<a name="muzc-1739557108489"></a>**记着工业革命**

<a name="7mjx-1739557115858"></a>**立法与法律**

<a name="hmh3-1739556886643"></a>**本章小结**


<a name="wet9-1739555510913"></a><a name="lk3f-1721118456500"></a><a name="m2ie-1721118456661"></a>技术选型应该区分使用场景，不是技术不行，而是哪些技术更适合哪些场景。新技术的出现就是为了解决新的场景下出现的问题。 
